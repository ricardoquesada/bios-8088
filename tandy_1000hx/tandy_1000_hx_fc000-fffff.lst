F000:C000 ;
F000:C000 ; ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
F000:C000 ; º	  This file is generated by The	Interactive Disassembler (IDA)	      º
F000:C000 ; º	  Copyright (c)	2010 by	Hex-Rays SA, <support@hex-rays.com>	      º
F000:C000 ; º			   Licensed to:	Freeware version		      º
F000:C000 ; ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
F000:C000 ;
F000:C000 ; Input MD5	: DD99228F2227C358CDC1ECA21614C9EB
F000:C000
F000:C000 ; File Name	: Z:\Users\riq\progs\tandy1000-the-uni-games\misc\bios\tandy_1000_hx_bios.bin
F000:C000 ; Format	: Binary file
F000:C000 ; Base Address: F000h	Range: F0000h -	100000h	Loaded length: 10000h
F000:C000
F000:C000		  .8086
F000:C000		  .model flat
F000:C000
F000:C000		  include mama.inc
F000:C000
F000:C000 ; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
F000:C000
F000:C000 ; Segment type: Pure code
F000:C000 F000		  segment byte public 'CODE'
F000:C000		  ;org 0C000h
F000:C000		  db  21h ; !
F000:C001 aBiosRomVersion02_00_00Compatibilit db 'BIOS ROM version 02.00.00',0Dh,0Ah
F000:C001							      ;	DATA XREF: POST_init_ints_and_more+3D4o
F000:C001		  db 'Compatibility Software',0Dh,0Ah
F000:C001		  db 'Copyright (C) 1984,1985,1986,1987',0Dh,0Ah
F000:C001		  db 'Phoenix Software Associates Ltd.',0Dh,0Ah
F000:C001		  db 'and Tandy Corporation.',0Dh,0Ah
F000:C001		  db 'All rights reserved.',0Dh,0Ah,'$'
F000:C0A8 int_1f_charset_128_255 db  1Eh, 33h,3	dup( 60h), 33h,	1Eh, 0Ch, 66h,	 0,4 dup( 66h),	3Bh,   0, 0Ch, 18h, 3Ch
F000:C0A8							      ;	DATA XREF: F000:FF21o
F000:C0A8		  db  66h, 7Eh,	60h, 3Ch,   0, 3Ch,0C3h, 3Ch,	6, 3Eh,	66h, 3Fh,   0, 66h,   0, 3Ch,	6
F000:C0A8		  db  3Eh, 66h,	3Fh,   0, 30h, 18h, 3Ch,   6, 3Eh, 66h,	3Fh,   0, 18h,	 0, 3Ch,   6, 3Eh
F000:C0A8		  db  66h, 3Fh,3 dup(	0), 3Ch, 66h, 60h, 66h,	3Ch, 18h, 3Ch,0C3h, 3Ch, 66h, 7Eh, 60h
F000:C0A8		  db  3Ch,   0,	66h,   0, 3Ch, 66h, 7Eh, 60h, 3Ch,   0,	30h, 18h, 3Ch, 66h, 7Eh, 60h, 3Ch
F000:C0A8		  db	0, 66h,	  0, 38h,3 dup(	18h), 3Ch,   0,	38h,0C6h, 38h,3	dup( 18h), 3Ch,	  0, 30h
F000:C0A8		  db  18h, 38h,3 dup( 18h), 3Ch,   0, 63h, 1Ch,	36h, 63h, 7Fh,2	dup( 63h),   0,2 dup( 1Ch)
F000:C0A8		  db  3Eh, 63h,	7Fh,2 dup( 63h),   0,	6, 0Ch,	7Fh, 31h, 3Ch, 31h, 7Fh,3 dup(	 0), 7Eh
F000:C0A8		  db  1Bh, 7Eh,0D8h, 7Eh,   0, 3Fh, 6Ch,0CCh,0FFh,2 dup(0CCh),0CFh,   0, 3Ch,0C3h, 3Ch
F000:C0A8		  db 3 dup( 66h), 3Ch,	 0, 66h,   0, 3Ch,3 dup( 66h), 3Ch,   0, 30h, 18h, 3Ch,3 dup( 66h)
F000:C0A8		  db  3Ch,   0,	3Ch,0C3h,4 dup(	66h), 3Bh,   0,	30h, 18h,4 dup(	66h), 3Bh,   0,	66h,   0
F000:C0A8		  db 3 dup( 66h), 3Eh,	 6, 7Ch, 63h, 3Eh,4 dup( 63h), 3Eh,   0, 36h,5 dup( 63h), 3Eh
F000:C0A8		  db	0,2 dup( 0Ch), 3Fh,2 dup( 60h),	3Fh,2 dup( 0Ch), 1Ch, 36h, 32h,	78h, 30h, 73h
F000:C0A8		  db  7Eh,   0,2 dup( 66h), 3Ch, 7Eh, 18h, 7Eh,2 dup( 18h),0F8h,2 dup(0CCh),0FAh,0C6h
F000:C0A8		  db 0CFh,0C6h,0C7h, 0Eh,2 dup(	18h), 3Ch,3 dup( 18h), 70h, 0Ch, 18h, 3Ch,   6,	3Eh, 66h
F000:C0A8		  db  3Fh,   0,	18h, 30h, 38h,3	dup( 18h), 3Ch,	  0, 0Ch, 18h, 3Ch,3 dup( 66h),	3Ch,   0
F000:C0A8		  db  0Ch, 18h,4 dup( 66h), 3Bh,   0, 3Bh, 6Fh,	  0, 6Eh,3 dup(	33h),	0, 76h,0DEh, 73h
F000:C0A8		  db  7Bh, 6Fh,	67h, 63h,   0, 3Ch,   6, 3Eh, 66h, 3Bh,	  0,0FFh,   0, 3Ch,3 dup( 66h)
F000:C0A8		  db  3Ch,   0,0FFh,2 dup(   0), 18h,	0, 18h,	30h, 60h, 66h, 3Ch,3 dup(   0),	7Eh,2 dup( 60h)
F000:C0A8		  db 5 dup(   0), 7Eh,2	dup(   6),2 dup(   0),0C3h,0C6h,0CCh,0DEh, 33h,	66h,0CCh, 0Fh
F000:C0A8		  db 0C3h,0C6h,0CCh,0D8h, 37h, 6Fh,0CFh,   3,	0, 18h,	  0,2 dup( 18h),2 dup( 3Ch), 18h
F000:C0A8		  db	0, 33h,	66h,0CCh, 66h, 33h,3 dup(   0),0CCh, 66h, 33h, 66h,0CCh,2 dup(	 0), 22h
F000:C0A8		  db  88h, 22h,	88h, 22h, 88h, 22h, 88h, 55h,0AAh, 55h,0AAh, 55h,0AAh, 55h,0AAh,0DBh, 77h
F000:C0A8		  db 0DBh,0EEh,0DBh, 77h,0DBh,0EEh,0Ch dup( 18h),0F8h,5	dup( 18h),0F8h,	18h,0F8h,3 dup(	18h)
F000:C0A8		  db 4 dup( 36h),0F6h,3	dup( 36h),4 dup(   0),0FEh,3 dup( 36h),2 dup(	0),0F8h, 18h,0F8h
F000:C0A8		  db 3 dup( 18h),2 dup(	36h),0F6h,   6,0F6h,0Bh	dup( 36h),2 dup(   0),0FEh,   6,0F6h,5 dup( 36h)
F000:C0A8		  db 0F6h,   6,0FEh,3 dup(   0),4 dup( 36h),0FEh,3 dup(	  0),2 dup( 18h),0F8h, 18h,0F8h
F000:C0A8		  db 7 dup(   0),0F8h,7	dup( 18h), 1Fh,3 dup(	0),4 dup( 18h),0FFh,7 dup(   0),0FFh,7 dup( 18h)
F000:C0A8		  db  1Fh,3 dup( 18h),4	dup(   0),0FFh,3 dup(	0),4 dup( 18h),0FFh,5 dup( 18h), 1Fh, 18h
F000:C0A8		  db  1Fh,3 dup( 18h),4	dup( 36h), 37h,5 dup( 36h), 37h, 30h, 3Fh,5 dup(   0), 3Fh, 30h
F000:C0A8		  db  37h,5 dup( 36h),0F7h,   0,0FFh,5 dup(   0),0FFh,	 0,0F7h,5 dup( 36h), 37h, 30h
F000:C0A8		  db  37h,3 dup( 36h),2	dup(   0),0FFh,	  0,0FFh,3 dup(	  0),2 dup( 36h),0F7h,	 0,0F7h
F000:C0A8		  db 3 dup( 36h),2 dup(	18h),0FFh,   0,0FFh,3 dup(   0),4 dup( 36h),0FFh,5 dup(	  0),0FFh
F000:C0A8		  db	0,0FFh,3 dup( 18h),4 dup(   0),0FFh,7 dup( 36h), 3Fh,3 dup(   0),2 dup(	18h), 1Fh
F000:C0A8		  db  18h, 1Fh,5 dup(	0), 1Fh, 18h, 1Fh,3 dup( 18h),4	dup(   0), 3Fh,7 dup( 36h),0FFh
F000:C0A8		  db 3 dup( 36h),2 dup(	18h),0FFh, 18h,0FFh,7 dup( 18h),0F8h,7 dup(   0), 1Fh,3	dup( 18h)
F000:C0A8		  db 8 dup(0FFh),4 dup(	  0),4 dup(0FFh),8 dup(0F0h),8 dup( 0Fh),4 dup(0FFh),6 dup(   0)
F000:C0A8		  db  3Bh, 6Eh,	64h, 6Eh, 3Bh,	 0, 3Ch,2 dup( 66h), 7Ch,2 dup(	63h), 6Eh, 60h,	7Fh, 33h
F000:C0A8		  db  31h,3 dup( 30h), 78h,3 dup(   0),	7Fh,3 dup( 36h), 33h,	0, 7Eh,	66h, 30h, 18h
F000:C0A8		  db  30h, 66h,	7Eh,3 dup(   0), 3Fh,3 dup( 66h), 3Ch,3	dup(   0),4 dup( 33h), 3Eh, 60h
F000:C0A8		  db 2 dup(   0), 7Eh, 98h,3 dup( 18h),	  0, 7Eh, 18h, 3Ch,2 dup( 66h),	3Ch, 18h, 7Eh
F000:C0A8		  db  1Ch, 36h,	63h, 7Fh, 63h, 36h, 1Ch,   0, 3Ch, 66h,3 dup(0C3h), 66h,0E7h,	0, 0Eh
F000:C0A8		  db  18h, 0Ch,	3Eh,2 dup( 66h), 3Ch,3 dup(   0), 7Eh,2	dup(0DBh), 7Eh,3 dup(	0),   3
F000:C0A8		  db  3Eh, 67h,	6Bh, 73h, 3Eh, 60h, 1Ch, 30h, 60h, 7Ch,	60h, 30h, 1Ch,	 0, 3Ch,6 dup( 66h)
F000:C0A8		  db 2 dup(   0), 7Eh,	 0, 7Eh,   0, 7Eh,3 dup(   0), 18h, 7Eh, 18h,	0, 7Eh,2 dup(	0)
F000:C0A8		  db  30h, 18h,	0Ch, 18h, 30h, 7Eh,2 dup(   0),	0Ch, 18h, 30h, 18h, 0Ch, 7Eh,2 dup(   0)
F000:C0A8		  db	7,0Ch dup( 0Ch),2 dup( 6Ch), 38h,2 dup(	18h),	0, 7Eh,	  0,2 dup( 18h),2 dup(	 0)
F000:C0A8		  db  3Bh, 6Eh,	  0, 3Bh, 6Eh,2	dup(   0), 1Ch,2 dup( 36h), 1Ch,5 dup(	 0),2 dup( 1Ch)
F000:C0A8		  db 8 dup(   0),2 dup(	18h),3 dup(   0), 0Fh,3	dup( 0Ch),0ECh,	6Ch, 3Ch, 1Ch, 3Ch,4 dup( 36h)
F000:C0A8		  db 3 dup(   0), 38h, 0Ch, 18h, 30h, 3Ch,5 dup(   0),4	dup( 3Ch),0Ah dup(   0)
F000:C4A8
F000:C4A8 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:C4A8
F000:C4A8
F000:C4A8 POST_main	  proc far				      ;	CODE XREF: POST_main+1BCEj
F000:C4A8
F000:C4A8 ; FUNCTION CHUNK AT F000:E05B	SIZE 0000001E BYTES
F000:C4A8
F000:C4A8		  cli					      ;	disable	interrupts
F000:C4A9		  cld					      ;	forward	direction
F000:C4AA		  mov	  cx, 480			      ;	value for delay
F000:C4AD
F000:C4AD delay0:						      ;	CODE XREF: POST_main:delay0j
F000:C4AD		  loop	  delay0			      ;	small delay
F000:C4AF		  mov	  al, 11000b
F000:C4B1		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:C4B3		  mov	  dx, 378h
F000:C4B6		  out	  dx, al			      ;	Printer	Data Latch:
F000:C4B6							      ;	send byte to printer
F000:C4B7		  in	  al, 62h			      ;	0-2: Not used
F000:C4B7							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:C4B7							      ;	4: EEPROM data-serial read only
F000:C4B7							      ;	5: 1=Timer 2 channel out
F000:C4B7							      ;	6: Monochrome mode. 0=Color monitor
F000:C4B7							      ;	7: Reserved
F000:C4B9		  or	  al, 1000b			      ;	turn on	7.16Mhz	mode
F000:C4BB		  out	  62h, al			      ;	0-2: Not used
F000:C4BB							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:C4BB							      ;	4: EEPROM data-serial read only
F000:C4BB							      ;	5: 1=Timer 2 channel out
F000:C4BB							      ;	6: Monochrome mode. 0=Color monitor
F000:C4BB							      ;	7: Reserved
F000:C4BD		  mov	  al, 3
F000:C4BF		  mov	  dx, 3F2h
F000:C4C2		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:C4C2							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:C4C2							      ;	2:   0=reset diskette controller; 1=enable controller
F000:C4C2							      ;	3:   1=enable diskette DMA and interrupts
F000:C4C2							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:C4C3		  mov	  al, 4
F000:C4C5		  dec	  dx
F000:C4C6		  out	  dx, al
F000:C4C7		  mov	  dx, 3DAh
F000:C4CA		  in	  al, dx			      ;	Video status bits:
F000:C4CA							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:C4CA							      ;	1: 1=light pen is triggered; 0=armed
F000:C4CA							      ;	2: 1=light pen switch is open; 0=closed
F000:C4CA							      ;	3: 1=vertical sync pulse is occurring.
F000:C4CB		  mov	  dl, 0BAh ; 'º'
F000:C4CD		  in	  al, dx			      ;	Video status bits:
F000:C4CD							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:C4CD							      ;	1: 1=light pen is triggered; 0=armed
F000:C4CD							      ;	2: 1=light pen switch is open; 0=closed
F000:C4CD							      ;	3: 1=vertical sync pulse is occurring.
F000:C4CE		  xor	  al, al
F000:C4D0		  mov	  dl, 0C0h ; 'À'
F000:C4D2		  out	  dx, al			      ;	EGA: palette register: select colors for attribute AL:
F000:C4D2							      ;	0: RED
F000:C4D2							      ;	1: GREEN
F000:C4D2							      ;	2: BLUE
F000:C4D2							      ;	3: blue
F000:C4D2							      ;	4: green
F000:C4D2							      ;	5: red
F000:C4D3		  mov	  al, 100000b
F000:C4D5		  mov	  dx, 3D8h
F000:C4D8		  out	  dx, al			      ;	mode select register
F000:C4D9		  mov	  dx, 3DAh
F000:C4DC		  mov	  al, 3				      ;	select CRT mode	control
F000:C4DE		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C4DE							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C4DF		  mov	  dx, 3DEh
F000:C4E2		  mov	  al, 0
F000:C4E4		  out	  dx, al			      ;	bit 2: enable border
F000:C4E4							      ;	bit 3: set to 1	for 640x200 4 color
F000:C4E4							      ;	bit 4: set to 1	for 16 color modes
F000:C4E4							      ;	bit 5: set to 1	for 640x200 secondary pixel organization?
F000:C4E5		  mov	  dx, 3B8h
F000:C4E8		  mov	  al, 100001b
F000:C4EA		  out	  dx, al
F000:C4EB		  mov	  al, 0
F000:C4ED		  mov	  dx, 3DDh			      ;	Extended RAM page register
F000:C4F0		  out	  dx, al
F000:C4F1		  mov	  dx, 3DBh
F000:C4F4		  out	  dx, al			      ;	Video: light pen latch reset.
F000:C4F4							      ;	Any OUT	clears the latch.
F000:C4F5		  mov	  ax, 0BBE8h
F000:C4F8		  mov	  ds, ax			      ;	ds = 0xbbe8
F000:C4FA		  mov	  ds:pbbe80.shadow_reset_flag, si     ;	post reset flag
F000:C4FE		  mov	  ds:pbbe80.shadow_caps_numlock, di   ;	keyboard ctlr +	numlock	flag
F000:C502		  mov	  al, 0
F000:C504		  mov	  dx, 3DAh
F000:C507		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C507							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C508		  add	  dx, 4
F000:C50B		  out	  dx, al
F000:C50C		  mov	  dx, 3D9h
F000:C50F		  out	  dx, al			      ;	color select register
F000:C510		  mov	  al, 3
F000:C512		  mov	  dx, 3DAh
F000:C515		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C515							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C516		  xor	  al, al
F000:C518		  mov	  dx, 3DEh
F000:C51B		  out	  dx, al
F000:C51C		  mov	  al, 2
F000:C51E		  mov	  dx, 3DAh
F000:C521		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C521							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C522		  mov	  al, 0
F000:C524		  mov	  dx, 3DEh
F000:C527		  out	  dx, al
F000:C528		  mov	  al, 1
F000:C52A		  mov	  dx, 3DAh
F000:C52D		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C52D							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C52E		  mov	  al, 0FFh
F000:C530		  mov	  dx, 3DEh
F000:C533		  out	  dx, al
F000:C534		  mov	  bl, 10h
F000:C536		  mov	  dx, 3DAh
F000:C539
F000:C539 l0:							      ;	CODE XREF: POST_main+A0j
F000:C539		  mov	  al, bl
F000:C53B		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C53B							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C53C		  add	  dx, 4
F000:C53F		  out	  dx, al
F000:C540		  sub	  dx, 4
F000:C543		  inc	  bl
F000:C545		  cmp	  bl, 20h ; ' '
F000:C548		  jnz	  short	l0
F000:C54A		  xor	  al, al
F000:C54C		  out	  dx, al			      ;	Video: bits 0-1	control
F000:C54C							      ;	Feature	Control	outputs	FC0 and	FC1
F000:C54D		  mov	  ax, 0B800h
F000:C550		  mov	  es, ax
F000:C552		  mov	  dx, 3D4h			      ;	6845 index register
F000:C555		  mov	  si, offset video_6845_init_tbl_d    ;	values for ports 3d4 - 3d5 (index 0 to 0xf)
F000:C558		  mov	  di, offset ret_address0	      ;	return address
F000:C55B		  jmp	  init_video
F000:C55E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C55E
F000:C55E ret_address0:						      ;	DATA XREF: POST_main+B0o
F000:C55E		  mov	  al, 0FFh
F000:C560		  out	  0C0h,	al			      ;	DMA controller,	8237A-5.
F000:C560							      ;	channel	0 base address
F000:C560							      ;	(also sets current address)
F000:C562		  mov	  al, 0BFh ; '¿'
F000:C564		  out	  0C0h,	al			      ;	DMA controller,	8237A-5.
F000:C564							      ;	channel	0 base address
F000:C564							      ;	(also sets current address)
F000:C566		  mov	  al, 0DFh ; 'ß'
F000:C568		  out	  0C0h,	al			      ;	DMA controller,	8237A-5.
F000:C568							      ;	channel	0 base address
F000:C568							      ;	(also sets current address)
F000:C56A		  mov	  al, 9Fh ; 'Ÿ'
F000:C56C		  out	  0C0h,	al			      ;	DMA controller,	8237A-5.
F000:C56C							      ;	channel	0 base address
F000:C56C							      ;	(also sets current address)
F000:C56E		  mov	  al, 11001b
F000:C570		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:C572		  mov	  dx, 378h
F000:C575		  out	  dx, al			      ;	Printer	Data Latch:
F000:C575							      ;	send byte to printer
F000:C576		  xor	  ax, ax
F000:C578		  mov	  ss, ax
F000:C57A		  mov	  dx, 5A5Ah
F000:C57D		  xor	  bx, bx
F000:C57F		  mov	  ax, 0B000h			      ;	Monochrome video address
F000:C582		  mov	  es, ax			      ;	es = b000
F000:C584		  mov	  es:[bx], dx
F000:C587		  jmp	  short	$+2
F000:C589		  mov	  cx, es:[bx]
F000:C58C		  cmp	  cx, dx			      ;	is Monochrome ?
F000:C58E		  jnz	  short	l1
F000:C590		  mov	  ax, 2
F000:C593		  mov	  ss, ax			      ;	if monochrome ss = 2 (used ahead)
F000:C595
F000:C595 l1:							      ;	CODE XREF: POST_main+E6j
F000:C595		  mov	  ax, 0B800h
F000:C598		  mov	  es, ax			      ;	es = b800
F000:C59A		  mov	  es:[bx], dx
F000:C59D		  jmp	  short	$+2
F000:C59F		  mov	  cx, es:[bx]
F000:C5A2		  cmp	  cx, dx			      ;	is CGA / Tandy / EGA / VGA ?
F000:C5A4		  jnz	  short	l2
F000:C5A6		  mov	  ax, ss
F000:C5A8		  or	  ax, 1
F000:C5AB		  mov	  ss, ax			      ;	if so, ss = ss | 1 (used ahead)
F000:C5AD
F000:C5AD l2:							      ;	CODE XREF: POST_main+FCj
F000:C5AD		  mov	  ax, ss
F000:C5AF		  test	  al, 2
F000:C5B1		  jz	  short	l3
F000:C5B3		  mov	  ax, 0B000h
F000:C5B6		  mov	  es, ax
F000:C5B8		  mov	  dx, 3B4h			      ;	6845 index register (Hercules)
F000:C5BB		  mov	  si, offset video_6845_init_tbl_d.init_mode_7 ; BROKEN	OFFSET.	probably because this code never gets executed
F000:C5BE		  mov	  di, offset ret_address1	      ;	return address
F000:C5C1		  jmp	  init_video			      ;	Init video for Hercules
F000:C5C4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C5C4
F000:C5C4 ret_address1:						      ;	DATA XREF: POST_main+116o
F000:C5C4		  mov	  dx, 3B8h			      ;	6845 Mode Control Register (Hercules)
F000:C5C7		  mov	  al, 101001b
F000:C5C9		  out	  dx, al			      ;	Video: CRT cntrlr addr
F000:C5C9							      ;	horizontal total
F000:C5CA
F000:C5CA l3:							      ;	CODE XREF: POST_main+109j
F000:C5CA		  mov	  ax, ss
F000:C5CC		  test	  al, 1				      ;	is color ? monochrome has ss = 2
F000:C5CE		  jnz	  short	l4
F000:C5D0		  mov	  al, 11000b
F000:C5D2		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:C5D4		  mov	  dx, 378h
F000:C5D7		  out	  dx, al			      ;	Printer	Data Latch:
F000:C5D7							      ;	send byte to printer
F000:C5D8		  mov	  al, 3Fh ; '?'
F000:C5DA		  mov	  dx, 3DFh			      ;	CRT / CPU page register	(PCJr only)
F000:C5DD		  out	  dx, al
F000:C5DE		  mov	  si, offset video_6845_init_tbl_d    ;	3D4 / 3D5 values
F000:C5E1		  jmp	  short	l5
F000:C5E3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C5E3
F000:C5E3 l4:							      ;	CODE XREF: POST_main+126j
F000:C5E3		  mov	  si, offset video_6845_init_tbl_a    ;	alternatvie values for 3D4 / 3D5
F000:C5E6
F000:C5E6 l5:							      ;	CODE XREF: POST_main+139j
F000:C5E6		  mov	  ax, 0B800h
F000:C5E9		  mov	  es, ax			      ;	default: color mode. es	= b800h
F000:C5EB		  mov	  dx, 3D4h			      ;	6845 Index Register (Color)
F000:C5EE		  mov	  di, offset ret_address2	      ;	return address
F000:C5F1		  jmp	  init_video
F000:C5F4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C5F4
F000:C5F4 ret_address2:						      ;	DATA XREF: POST_main+146o
F000:C5F4		  mov	  dx, 3DAh
F000:C5F7
F000:C5F7 wait_retrace_finish:					      ;	CODE XREF: POST_main+152j
F000:C5F7		  in	  al, dx			      ;	Video status bits:
F000:C5F7							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:C5F7							      ;	1: 1=light pen is triggered; 0=armed
F000:C5F7							      ;	2: 1=light pen switch is open; 0=closed
F000:C5F7							      ;	3: 1=vertical sync pulse is occurring.
F000:C5F8		  test	  al, 8
F000:C5FA		  jnz	  short	wait_retrace_finish
F000:C5FC
F000:C5FC wait_retrace_start:					      ;	CODE XREF: POST_main+157j
F000:C5FC		  in	  al, dx			      ;	Video status bits:
F000:C5FC							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:C5FC							      ;	1: 1=light pen is triggered; 0=armed
F000:C5FC							      ;	2: 1=light pen switch is open; 0=closed
F000:C5FC							      ;	3: 1=vertical sync pulse is occurring.
F000:C5FD		  test	  al, 8
F000:C5FF		  jz	  short	wait_retrace_start
F000:C601		  mov	  al, 28h ; '('
F000:C603		  mov	  dx, 3D8h
F000:C606		  out	  dx, al
F000:C607		  mov	  ax, ss
F000:C609		  test	  al, 2
F000:C60B		  jz	  short	l6
F000:C60D		  in	  al, 62h			      ;	0-2: Not used
F000:C60D							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:C60D							      ;	4: EEPROM data-serial read only
F000:C60D							      ;	5: 1=Timer 2 channel out
F000:C60D							      ;	6: Monochrome mode. 0=Color monitor
F000:C60D							      ;	7: Reserved
F000:C60F		  test	  al, 1000000b
F000:C611		  jz	  short	l6			      ;	color monitor?
F000:C613		  mov	  ax, 0B000h			      ;	it is monochrome
F000:C616		  mov	  es, ax			      ;	es = b000h
F000:C618
F000:C618 l6:							      ;	CODE XREF: POST_main+163j
F000:C618							      ;	POST_main+169j
F000:C618		  mov	  ax, 0BBE8h
F000:C61B		  mov	  ds, ax			      ;	ds = bbe8h (tmp	place for vars?)
F000:C61D		  mov	  si, ds:pbbe80.shadow_reset_flag
F000:C621		  mov	  bx, ds:pbbe80.shadow_caps_numlock   ;	save values. memory in bbe8 will get destroyed
F000:C625		  mov	  ax, 0
F000:C628
F000:C628 l7:							      ;	CODE XREF: POST_main+1A8j
F000:C628		  mov	  di, 0
F000:C62B
F000:C62B l8:							      ;	CODE XREF: POST_main+18Cj
F000:C62B		  mov	  [di],	ax			      ;	fill with 0 from bbe8:0000 to bbe8:0180	(until 0xbc000)
F000:C62D		  add	  di, 2
F000:C630		  cmp	  di, 180h
F000:C634		  jb	  short	l8
F000:C636		  mov	  cx, 118h
F000:C639
F000:C639 delay1:						      ;	CODE XREF: POST_main:delay1j
F000:C639		  loop	  delay1
F000:C63B		  mov	  di, 0
F000:C63E
F000:C63E l9:							      ;	CODE XREF: POST_main+1A3j
F000:C63E		  mov	  dx, [di]			      ;	verify that memory is working
F000:C640		  cmp	  ax, dx			      ;	ax == dx == 0
F000:C642		  jnz	  short	video_error
F000:C644		  add	  di, 2
F000:C647		  cmp	  di, 180h
F000:C64B		  jb	  short	l9
F000:C64D		  add	  ax, 5555h
F000:C650		  jnb	  short	l7			      ;	do the test a few times
F000:C652		  mov	  ds:pbbe80.shadow_reset_flag, si
F000:C656		  mov	  ds:pbbe80.shadow_caps_numlock, bx   ;	restore	values
F000:C65A		  jmp	  near ptr POST_test_port_0378
F000:C65D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C65D
F000:C65D video_error:						      ;	CODE XREF: POST_main+19Aj
F000:C65D		  mov	  ss, ax
F000:C65F		  mov	  sp, dx
F000:C661		  mov	  ax, di
F000:C663		  mov	  ds, ax
F000:C665		  mov	  si, offset aVidAddrBaseBbe	      ;	"Vid Addr:   Base:BBE80h Off:  xxxxh"
F000:C668		  mov	  di, 370h
F000:C66B
F000:C66B print_error_msg:					      ;	CODE XREF: POST_main+1CBj
F000:C66B		  lods	  byte ptr cs:[si]
F000:C66D		  or	  al, al			      ;	asciiz
F000:C66F		  jz	  short	l10
F000:C671		  stosb
F000:C672		  inc	  di
F000:C673		  jmp	  short	print_error_msg
F000:C675 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C675
F000:C675 l10:							      ;	CODE XREF: POST_main+1C7j
F000:C675		  sub	  di, 0Ah
F000:C678		  mov	  ax, ds
F000:C67A		  mov	  si, offset l11
F000:C67D		  jmp	  print_number_in_bcd
F000:C680 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C680
F000:C680 l11:							      ;	DATA XREF: POST_main+1D2o
F000:C680		  mov	  si, offset aDataErrWritten	      ;	"Data Err: Written: xxxxh Read:	xxxxh"
F000:C683		  mov	  di, 3C0h
F000:C686
F000:C686 l12:							      ;	CODE XREF: POST_main+1E6j
F000:C686		  lods	  byte ptr cs:[si]
F000:C688		  or	  al, al
F000:C68A		  jz	  short	l13
F000:C68C		  stosb
F000:C68D		  inc	  di
F000:C68E		  jmp	  short	l12
F000:C690 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C690
F000:C690 l13:							      ;	CODE XREF: POST_main+1E2j
F000:C690		  sub	  di, 22h ; '"'
F000:C693		  mov	  ax, ss
F000:C695		  mov	  si, offset l14		      ;	return address
F000:C698		  jmp	  print_number_in_bcd
F000:C69B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C69B
F000:C69B l14:							      ;	DATA XREF: POST_main+1EDo
F000:C69B		  add	  di, 10h
F000:C69E		  mov	  ax, sp
F000:C6A0		  mov	  si, offset ret_address3	      ;	return address
F000:C6A3		  jmp	  print_number_in_bcd
F000:C6A6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C6A6
F000:C6A6 ret_address3:						      ;	CODE XREF: POST_main:ret_address3j
F000:C6A6							      ;	DATA XREF: POST_main+1F8o
F000:C6A6		  jmp	  short	ret_address3		      ;	infinite loop
F000:C6A6 POST_main	  endp
F000:C6A6
F000:C6A6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C6A8 aVidAddrBaseBbe db 'Vid Addr:   Base:BBE80h Off:  xxxxh',0  ; DATA XREF: POST_main+1BDo
F000:C6CC aDataErrWritten db 'Data Err: Written: xxxxh Read: xxxxh',0 ; DATA XREF: POST_main:l11o
F000:C6F1
F000:C6F1 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:C6F1
F000:C6F1
F000:C6F1 POST_test_port_0378 proc far				      ;	CODE XREF: POST_main+1B2j
F000:C6F1		  mov	  ax, 0BBE8h
F000:C6F4		  mov	  ds, ax			      ;	ds = bbe8
F000:C6F6		  mov	  ax, ss
F000:C6F8		  mov	  ds:pbbe80.tmp_reg6_byte, al
F000:C6FB		  mov	  word ptr ds:pbbe80.tmp_es, es
F000:C6FF		  mov	  ax, 0BBF0h			      ;	use video memory as stack segment
F000:C702		  mov	  ss, ax			      ;	ss = bbf0
F000:C704		  mov	  sp, 0FEh ; 'ş'                      ; stack: bbf0:00fe
F000:C707		  mov	  dx, 378h
F000:C70A		  in	  al, dx			      ;	Printer	Data Latch:
F000:C70A							      ;	fetch last byte	sent
F000:C70B		  sub	  al, 2
F000:C70D		  and	  al, 0F3h
F000:C70F		  mov	  ds:pbbe80.tmp_reg5_byte, al
F000:C712		  mov	  dx, 378h
F000:C715		  mov	  al, 55h ; 'U'                       ; send char 55h
F000:C717		  out	  dx, al			      ;	Printer	Data Latch:
F000:C717							      ;	send byte to printer
F000:C718		  jmp	  short	$+2
F000:C71A		  in	  al, dx			      ;	Printer	Data Latch:
F000:C71A							      ;	fetch last byte	sent
F000:C71B		  cmp	  al, 55h ; 'U'                       ; make sure last byte sent was 55h
F000:C71D		  jz	  short	near ptr POST_test_pic_8253
F000:C71F		  mov	  si, offset aErrIOOfPort378	      ;	"Err I/O of port 378h"
F000:C722		  mov	  di, 3C0h			      ;	screen offset
F000:C725		  call	  print_asciiz
F000:C728
F000:C728 halt:							      ;	CODE XREF: POST_test_port_0378:haltj
F000:C728		  jmp	  short	halt
F000:C728 POST_test_port_0378 endp
F000:C728
F000:C728 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C72A aErrIOOfPort378 db 'Err I/O of port 378h',0                 ; DATA XREF: POST_test_port_0378+2Eo
F000:C73F
F000:C73F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:C73F
F000:C73F
F000:C73F POST_test_pic_8253 proc far				      ;	CODE XREF: POST_test_port_0378+2Cj
F000:C73F		  xor	  al, al
F000:C741		  out	  81h, al			      ;	DMA page register 74LS612:
F000:C741							      ;	Channel	2 (diskette DMA)  (address bits	16-23)
F000:C743		  out	  82h, al			      ;	DMA page register 74LS612:
F000:C743							      ;	Channel	3 (hard	disk DMA) (address bits	16-23)
F000:C745		  out	  83h, al			      ;	DMA page register 74LS612:
F000:C745							      ;	Channel	1 (address bits	16-23)
F000:C747		  out	  0Dh, al			      ;	DMA controller,	8237A-5.
F000:C747							      ;	master clear.
F000:C747							      ;	Any OUT	clears the ctrlr (must be re-initialized)
F000:C749		  mov	  cx, 2
F000:C74C
F000:C74C delay0:						      ;	CODE XREF: POST_test_pic_8253:delay0j
F000:C74C		  loop	  delay0
F000:C74E		  mov	  al, 4
F000:C750		  out	  8, al				      ;	DMA 8237A-5. cmd reg bits:
F000:C750							      ;	0: enable mem-to-mem DMA
F000:C750							      ;	1: enable Ch0 address hold
F000:C750							      ;	2: disable controller
F000:C750							      ;	3: compressed timing mode
F000:C750							      ;	4: enable rotating priority
F000:C750							      ;	5: extended write mode;	0=late write
F000:C750							      ;	6: DRQ sensing - active	high
F000:C750							      ;	7: DACK	sensing	- active high
F000:C752		  mov	  dx, 0
F000:C755		  mov	  ah, 0
F000:C757		  mov	  cx, 1
F000:C75A
F000:C75A l0:							      ;	CODE XREF: POST_test_pic_8253+2Ej
F000:C75A		  mov	  al, cl
F000:C75C		  out	  dx, al
F000:C75D		  mov	  al, ah
F000:C75F		  out	  dx, al
F000:C760		  nop
F000:C761		  in	  al, dx
F000:C762		  cmp	  al, cl
F000:C764		  jnz	  short	l2
F000:C766		  in	  al, dx
F000:C767		  cmp	  al, 0
F000:C769		  jnz	  short	l2
F000:C76B		  rcl	  cl, 1
F000:C76D		  jnb	  short	l0
F000:C76F		  mov	  dx, 0
F000:C772		  xor	  al, al
F000:C774
F000:C774 l1:							      ;	CODE XREF: POST_test_pic_8253+3Bj
F000:C774		  out	  dx, al
F000:C775		  out	  dx, al
F000:C776		  inc	  dx
F000:C777		  cmp	  dx, 8
F000:C77A		  jnz	  short	l1
F000:C77C		  mov	  dx, 0Bh
F000:C77F		  mov	  al, 58h ; 'X'
F000:C781		  out	  dx, al			      ;	DMA 8237A-5. mode register bits:
F000:C781							      ;	0-1: channel (00=0; 01=1; 10=2;	11=3)
F000:C781							      ;	2-3: transfer type (00=verify=Nop; 01=write; 10=read)
F000:C781							      ;	4: 1=enable auto-initialization
F000:C781							      ;	5: 1=address increment;	0=address decrement
F000:C781							      ;	6-7: 00=demand mode; 01=single;	10=block; 11=cascade
F000:C782		  mov	  al, 49h ; 'I'
F000:C784		  out	  dx, al			      ;	DMA 8237A-5. mode register bits:
F000:C784							      ;	0-1: channel (00=0; 01=1; 10=2;	11=3)
F000:C784							      ;	2-3: transfer type (00=verify=Nop; 01=write; 10=read)
F000:C784							      ;	4: 1=enable auto-initialization
F000:C784							      ;	5: 1=address increment;	0=address decrement
F000:C784							      ;	6-7: 00=demand mode; 01=single;	10=block; 11=cascade
F000:C785		  mov	  al, 4Ah ; 'J'
F000:C787		  out	  dx, al			      ;	DMA 8237A-5. mode register bits:
F000:C787							      ;	0-1: channel (00=0; 01=1; 10=2;	11=3)
F000:C787							      ;	2-3: transfer type (00=verify=Nop; 01=write; 10=read)
F000:C787							      ;	4: 1=enable auto-initialization
F000:C787							      ;	5: 1=address increment;	0=address decrement
F000:C787							      ;	6-7: 00=demand mode; 01=single;	10=block; 11=cascade
F000:C788		  mov	  al, 4Bh ; 'K'
F000:C78A		  out	  dx, al			      ;	DMA 8237A-5. mode register bits:
F000:C78A							      ;	0-1: channel (00=0; 01=1; 10=2;	11=3)
F000:C78A							      ;	2-3: transfer type (00=verify=Nop; 01=write; 10=read)
F000:C78A							      ;	4: 1=enable auto-initialization
F000:C78A							      ;	5: 1=address increment;	0=address decrement
F000:C78A							      ;	6-7: 00=demand mode; 01=single;	10=block; 11=cascade
F000:C78B		  mov	  al, 0Eh
F000:C78D		  out	  0Fh, al			      ;	DMA controller,	8237A-5.
F000:C78D							      ;	master clear. Clear or mask any	or
F000:C78D							      ;	all of the channels. Bits:
F000:C78D							      ;	0: 1=mask channel 0; 0=enable
F000:C78D							      ;	1: 1=mask channel 1;
F000:C78D							      ;	2: 1=mask channel 2;
F000:C78D							      ;	3: 1=mask channel 3;
F000:C78F		  mov	  al, 0FFh
F000:C791		  out	  1, al				      ;	DMA controller,	8237A-5.
F000:C791							      ;	channel	0 base address and word	count
F000:C793		  mov	  al, 0
F000:C795		  out	  8, al				      ;	DMA 8237A-5. cmd reg bits:
F000:C795							      ;	0: enable mem-to-mem DMA
F000:C795							      ;	1: enable Ch0 address hold
F000:C795							      ;	2: disable controller
F000:C795							      ;	3: compressed timing mode
F000:C795							      ;	4: enable rotating priority
F000:C795							      ;	5: extended write mode;	0=late write
F000:C795							      ;	6: DRQ sensing - active	high
F000:C795							      ;	7: DACK	sensing	- active high
F000:C797
F000:C797 l2:							      ;	CODE XREF: POST_test_pic_8253+25j
F000:C797							      ;	POST_test_pic_8253+2Aj
F000:C797		  mov	  ch, 0
F000:C799
F000:C799 l3:							      ;	CODE XREF: POST_test_pic_8253+8Aj
F000:C799							      ;	POST_test_pic_8253+99j
F000:C799		  mov	  al, 10h
F000:C79B		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C79B							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C79B							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C79B							      ;	3: 1=read high switches
F000:C79B							      ;	4: 0=enable RAM	parity checking
F000:C79B							      ;	5: 0=enable I/O	channel	check
F000:C79B							      ;	6: 0=hold keyboard clock low
F000:C79B							      ;	7: 0=enable kbrd
F000:C79D		  mov	  cl, 1
F000:C79F
F000:C79F l4:							      ;	CODE XREF: POST_test_pic_8253+85j
F000:C79F		  mov	  al, 0B0h ; '°'
F000:C7A1		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7A3		  mov	  al, 0FFh
F000:C7A5		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7A7		  mov	  al, cl
F000:C7A9		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7AB		  mov	  al, 80h ; '€'
F000:C7AD		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7AF		  mov	  al, 0B0h ; '°'
F000:C7B1		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7B3		  in	  al, 42h			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7B5		  jmp	  short	$+2
F000:C7B7		  in	  al, 42h			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7B9		  cmp	  ch, 1
F000:C7BC		  jz	  short	l5
F000:C7BE		  cmp	  al, cl
F000:C7C0		  jnz	  short	l6
F000:C7C2
F000:C7C2 l5:							      ;	CODE XREF: POST_test_pic_8253+7Dj
F000:C7C2		  rcl	  cl, 1
F000:C7C4		  jnb	  short	l4
F000:C7C6		  cmp	  ch, 1
F000:C7C9		  jz	  short	l3
F000:C7CB		  jmp	  short	l7
F000:C7CD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C7CD
F000:C7CD l6:							      ;	CODE XREF: POST_test_pic_8253+81j
F000:C7CD		  mov	  si, offset aErrIOOf8253	      ;	"Err I/O of 8253"
F000:C7D0		  mov	  di, 3C0h
F000:C7D3		  call	  print_asciiz
F000:C7D6		  mov	  ch, 1
F000:C7D8		  jmp	  short	l3
F000:C7D8 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C7DA aErrIOOf8253	  db 'Err I/O of 8253',0                      ; DATA XREF: POST_test_pic_8253:l6o
F000:C7EA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C7EA
F000:C7EA l7:							      ;	CODE XREF: POST_test_pic_8253+8Cj
F000:C7EA		  mov	  al, 74h ; 't'
F000:C7EC		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7EE		  mov	  al, 12h
F000:C7F0		  out	  41h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7F2		  mov	  al, 0
F000:C7F4		  out	  41h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7F6		  mov	  cx, 32h ; '2'
F000:C7F9
F000:C7F9 delay1:						      ;	CODE XREF: POST_test_pic_8253:delay1j
F000:C7F9		  loop	  delay1
F000:C7FB		  mov	  al, 30h ; '0'
F000:C7FD		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C7FF		  mov	  al, 0
F000:C801		  out	  40h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C803		  jmp	  short	$+2
F000:C805		  out	  40h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C807		  mov	  al, 0B0h ; '°'
F000:C809		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C80B		  mov	  al, 0
F000:C80D		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C80F		  jmp	  short	$+2
F000:C811		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:C813		  mov	  ax, 0
F000:C816		  mov	  es, ax			      ;	es = 0
F000:C818		  xor	  si, si
F000:C81A
F000:C81A l8:							      ;	CODE XREF: POST_test_pic_8253+10Aj
F000:C81A		  mov	  ax, es:[si]
F000:C81D		  not	  ax
F000:C81F		  mov	  es:[si], ax			      ;	[es:0000] = ! [es:0000]	???
F000:C822		  mov	  cx, 118h
F000:C825
F000:C825 delay2:						      ;	CODE XREF: POST_test_pic_8253:delay2j
F000:C825		  loop	  delay2			      ;	delay
F000:C827		  cmp	  ax, es:[si]
F000:C82A		  jnz	  short	l10
F000:C82C		  not	  ax
F000:C82E		  mov	  es:[si], ax			      ;	[es:0000] = ! [es:0000]
F000:C831		  mov	  cx, 118h
F000:C834
F000:C834 delay3:						      ;	CODE XREF: POST_test_pic_8253:delay3j
F000:C834		  loop	  delay3			      ;	delay
F000:C836		  cmp	  ax, es:[si]
F000:C839		  jnz	  short	l10
F000:C83B
F000:C83B l9:							      ;	CODE XREF: POST_test_pic_8253+122j
F000:C83B		  mov	  bx, es
F000:C83D		  add	  bx, 1000h			      ;	es += 1000h (+64k)
F000:C841		  mov	  es, bx
F000:C843		  cmp	  bx, 6000h
F000:C847		  jz	  short	l13
F000:C849		  jmp	  short	l8
F000:C84B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C84B
F000:C84B l10:							      ;	CODE XREF: POST_test_pic_8253+EBj
F000:C84B							      ;	POST_test_pic_8253+FAj
F000:C84B		  xor	  ax, es:[si]
F000:C84E		  mov	  bl, 0
F000:C850		  mov	  cx, 11h
F000:C853
F000:C853 l11:							      ;	CODE XREF: POST_test_pic_8253+119j
F000:C853							      ;	POST_test_pic_8253+11Dj
F000:C853		  dec	  cx
F000:C854		  jcxz	  short	l12
F000:C856		  rcl	  ax, 1
F000:C858		  jnb	  short	l11
F000:C85A		  inc	  bl
F000:C85C		  jmp	  short	l11
F000:C85E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C85E
F000:C85E l12:							      ;	CODE XREF: POST_test_pic_8253+115j
F000:C85E		  cmp	  bl, 0
F000:C861		  jb	  short	l9
F000:C863
F000:C863 l13:							      ;	CODE XREF: POST_test_pic_8253+108j
F000:C863		  mov	  dx, es
F000:C865		  mov	  bl, dh
F000:C867		  mov	  al, dh
F000:C869		  mov	  cl, 4
F000:C86B		  shr	  al, cl
F000:C86D		  mov	  cl, al
F000:C86F		  add	  al, ds:pbbe80.tmp_reg5_byte
F000:C873		  mov	  bh, al
F000:C875		  mov	  ds:pbbe80, dx
F000:C879		  mov	  ds:pbbe80.tmp_reg5_byte, cl
F000:C87D		  xor	  si, si
F000:C87F		  xor	  di, di
F000:C881		  mov	  ax, 7C00h
F000:C884		  mov	  es, ax			      ;	es = 7c00h (dst)
F000:C886		  mov	  ax, 9C00h
F000:C889		  mov	  ds, ax			      ;	ds = 9c00h (src)
F000:C88B		  mov	  cx, 4000h
F000:C88E		  rep movsb				      ;	copy 4k	from 9c00:0000h	to 7c00:0000h
F000:C890		  mov	  ax, 0BBE8h
F000:C893		  mov	  ds, ax			      ;	ds = bbe8h (restore value)
F000:C895		  or	  bl, bl
F000:C897		  jz	  short	l14
F000:C899		  cmp	  bl, 40h ; '@'
F000:C89C		  jnz	  short	l15
F000:C89E
F000:C89E l14:							      ;	CODE XREF: POST_test_pic_8253+158j
F000:C89E		  mov	  al, 28h ; '('
F000:C8A0		  jmp	  short	l16
F000:C8A2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C8A2
F000:C8A2 l15:							      ;	CODE XREF: POST_test_pic_8253+15Dj
F000:C8A2		  mov	  al, 0
F000:C8A4
F000:C8A4 l16:							      ;	CODE XREF: POST_test_pic_8253+161j
F000:C8A4		  mov	  dx, 3DDh			      ;	Extended RAM register
F000:C8A7		  out	  dx, al
F000:C8A8		  mov	  al, bh
F000:C8AA		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:C8AC		  mov	  es, word ptr ds:pbbe80.tmp_es
F000:C8B0		  mov	  si, offset aMemorySizeK	      ;	"Memory	Size =	  k"
F000:C8B3		  mov	  di, 4
F000:C8B6		  call	  print_asciiz
F000:C8B9		  mov	  al, ds:pbbe80.tmp_reg5_byte
F000:C8BC		  mov	  cx, 3
F000:C8BF		  mul	  cl
F000:C8C1		  xor	  ah, ah
F000:C8C3		  mov	  si, ax
F000:C8C5		  mov	  bx, offset aMemoryValues
F000:C8C8		  mov	  di, 20h ; ' '
F000:C8CB
F000:C8CB l17:							      ;	CODE XREF: POST_test_pic_8253+192j
F000:C8CB		  mov	  al, cs:[bx+si]
F000:C8CE		  stosb					      ;	print memory value to screen
F000:C8CF		  inc	  di
F000:C8D0		  inc	  si
F000:C8D1		  loop	  l17
F000:C8D3		  jmp	  short	near ptr POST_test_port_61_kbd
F000:C8D3 POST_test_pic_8253 endp
F000:C8D3
F000:C8D3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C8D5 aMemorySizeK	  db 'Memory Size =    k',0                   ; DATA XREF: POST_test_pic_8253+171o
F000:C8E8 aMemoryValues	  db  32h, 35h,	36h, 33h, 32h, 30h, 33h, 38h,3 dup( 34h), 38h, 35h, 31h, 32h, 35h, 37h
F000:C8E8							      ;	DATA XREF: POST_test_pic_8253+186o
F000:C8E8		  db 2 dup( 36h), 34h, 30h
F000:C8FD
F000:C8FD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:C8FD
F000:C8FD
F000:C8FD POST_test_port_61_kbd	proc far			      ;	CODE XREF: POST_test_pic_8253+194j
F000:C8FD							      ;	POST_test_port_61_kbd+1Cj
F000:C8FD		  mov	  cl, 1
F000:C8FF
F000:C8FF l0:							      ;	CODE XREF: POST_test_port_61_kbd+Fj
F000:C8FF		  mov	  al, cl
F000:C901		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C901							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C901							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C901							      ;	3: 1=read high switches
F000:C901							      ;	4: 0=enable RAM	parity checking
F000:C901							      ;	5: 0=enable I/O	channel	check
F000:C901							      ;	6: 0=hold keyboard clock low
F000:C901							      ;	7: 0=enable kbrd
F000:C903		  nop
F000:C904		  in	  al, 61h			      ;	PC/XT PPI port B bits:
F000:C904							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C904							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C904							      ;	3: 1=read high switches
F000:C904							      ;	4: 0=enable RAM	parity checking
F000:C904							      ;	5: 0=enable I/O	channel	check
F000:C904							      ;	6: 0=hold keyboard clock low
F000:C904							      ;	7: 0=enable kbrd
F000:C906		  cmp	  al, cl
F000:C908		  jnz	  short	l1
F000:C90A		  rcl	  cl, 1
F000:C90C		  jnb	  short	l0
F000:C90E		  jmp	  short	near ptr POST_test_8259
F000:C910 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C910
F000:C910 l1:							      ;	CODE XREF: POST_test_port_61_kbd+Bj
F000:C910		  mov	  si, offset aErrIOFromKbdPo	      ;	"Err I/O from kbd port 61h"
F000:C913		  mov	  di, 3C0h
F000:C916		  call	  print_asciiz
F000:C919		  jmp	  short	near ptr POST_test_port_61_kbd
F000:C919 POST_test_port_61_kbd	endp
F000:C919
F000:C919 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C91B aErrIOFromKbdPo db 'Err I/O from kbd port 61h',0            ; DATA XREF: POST_test_port_61_kbd:l1o
F000:C935
F000:C935 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:C935
F000:C935
F000:C935 POST_test_8259  proc far				      ;	CODE XREF: POST_test_port_61_kbd+11j
F000:C935		  mov	  al, 0C0h ; 'À'
F000:C937		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C937							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C937							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C937							      ;	3: 1=read high switches
F000:C937							      ;	4: 0=enable RAM	parity checking
F000:C937							      ;	5: 0=enable I/O	channel	check
F000:C937							      ;	6: 0=hold keyboard clock low
F000:C937							      ;	7: 0=enable kbrd
F000:C939		  mov	  al, 40h ; '@'
F000:C93B		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C93B							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C93B							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C93B							      ;	3: 1=read high switches
F000:C93B							      ;	4: 0=enable RAM	parity checking
F000:C93B							      ;	5: 0=enable I/O	channel	check
F000:C93B							      ;	6: 0=hold keyboard clock low
F000:C93B							      ;	7: 0=enable kbrd
F000:C93D		  mov	  al, 13h
F000:C93F		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:C941		  mov	  al, 8
F000:C943		  mov	  dx, 21h ; '!'
F000:C946		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:C947		  mov	  al, 1
F000:C949		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:C94A		  mov	  al, 0FFh
F000:C94C		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:C94D		  mov	  cl, al
F000:C94F		  mov	  al, 40h ; '@'
F000:C951		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:C953		  in	  al, dx			      ;	Interrupt controller, 8259A.
F000:C954		  cmp	  al, cl
F000:C956		  jnz	  short	l2
F000:C958		  mov	  cl, 1
F000:C95A
F000:C95A l0:							      ;	CODE XREF: POST_test_8259+2Fj
F000:C95A		  mov	  al, cl
F000:C95C		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:C95D		  in	  al, dx			      ;	Interrupt controller, 8259A.
F000:C95E		  cmp	  al, cl
F000:C960		  jnz	  short	l2
F000:C962		  rcl	  cl, 1
F000:C964		  jnb	  short	l0
F000:C966		  mov	  al, 0FDh ; 'ı'
F000:C968		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:C969		  mov	  cl, al
F000:C96B		  in	  al, dx			      ;	Interrupt controller, 8259A.
F000:C96C		  cmp	  al, cl
F000:C96E		  jnz	  short	l2
F000:C970		  mov	  cx, 8
F000:C973
F000:C973 l1:							      ;	CODE XREF: POST_test_8259+42j
F000:C973		  mov	  al, 20h ; ' '
F000:C975		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:C977		  loop	  l1
F000:C979		  jmp	  short	l3
F000:C97B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C97B
F000:C97B l2:							      ;	CODE XREF: POST_test_8259+21j
F000:C97B							      ;	POST_test_8259+2Bj
F000:C97B							      ;	POST_test_8259+39j
F000:C97B		  mov	  si, offset aErrIOOf8259	      ;	"Err I/O of 8259"
F000:C97E		  mov	  di, 3C0h
F000:C981		  call	  print_asciiz
F000:C984
F000:C984 halt0:						      ;	CODE XREF: POST_test_8259:halt0j
F000:C984		  jmp	  short	halt0
F000:C984 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C986 aErrIOOf8259	  db 'Err I/O of 8259',0                      ; DATA XREF: POST_test_8259:l2o
F000:C996		  db 0EBh ; ë
F000:C997		  db 0FEh ; ş
F000:C998 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C998
F000:C998 l3:							      ;	CODE XREF: POST_test_8259+44j
F000:C998		  mov	  al, 0
F000:C99A		  out	  67h, al			      ;	port 67h ???
F000:C99C		  mov	  cx, 11h
F000:C99F
F000:C99F l4:							      ;	CODE XREF: POST_test_8259+7Fj
F000:C99F		  xchg	  bx, cx
F000:C9A1		  mov	  al, 0C0h ; 'À'
F000:C9A3		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C9A3							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C9A3							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C9A3							      ;	3: 1=read high switches
F000:C9A3							      ;	4: 0=enable RAM	parity checking
F000:C9A3							      ;	5: 0=enable I/O	channel	check
F000:C9A3							      ;	6: 0=hold keyboard clock low
F000:C9A3							      ;	7: 0=enable kbrd
F000:C9A5		  mov	  al, 20h ; ' '
F000:C9A7		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:C9A9		  mov	  al, 40h ; '@'
F000:C9AB		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:C9AB							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:C9AB							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:C9AB							      ;	3: 1=read high switches
F000:C9AB							      ;	4: 0=enable RAM	parity checking
F000:C9AB							      ;	5: 0=enable I/O	channel	check
F000:C9AB							      ;	6: 0=hold keyboard clock low
F000:C9AB							      ;	7: 0=enable kbrd
F000:C9AD		  mov	  cx, 0A9h ; '©'
F000:C9B0
F000:C9B0 delay0:						      ;	CODE XREF: POST_test_8259:delay0j
F000:C9B0		  loop	  delay0
F000:C9B2		  xchg	  bx, cx
F000:C9B4		  loop	  l4
F000:C9B6		  mov	  ax, 1
F000:C9B9		  mov	  ds:pbbe80.tmp_reg3, ax
F000:C9BC		  xor	  ax, ax
F000:C9BE		  mov	  ds:pbbe80.tmp_reg2, ax
F000:C9C1		  mov	  ax, 7000h			      ;	int 15h, ah=70h. Read from EEPROM
F000:C9C4		  mov	  bl, 1
F000:C9C6		  pushf
F000:C9C7		  push	  cs
F000:C9C8		  mov	  dx, offset l5
F000:C9CB		  push	  dx
F000:C9CC		  jmp	  int_15_handler_bis
F000:C9CF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C9CF
F000:C9CF l5:							      ;	DATA XREF: POST_test_8259+93o
F000:C9CF		  test	  dl, 20h
F000:C9D2		  jnz	  short	test_memory_ram
F000:C9D4		  cmp	  word ptr ds:pbbe80.shadow_reset_flag,	4321h ;	preserve memory	?
F000:C9DA		  jz	  short	test_memory_ram
F000:C9DC		  jmp	  clean_memory_ram
F000:C9DF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:C9DF
F000:C9DF test_memory_ram:					      ;	CODE XREF: POST_test_8259+9Dj
F000:C9DF							      ;	POST_test_8259+A5j
F000:C9DF		  mov	  cx, 5A5Ah
F000:C9E2		  mov	  bp, 0
F000:C9E5
F000:C9E5 l6:							      ;	CODE XREF: POST_test_8259+DBj
F000:C9E5							      ;	POST_test_8259+ECj
F000:C9E5		  mov	  bx, 0FFFEh
F000:C9E8
F000:C9E8 l7:							      ;	CODE XREF: POST_test_8259+F1j
F000:C9E8		  mov	  es, bp			      ;	es = 0
F000:C9EA		  mov	  si, 0FFFEh
F000:C9ED
F000:C9ED l8:							      ;	CODE XREF: POST_test_8259+C5j
F000:C9ED		  mov	  ax, bx
F000:C9EF		  xor	  ax, cx
F000:C9F1		  xor	  ax, bp
F000:C9F3		  mov	  es:[bx], ax			      ;	fill chunk of 64k RAM with garbage
F000:C9F6		  dec	  bx
F000:C9F7		  dec	  bx
F000:C9F8		  cmp	  bx, si
F000:C9FA		  jnz	  short	l8
F000:C9FC		  add	  bp, 1000h
F000:CA00		  test	  byte ptr ds:pbbe80.tmp_reg6_byte, 1
F000:CA05		  jz	  short	l9
F000:CA07		  mov	  bx, 4000h
F000:CA0A		  add	  bx, ds:pbbe80
F000:CA0E		  cmp	  bx, bp
F000:CA10		  jnz	  short	l6
F000:CA12		  jmp	  short	l11
F000:CA14 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA14
F000:CA14 l9:							      ;	CODE XREF: POST_test_8259+D0j
F000:CA14		  mov	  bx, 3000h
F000:CA17		  add	  bx, ds:pbbe80
F000:CA1B		  cmp	  bx, bp
F000:CA1D		  jz	  short	l10
F000:CA1F		  jb	  short	l11
F000:CA21		  jmp	  short	l6
F000:CA23 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA23
F000:CA23 l10:							      ;	CODE XREF: POST_test_8259+E8j
F000:CA23		  mov	  bx, 0BFFEh
F000:CA26		  jmp	  short	l7
F000:CA28 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA28
F000:CA28 l11:							      ;	CODE XREF: POST_test_8259+DDj
F000:CA28							      ;	POST_test_8259+EAj
F000:CA28		  mov	  bp, 0
F000:CA2B
F000:CA2B l12:							      ;	CODE XREF: POST_test_8259+128j
F000:CA2B							      ;	POST_test_8259+139j
F000:CA2B		  mov	  bx, 0FFFEh
F000:CA2E
F000:CA2E l13:							      ;	CODE XREF: POST_test_8259+112j
F000:CA2E							      ;	POST_test_8259+13Ej
F000:CA2E		  mov	  es, bp
F000:CA30		  mov	  ax, bx
F000:CA32		  xor	  ax, cx
F000:CA34		  xor	  ax, bp
F000:CA36		  mov	  si, ax
F000:CA38		  mov	  di, es:[bx]
F000:CA3B		  cmp	  si, di
F000:CA3D		  jz	  short	l14
F000:CA3F		  call	  print_memory_error
F000:CA42
F000:CA42 l14:							      ;	CODE XREF: POST_test_8259+108j
F000:CA42		  dec	  bx
F000:CA43		  dec	  bx
F000:CA44		  cmp	  bx, 0FFFEh
F000:CA47		  jnz	  short	l13
F000:CA49		  add	  bp, 1000h
F000:CA4D		  test	  byte ptr ds:0Fh, 1
F000:CA52		  jz	  short	l15
F000:CA54		  mov	  bx, 4000h
F000:CA57		  add	  bx, ds:0
F000:CA5B		  cmp	  bx, bp
F000:CA5D		  jnz	  short	l12
F000:CA5F		  jmp	  short	clean_memory_ram
F000:CA61 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA61
F000:CA61 l15:							      ;	CODE XREF: POST_test_8259+11Dj
F000:CA61		  mov	  bx, 3000h
F000:CA64		  add	  bx, ds:0
F000:CA68		  cmp	  bx, bp
F000:CA6A		  jz	  short	l16
F000:CA6C		  jb	  short	clean_memory_ram
F000:CA6E		  jmp	  short	l12
F000:CA70 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA70
F000:CA70 l16:							      ;	CODE XREF: POST_test_8259+135j
F000:CA70		  mov	  bx, 0BFFEh
F000:CA73		  jmp	  short	l13
F000:CA75 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA75
F000:CA75 clean_memory_ram:					      ;	CODE XREF: POST_test_8259+A7j
F000:CA75							      ;	POST_test_8259+12Aj
F000:CA75							      ;	POST_test_8259+137j
F000:CA75		  mov	  bp, ds:pbbe80
F000:CA79		  mov	  bx, 3000h
F000:CA7C		  add	  bp, bx
F000:CA7E		  xor	  ax, ax
F000:CA80		  mov	  es, ax			      ;	es = 0
F000:CA82
F000:CA82 l17:							      ;	CODE XREF: POST_test_8259+163j
F000:CA82		  mov	  cx, 8000h
F000:CA85
F000:CA85 l18:							      ;	CODE XREF: POST_test_8259:l20j
F000:CA85		  xor	  ax, ax
F000:CA87		  mov	  di, ax			      ;	di = 0
F000:CA89		  rep stosw				      ;	fill chunk of 64k RAM with 0
F000:CA8B		  mov	  ax, es
F000:CA8D		  add	  ax, 1000h			      ;	next 64k
F000:CA90		  cmp	  ax, bp			      ;	already	filled 192k?
F000:CA92		  mov	  es, ax
F000:CA94		  jz	  short	l19
F000:CA96		  jnb	  short	l21
F000:CA98		  jmp	  short	l17
F000:CA9A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CA9A
F000:CA9A l19:							      ;	CODE XREF: POST_test_8259+15Fj
F000:CA9A		  mov	  cx, 5FFFh
F000:CA9D		  test	  byte ptr ds:0Fh, 1
F000:CAA2		  jz	  short	l20
F000:CAA4		  mov	  cx, 7F3Fh
F000:CAA7
F000:CAA7 l20:							      ;	CODE XREF: POST_test_8259+16Dj
F000:CAA7		  jmp	  short	l18
F000:CAA9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CAA9
F000:CAA9 l21:							      ;	CODE XREF: POST_test_8259+161j
F000:CAA9		  mov	  ax, ds:4
F000:CAAC		  cmp	  ax, 1
F000:CAAF		  jnz	  short	halt1
F000:CAB1		  jmp	  near ptr POST_init_ints_and_more
F000:CAB4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CAB4
F000:CAB4 halt1:						      ;	CODE XREF: POST_test_8259+17Aj
F000:CAB4							      ;	POST_test_8259:halt1j
F000:CAB4		  jmp	  short	halt1
F000:CAB4 POST_test_8259  endp
F000:CAB4
F000:CAB4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CAB6 aMemoryErrInfo  db 'Memory Err Info:',0                     ; DATA XREF: print_memory_error+Eo
F000:CAC7 aWrittenReadBas db 'Written  Read    Base   Offset',0       ; DATA XREF: print_memory_error+17o
F000:CAE6
F000:CAE6 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CAE6
F000:CAE6
F000:CAE6 print_memory_error proc near				      ;	CODE XREF: POST_test_8259+10Ap
F000:CAE6		  mov	  es, word ptr ds:pbbe80.tmp_es
F000:CAEA		  mov	  ds:pbbe80.tmp_reg3, si
F000:CAEE		  mov	  si, di
F000:CAF0		  push	  si
F000:CAF1		  mov	  di, 14Ah
F000:CAF4		  mov	  si, offset aMemoryErrInfo	      ;	"Memory	Err Info:"
F000:CAF7		  call	  print_asciiz
F000:CAFA		  mov	  di, 19Ah
F000:CAFD		  mov	  si, offset aWrittenReadBas	      ;	"Written  Read	  Base	 Offset"
F000:CB00		  call	  print_asciiz
F000:CB03		  pop	  si
F000:CB04		  mov	  ax, ds:pbbe80.tmp_reg2
F000:CB07		  cmp	  al, 0Fh
F000:CB09		  jz	  short	l0
F000:CB0B		  inc	  ax
F000:CB0C		  mov	  ds:pbbe80.tmp_reg2, ax
F000:CB0F
F000:CB0F l0:							      ;	CODE XREF: print_memory_error+23j
F000:CB0F		  mov	  ax, ds:pbbe80.tmp_reg2
F000:CB12		  mov	  ah, 80
F000:CB14		  mul	  ah
F000:CB16		  mov	  di, 1ECh
F000:CB19		  add	  di, ax			      ;	dest: es:1ec
F000:CB1B		  push	  cx
F000:CB1C		  push	  bx
F000:CB1D		  push	  si
F000:CB1E		  mov	  ax, ds:pbbe80.tmp_reg3
F000:CB21		  mov	  si, offset l1
F000:CB24		  jmp	  short	print_number_in_bcd
F000:CB26 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CB26
F000:CB26 l1:							      ;	DATA XREF: print_memory_error+3Bo
F000:CB26		  add	  di, 8
F000:CB29		  pop	  ax
F000:CB2A		  mov	  si, offset l2
F000:CB2D		  jmp	  short	print_number_in_bcd
F000:CB2F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CB2F
F000:CB2F l2:							      ;	DATA XREF: print_memory_error+44o
F000:CB2F		  add	  di, 8
F000:CB32		  mov	  ax, bp
F000:CB34		  mov	  si, offset l3
F000:CB37		  jmp	  short	print_number_in_bcd
F000:CB39 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CB39
F000:CB39 l3:							      ;	DATA XREF: print_memory_error+4Eo
F000:CB39		  add	  di, 8
F000:CB3C		  pop	  ax
F000:CB3D		  push	  ax
F000:CB3E		  mov	  si, offset l4
F000:CB41		  jmp	  short	print_number_in_bcd
F000:CB43 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CB43
F000:CB43 l4:							      ;	DATA XREF: print_memory_error+58o
F000:CB43		  pop	  bx
F000:CB44		  pop	  cx
F000:CB45		  mov	  si, ds:pbbe80.tmp_reg3
F000:CB49		  retn
F000:CB49 print_memory_error endp
F000:CB49
F000:CB4A
F000:CB4A ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CB4A
F000:CB4A ;	Entry:
F000:CB4A ;	    AX = number	to write
F000:CB4A ;	    ES:DI = destination	to write
F000:CB4A
F000:CB4A print_number_in_bcd proc near				      ;	CODE XREF: POST_main+1D5j
F000:CB4A							      ;	POST_main+1F0j
F000:CB4A							      ;	POST_main+1FBj
F000:CB4A							      ;	print_memory_error+3Ej	...
F000:CB4A		  mov	  dx, ax			      ;	assume AX = '1234'
F000:CB4C		  mov	  cx, 4
F000:CB4F
F000:CB4F l0:							      ;	CODE XREF: print_number_in_bcd+19j
F000:CB4F		  mov	  bx, cx			      ;	tmp: save cx
F000:CB51		  mov	  cl, 4
F000:CB53		  rol	  dx, cl			      ;	dx << 4	= '2341'
F000:CB55		  mov	  cx, bx			      ;	tmp: restore cx
F000:CB57		  mov	  al, dl			      ;	AL = '41'
F000:CB59		  and	  al, 0Fh			      ;	al = ' 1'
F000:CB5B		  add	  al, 90h ; ''                       ; AL = '91'
F000:CB5D		  daa					      ;	AL = '91' ?
F000:CB5E		  adc	  al, 40h ; '@'                       ; AL = '31'
F000:CB60		  daa					      ;	AL = '31'
F000:CB61		  stosb
F000:CB62		  inc	  di
F000:CB63		  loop	  l0
F000:CB65		  jmp	  si
F000:CB65 print_number_in_bcd endp
F000:CB65
F000:CB67
F000:CB67 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CB67
F000:CB67 ;	Entry:
F000:CB67 ;	    SI = pointer to asciiz
F000:CB67 ;	    ES:DI = where to print it
F000:CB67
F000:CB67 print_asciiz	  proc near				      ;	CODE XREF: POST_test_port_0378+34p
F000:CB67							      ;	POST_test_pic_8253+94p
F000:CB67							      ;	POST_test_pic_8253+177p
F000:CB67							      ;	POST_test_port_61_kbd+19p ...
F000:CB67		  lods	  byte ptr cs:[si]
F000:CB69		  or	  al, al
F000:CB6B		  jz	  short	exit
F000:CB6D		  stosb
F000:CB6E		  inc	  di
F000:CB6F		  jmp	  short	print_asciiz
F000:CB71 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CB71
F000:CB71 exit:							      ;	CODE XREF: print_asciiz+4j
F000:CB71		  retn
F000:CB71 print_asciiz	  endp
F000:CB71
F000:CB72
F000:CB72 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CB72
F000:CB72
F000:CB72 init_video	  proc near				      ;	CODE XREF: POST_main+B3j
F000:CB72							      ;	POST_main+119j
F000:CB72							      ;	POST_main+149j
F000:CB72		  mov	  bx, di			      ;	di = return address. save it
F000:CB74		  xor	  di, di			      ;	di = 0
F000:CB76		  mov	  cx, 7D0h			      ;	80 * 25	= 2000 = 07d0h
F000:CB79		  mov	  ax, 720h			      ;	20h = space. 07h = attribute
F000:CB7C		  rep stosw				      ;	clear screen
F000:CB7E		  mov	  di, bx			      ;	restore	di (return address)
F000:CB80		  mov	  cx, 10h			      ;	16 registers to	'out'
F000:CB83		  xor	  bx, bx			      ;	bx = 0
F000:CB85
F000:CB85 l0:							      ;	CODE XREF: init_video+1Cj
F000:CB85		  mov	  al, bl			      ;	al = ctrl index. starts	with 0
F000:CB87		  out	  dx, al			      ;	Video: CRT cntrlr addr
F000:CB87							      ;	horizontal total
F000:CB88		  inc	  dx
F000:CB89		  lods	  byte ptr cs:[si]		      ;	si = pointer to	6845 init table
F000:CB8B		  out	  dx, al			      ;	Video: CRT controller internal registers
F000:CB8C		  dec	  dx
F000:CB8D		  inc	  bx				      ;	ctrl index register ++
F000:CB8E		  loop	  l0
F000:CB90		  jmp	  di
F000:CB90 init_video	  endp
F000:CB90
F000:CB92
F000:CB92 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CB92
F000:CB92
F000:CB92 int_13_main	  proc far				      ;	CODE XREF: int_09_handler:int_13_handlerj
F000:CB92		  call	  int_push_regs
F000:CB95		  mov	  di, 0Ch
F000:CB98		  nop
F000:CB99		  call	  convert_ah_to_di_idx
F000:CB9C		  jb	  short	exit
F000:CB9E		  test	  byte ptr ds:p400.extra_status, 40h
F000:CBA3		  jz	  short	l0
F000:CBA5		  xor	  dl, 3
F000:CBA8		  cmp	  dl, 3
F000:CBAB		  jnz	  short	l0
F000:CBAD		  and	  dl, 0FCh
F000:CBB0
F000:CBB0 l0:							      ;	CODE XREF: int_13_main+11j
F000:CBB0							      ;	int_13_main+19j
F000:CBB0		  push	  bx
F000:CBB1		  mov	  bx, ds:p400.installed_hardware
F000:CBB5		  test	  bx, 100h			      ;	test for reserved bit
F000:CBB9		  pop	  bx
F000:CBBA		  jz	  short	l1
F000:CBBC		  jmp	  word ptr cs:jump_dma_tbl[di]
F000:CBC1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CBC1
F000:CBC1 l1:							      ;	CODE XREF: int_13_main+28j
F000:CBC1		  jmp	  word ptr cs:jump_tbl[di]
F000:CBC1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CBC6 jump_tbl:						      ;	DATA XREF: int_13_main:l1r
F000:CBC6		  dw offset int_13_00_handler
F000:CBC8		  dw offset int_13_01_handler
F000:CBCA		  dw offset int_13_02_handler
F000:CBCC		  dw offset int_13_03_handler
F000:CBCE		  dw offset int_13_04_handler
F000:CBD0		  dw offset int_13_05_handler
F000:CBD2 jump_dma_tbl:						      ;	DATA XREF: int_13_main+2Ar
F000:CBD2		  dw offset int_13_00_handler
F000:CBD4		  dw offset int_13_01_handler
F000:CBD6		  dw offset int_13_02_dma_handler
F000:CBD8		  dw offset int_13_03_dma_handler
F000:CBDA		  dw offset int_13_04_dma_handler
F000:CBDC		  dw offset int_13_05_dma_handler
F000:CBDE ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CBDE
F000:CBDE exit:							      ;	CODE XREF: int_13_main+Aj
F000:CBDE		  mov	  byte ptr ds:p400.diskette_last_status, 1
F000:CBE3		  mov	  ah, 1
F000:CBE5		  jmp	  near ptr int_13_pop_and_exit
F000:CBE5 int_13_main	  endp
F000:CBE5
F000:CBE8
F000:CBE8 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CBE8
F000:CBE8 ;
F000:CBE8 ;	Resets the fixed disk or diskette controller and drive,	forcing
F000:CBE8 ;	recalibration of the read/write	head.
F000:CBE8 ;
F000:CBE8 ;	   Call	with:	  AH	     00h
F000:CBE8 ;			  DL	     Drive number
F000:CBE8 ;
F000:CBE8 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CBE8 ;			  CF	     Set if error, cleared otherwise
F000:CBE8
F000:CBE8 int_13_00_handler proc far				      ;	CODE XREF: int_13_main+2Aj
F000:CBE8							      ;	int_13_main:l1j
F000:CBE8							      ;	DATA XREF: int_13_main:jump_tblo
F000:CBE8							      ;	int_13_main:jump_dma_tblo
F000:CBE8		  mov	  byte ptr ds:p400.diskette_last_status, 0
F000:CBED		  and	  byte ptr ds:p400.diskette_recalibrate_status,	70h
F000:CBF2		  cli
F000:CBF3		  mov	  dl, ds:p400.diskette_motor_status
F000:CBF7		  mov	  al, 3
F000:CBF9		  test	  dl, 8
F000:CBFC		  jnz	  short	loc_FCC0E
F000:CBFE		  mov	  al, 2
F000:CC00		  test	  dl, 4
F000:CC03		  jnz	  short	loc_FCC0E
F000:CC05		  mov	  al, 1
F000:CC07		  test	  dl, 2
F000:CC0A		  jnz	  short	loc_FCC0E
F000:CC0C		  xor	  al, al
F000:CC0E
F000:CC0E loc_FCC0E:						      ;	CODE XREF: int_13_00_handler+14j
F000:CC0E							      ;	int_13_00_handler+1Bj
F000:CC0E							      ;	int_13_00_handler+22j
F000:CC0E		  mov	  cl, 4
F000:CC10		  shl	  dl, cl
F000:CC12		  cmp	  dl, 40h ; '@'
F000:CC15		  jnz	  short	loc_FCC19
F000:CC17		  mov	  dl, 10h
F000:CC19
F000:CC19 loc_FCC19:						      ;	CODE XREF: int_13_00_handler+2Dj
F000:CC19		  and	  dl, 0F0h
F000:CC1C		  or	  al, dl
F000:CC1E		  or	  al, 8
F000:CC20		  test	  al, 30h
F000:CC22		  jnz	  short	loc_FCC26
F000:CC24		  or	  al, 3
F000:CC26
F000:CC26 loc_FCC26:						      ;	CODE XREF: int_13_00_handler+3Aj
F000:CC26		  mov	  dx, 3F2h
F000:CC29		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:CC29							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:CC29							      ;	2:   0=reset diskette controller; 1=enable controller
F000:CC29							      ;	3:   1=enable diskette DMA and interrupts
F000:CC29							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:CC29							      ;
F000:CC2A		  or	  al, 4
F000:CC2C		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:CC2C							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:CC2C							      ;	2:   0=reset diskette controller; 1=enable controller
F000:CC2C							      ;	3:   1=enable diskette DMA and interrupts
F000:CC2C							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:CC2C							      ;
F000:CC2D		  sti
F000:CC2E		  call	  sub_FD031
F000:CC31		  call	  sub_FD2AD
F000:CC34		  jb	  short	loc_FCC69
F000:CC36		  test	  ah, 8
F000:CC39		  jz	  short	loc_FCC42
F000:CC3B		  or	  byte ptr ds:p400.diskette_last_status, 20h
F000:CC40		  jmp	  short	loc_FCC69
F000:CC42 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CC42
F000:CC42 loc_FCC42:						      ;	CODE XREF: int_13_00_handler+51j
F000:CC42		  mov	  al, 3
F000:CC44		  call	  sub_FD118
F000:CC47		  jb	  short	loc_FCC69
F000:CC49		  xor	  bx, bx
F000:CC4B		  mov	  cx, 2
F000:CC4E		  mov	  ax, ds:p400.installed_hardware
F000:CC51		  test	  ax, 100h			      ;	test for reserved bit
F000:CC54		  jz	  short	loc_FCC5B
F000:CC56		  call	  sub_FD344
F000:CC59		  jmp	  short	loc_FCC5E
F000:CC5B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CC5B
F000:CC5B loc_FCC5B:						      ;	CODE XREF: int_13_00_handler+6Cj
F000:CC5B		  call	  sub_FD317
F000:CC5E
F000:CC5E loc_FCC5E:						      ;	CODE XREF: int_13_00_handler+71j
F000:CC5E		  jb	  short	loc_FCC69
F000:CC60		  xor	  ax, ax
F000:CC62		  mov	  ds:p400.diskette_last_status,	al
F000:CC65		  clc
F000:CC66		  jmp	  near ptr int_13_pop_and_exit
F000:CC69 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CC69
F000:CC69 loc_FCC69:						      ;	CODE XREF: int_13_00_handler+4Cj
F000:CC69							      ;	int_13_00_handler+58j
F000:CC69							      ;	int_13_00_handler+5Fj
F000:CC69							      ;	int_13_00_handler:loc_FCC5Ej
F000:CC69		  xor	  al, al
F000:CC6B		  mov	  ah, ds:p400.diskette_last_status
F000:CC6F		  stc
F000:CC70		  jmp	  near ptr int_13_pop_and_exit
F000:CC70 int_13_00_handler endp
F000:CC70
F000:CC73
F000:CC73 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CC73
F000:CC73 ;	Returns	status information about the most recent fixed or floppy disk
F000:CC73 ;	operation.
F000:CC73 ;
F000:CC73 ;	   On entry:	  AH	     01h
F000:CC73 ;			  DL	     Drive number
F000:CC73 ;
F000:CC73 ;	   Returns:	  AH	     Status of operation (see below)
F000:CC73 ;			  CF	     Set if error, otherwise cleared
F000:CC73 ;
F000:CC73
F000:CC73 int_13_01_handler proc far				      ;	CODE XREF: int_13_main+2Aj
F000:CC73							      ;	int_13_main:l1j
F000:CC73							      ;	DATA XREF: int_13_main+36o
F000:CC73							      ;	int_13_main+42o
F000:CC73		  mov	  ah, ds:p400.diskette_last_status
F000:CC77		  mov	  al, ah
F000:CC79		  cmp	  ah, 0
F000:CC7C		  jz	  short	loc_FCC82
F000:CC7E		  stc
F000:CC7F		  jmp	  near ptr int_13_pop_and_exit
F000:CC82 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CC82
F000:CC82 loc_FCC82:						      ;	CODE XREF: int_13_01_handler+9j
F000:CC82		  clc
F000:CC83		  jmp	  near ptr int_13_pop_and_exit
F000:CC83 int_13_01_handler endp
F000:CC83
F000:CC86
F000:CC86 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CC86
F000:CC86 ;
F000:CC86 ;	Reads one or more sectors from a fixed or floppy disk into memory.
F000:CC86 ;
F000:CC86 ;	   On entry:	  AH	     02h
F000:CC86 ;			  AL	     Number of sectors to read
F000:CC86 ;			  CH	     Cylinder number (10 bit value; upper 2 bits
F000:CC86 ;				     in	CL)
F000:CC86 ;			  CL	     Starting sector number
F000:CC86 ;			  DH	     Head number
F000:CC86 ;			  DL	     Drive number
F000:CC86 ;			  ES:BX	     Address of	memory buffer
F000:CC86 ;
F000:CC86 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CC86 ;			  AL	     Number of sectors read
F000:CC86 ;			  CF	     Set if error, else	cleared
F000:CC86
F000:CC86 int_13_02_handler proc far				      ;	CODE XREF: int_13_main:l1j
F000:CC86							      ;	DATA XREF: int_13_main+38o
F000:CC86
F000:CC86 ; FUNCTION CHUNK AT F000:CC9F	SIZE 00000080 BYTES
F000:CC86
F000:CC86		  mov	  ah, 46h ; 'F'
F000:CC88		  call	  sub_FD089
F000:CC8B		  mov	  al, 0E6h ; 'æ'
F000:CC8D		  jmp	  short	loc_FCC9F
F000:CC8D int_13_02_handler endp
F000:CC8D
F000:CC8F
F000:CC8F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CC8F
F000:CC8F ;
F000:CC8F ;	Writes one or more sectors from	memory to a fixed or floppy disk.
F000:CC8F ;
F000:CC8F ;	   On entry:	  AH	     03h
F000:CC8F ;			  AL	     Number of sectors to write
F000:CC8F ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CC8F ;				     in	CL)
F000:CC8F ;			  CL	     Starting sector number
F000:CC8F ;			  DH	     Head number
F000:CC8F ;			  DL	     Drive number
F000:CC8F ;			  ES:BX	     Address of	memory buffer
F000:CC8F ;
F000:CC8F ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CC8F ;			  AL	     Number of sectors written
F000:CC8F ;			  CF	     Set if error, else	cleared
F000:CC8F ;
F000:CC8F
F000:CC8F int_13_03_handler proc far				      ;	CODE XREF: int_13_main:l1j
F000:CC8F							      ;	DATA XREF: int_13_main+3Ao
F000:CC8F		  mov	  ah, 4Ah ; 'J'
F000:CC91		  call	  sub_FD089
F000:CC94		  mov	  al, 0C5h ; 'Å'
F000:CC96		  jmp	  short	loc_FCC9F
F000:CC96 int_13_03_handler endp
F000:CC96
F000:CC98
F000:CC98 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CC98
F000:CC98 ;
F000:CC98 ;	Verifies one or	more fixed disk	or diskette sectors.
F000:CC98 ;
F000:CC98 ;	   On entry:	  AH	     04h
F000:CC98 ;			  AL	     Number of sectors to verify
F000:CC98 ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CC98 ;				     in	CL)
F000:CC98 ;			  CL	     Starting sector number
F000:CC98 ;			  DH	     Head number
F000:CC98 ;			  DL	     Drive number
F000:CC98 ;
F000:CC98 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CC98 ;			  AL	     Number of sectors verified
F000:CC98 ;			  CF	     Set if error, cleared otherwise
F000:CC98 ;
F000:CC98
F000:CC98 int_13_04_handler proc far				      ;	CODE XREF: int_13_main:l1j
F000:CC98							      ;	DATA XREF: int_13_main+3Co
F000:CC98		  mov	  ah, 42h ; 'B'
F000:CC9A		  call	  sub_FD089
F000:CC9D		  mov	  al, 0E6h ; 'æ'
F000:CC9D int_13_04_handler endp
F000:CC9D
F000:CC9F ; START OF FUNCTION CHUNK FOR	int_13_02_handler
F000:CC9F
F000:CC9F loc_FCC9F:						      ;	CODE XREF: int_13_02_handler+7j
F000:CC9F							      ;	int_13_03_handler+7j
F000:CC9F		  jnb	  short	loc_FCCA3
F000:CCA1		  jmp	  short	loc_FCD0C
F000:CCA3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CCA3
F000:CCA3 loc_FCCA3:						      ;	CODE XREF: int_13_02_handler:loc_FCC9Fj
F000:CCA3		  push	  cx
F000:CCA4		  cmp	  dl, 4
F000:CCA7		  jb	  short	loc_FCCB0
F000:CCA9		  mov	  byte ptr ds:41h, 1
F000:CCAE
F000:CCAE loc_FCCAE:						      ;	CODE XREF: int_13_02_handler+35j
F000:CCAE							      ;	int_13_02_handler+3Aj
F000:CCAE							      ;	int_13_02_handler+4Bj
F000:CCAE							      ;	int_13_02_handler+52j
F000:CCAE		  jmp	  short	loc_FCD0B
F000:CCB0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CCB0
F000:CCB0 loc_FCCB0:						      ;	CODE XREF: int_13_02_handler+21j
F000:CCB0		  mov	  byte ptr ds:p400.diskette_last_status, 0
F000:CCB5		  call	  get_diskette_params_addr
F000:CCB8		  call	  sub_FD1C4
F000:CCBB		  jb	  short	loc_FCCAE
F000:CCBD		  call	  sub_FD118
F000:CCC0		  jb	  short	loc_FCCAE
F000:CCC2		  mov	  al, dl
F000:CCC4		  and	  al, 3
F000:CCC6		  push	  dx
F000:CCC7		  shl	  dh, 1
F000:CCC9		  shl	  dh, 1
F000:CCCB		  or	  al, dh
F000:CCCD		  pop	  dx
F000:CCCE		  call	  sub_FD118
F000:CCD1		  jb	  short	loc_FCCAE
F000:CCD3		  mov	  al, ch
F000:CCD5		  call	  sub_FD118
F000:CCD8		  jb	  short	loc_FCCAE
F000:CCDA		  mov	  al, dh
F000:CCDC		  call	  sub_FD118
F000:CCDF		  jb	  short	loc_FCD0B
F000:CCE1		  mov	  al, cl
F000:CCE3		  call	  sub_FD118
F000:CCE6		  jb	  short	loc_FCD0B
F000:CCE8		  mov	  bx, 3
F000:CCEB		  mov	  cx, 4
F000:CCEE		  call	  sub_FD317
F000:CCF1		  jb	  short	loc_FCD0B
F000:CCF3		  call	  sub_FD031
F000:CCF6		  jb	  short	loc_FCD0B
F000:CCF8		  mov	  cx, 7
F000:CCFB		  call	  sub_FD170
F000:CCFE		  jb	  short	loc_FCD0B
F000:CD00		  pop	  cx
F000:CD01		  test	  ah, 0C0h
F000:CD04		  jz	  short	loc_FCD0C
F000:CD06		  call	  sub_FD2D4
F000:CD09		  jmp	  short	loc_FCD0C
F000:CD0B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CD0B
F000:CD0B loc_FCD0B:						      ;	CODE XREF: int_13_02_handler:loc_FCCAEj
F000:CD0B							      ;	int_13_02_handler+59j
F000:CD0B							      ;	int_13_02_handler+60j
F000:CD0B							      ;	int_13_02_handler+6Bj ...
F000:CD0B		  pop	  cx
F000:CD0C
F000:CD0C loc_FCD0C:						      ;	CODE XREF: int_13_02_handler+1Bj
F000:CD0C							      ;	int_13_02_handler+7Ej
F000:CD0C							      ;	int_13_02_handler+83j
F000:CD0C		  xor	  al, al
F000:CD0E		  mov	  ah, ds:p400.diskette_last_status
F000:CD12		  cmp	  ah, 0
F000:CD15		  jz	  short	loc_FCD1B
F000:CD17		  stc
F000:CD18		  jmp	  near ptr int_13_pop_and_exit
F000:CD1B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CD1B
F000:CD1B loc_FCD1B:						      ;	CODE XREF: int_13_02_handler+8Fj
F000:CD1B		  clc
F000:CD1C		  jmp	  near ptr int_13_pop_and_exit
F000:CD1C ; END	OF FUNCTION CHUNK FOR int_13_02_handler
F000:CD1F
F000:CD1F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CD1F
F000:CD1F ;
F000:CD1F ;	Reads one or more sectors from a fixed or floppy disk into memory.
F000:CD1F ;
F000:CD1F ;	   On entry:	  AH	     02h
F000:CD1F ;			  AL	     Number of sectors to read
F000:CD1F ;			  CH	     Cylinder number (10 bit value; upper 2 bits
F000:CD1F ;				     in	CL)
F000:CD1F ;			  CL	     Starting sector number
F000:CD1F ;			  DH	     Head number
F000:CD1F ;			  DL	     Drive number
F000:CD1F ;			  ES:BX	     Address of	memory buffer
F000:CD1F ;
F000:CD1F ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CD1F ;			  AL	     Number of sectors read
F000:CD1F ;			  CF	     Set if error, else	cleared
F000:CD1F
F000:CD1F int_13_02_dma_handler	proc far			      ;	CODE XREF: int_13_main+2Aj
F000:CD1F							      ;	int_13_main:l1j
F000:CD1F							      ;	DATA XREF: int_13_main+44o
F000:CD1F
F000:CD1F ; FUNCTION CHUNK AT F000:CD3B	SIZE 00000100 BYTES
F000:CD1F ; FUNCTION CHUNK AT F000:CE3C	SIZE 00000047 BYTES
F000:CD1F
F000:CD1F		  push	  cx
F000:CD20		  push	  ax
F000:CD21		  call	  sub_FCE83
F000:CD24		  push	  ax
F000:CD25		  mov	  al, 0E6h ; 'æ'
F000:CD27		  jmp	  short	loc_FCD3B
F000:CD27 int_13_02_dma_handler	endp
F000:CD27
F000:CD29
F000:CD29 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CD29
F000:CD29 ;
F000:CD29 ;	Writes one or more sectors from	memory to a fixed or floppy disk.
F000:CD29 ;
F000:CD29 ;	   On entry:	  AH	     03h
F000:CD29 ;			  AL	     Number of sectors to write
F000:CD29 ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CD29 ;				     in	CL)
F000:CD29 ;			  CL	     Starting sector number
F000:CD29 ;			  DH	     Head number
F000:CD29 ;			  DL	     Drive number
F000:CD29 ;			  ES:BX	     Address of	memory buffer
F000:CD29 ;
F000:CD29 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CD29 ;			  AL	     Number of sectors written
F000:CD29 ;			  CF	     Set if error, else	cleared
F000:CD29
F000:CD29 int_13_03_dma_handler	proc far			      ;	CODE XREF: int_13_main+2Aj
F000:CD29							      ;	int_13_main:l1j
F000:CD29							      ;	DATA XREF: int_13_main+46o
F000:CD29		  push	  cx
F000:CD2A		  push	  ax
F000:CD2B		  call	  sub_FCE83
F000:CD2E		  push	  ax
F000:CD2F		  mov	  al, 0C5h ; 'Å'
F000:CD31		  jmp	  short	loc_FCD3B
F000:CD31 int_13_03_dma_handler	endp
F000:CD31
F000:CD33
F000:CD33 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CD33
F000:CD33 ;
F000:CD33 ;	Verifies one or	more fixed disk	or diskette sectors.
F000:CD33 ;
F000:CD33 ;	   On entry:	  AH	     04h
F000:CD33 ;			  AL	     Number of sectors to verify
F000:CD33 ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CD33 ;				     in	CL)
F000:CD33 ;			  CL	     Starting sector number
F000:CD33 ;			  DH	     Head number
F000:CD33 ;			  DL	     Drive number
F000:CD33 ;
F000:CD33 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CD33 ;			  AL	     Number of sectors verified
F000:CD33 ;			  CF	     Set if error, cleared otherwise
F000:CD33 ;
F000:CD33
F000:CD33 int_13_04_dma_handler	proc far			      ;	CODE XREF: int_13_main+2Aj
F000:CD33							      ;	int_13_main:l1j
F000:CD33							      ;	DATA XREF: int_13_main+48o
F000:CD33		  push	  cx
F000:CD34		  push	  ax
F000:CD35		  call	  sub_FCE83
F000:CD38		  push	  ax
F000:CD39		  mov	  al, 0E6h ; 'æ'
F000:CD39 int_13_04_dma_handler	endp
F000:CD39
F000:CD3B ; START OF FUNCTION CHUNK FOR	int_13_02_dma_handler
F000:CD3B
F000:CD3B loc_FCD3B:						      ;	CODE XREF: int_13_02_dma_handler+8j
F000:CD3B							      ;	int_13_03_dma_handler+8j
F000:CD3B		  jnb	  short	loc_FCD40
F000:CD3D		  jmp	  loc_FCE6D
F000:CD40 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CD40
F000:CD40 loc_FCD40:						      ;	CODE XREF: int_13_02_dma_handler:loc_FCD3Bj
F000:CD40		  push	  es
F000:CD41		  push	  bx
F000:CD42		  cmp	  dl, 4
F000:CD45		  jb	  short	loc_FCD4F
F000:CD47		  mov	  byte ptr ds:p400.diskette_last_status, 1
F000:CD4C
F000:CD4C loc_FCD4C:						      ;	CODE XREF: int_13_02_dma_handler+3Bj
F000:CD4C							      ;	int_13_02_dma_handler+40j
F000:CD4C							      ;	int_13_02_dma_handler+51j
F000:CD4C							      ;	int_13_02_dma_handler+58j ...
F000:CD4C		  jmp	  loc_FCE6B
F000:CD4F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CD4F
F000:CD4F loc_FCD4F:						      ;	CODE XREF: int_13_02_dma_handler+26j
F000:CD4F		  mov	  byte ptr ds:p400.diskette_last_status, 0
F000:CD54		  call	  get_diskette_params_addr
F000:CD57		  call	  sub_FD1C4
F000:CD5A		  jb	  short	loc_FCD4C
F000:CD5C		  call	  sub_FD118
F000:CD5F		  jb	  short	loc_FCD4C
F000:CD61		  mov	  al, dl
F000:CD63		  and	  al, 3
F000:CD65		  push	  dx
F000:CD66		  shl	  dh, 1
F000:CD68		  shl	  dh, 1
F000:CD6A		  or	  al, dh
F000:CD6C		  pop	  dx
F000:CD6D		  call	  sub_FD118
F000:CD70		  jb	  short	loc_FCD4C
F000:CD72		  mov	  al, ch
F000:CD74		  call	  sub_FD118
F000:CD77		  jb	  short	loc_FCD4C
F000:CD79		  mov	  al, dh
F000:CD7B		  call	  sub_FD118
F000:CD7E		  jb	  short	loc_FCD4C
F000:CD80		  mov	  al, cl
F000:CD82		  call	  sub_FD118
F000:CD85		  jb	  short	loc_FCD4C
F000:CD87		  mov	  bx, 3
F000:CD8A		  mov	  cx, 4
F000:CD8D		  call	  sub_FD329
F000:CD90		  jb	  short	loc_FCD4C
F000:CD92		  mov	  al, ds:3Fh
F000:CD95		  mov	  cl, 4
F000:CD97		  shl	  al, cl
F000:CD99		  cmp	  al, 40h ; '@'
F000:CD9B		  jnz	  short	loc_FCD9F
F000:CD9D		  mov	  al, 10h
F000:CD9F
F000:CD9F loc_FCD9F:						      ;	CODE XREF: int_13_02_dma_handler+7Cj
F000:CD9F		  or	  al, 4Ch
F000:CDA1		  or	  al, dl
F000:CDA3		  mov	  dl, al
F000:CDA5		  pop	  bx
F000:CDA6		  pop	  es
F000:CDA7		  pop	  cx
F000:CDA8		  pop	  ax
F000:CDA9		  push	  dx
F000:CDAA		  mov	  di, bx
F000:CDAC		  mov	  si, bx
F000:CDAE		  mov	  bh, 20h ; ' '
F000:CDB0		  cmp	  ah, 4
F000:CDB3		  jnz	  short	loc_FCDB7
F000:CDB5		  jmp	  short	loc_FCE1A
F000:CDB7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDB7
F000:CDB7 loc_FCDB7:						      ;	CODE XREF: int_13_02_dma_handler+94j
F000:CDB7		  cmp	  ah, 3
F000:CDBA		  jz	  short	loc_FCDEC
F000:CDBC		  mov	  al, dh
F000:CDBE		  mov	  dx, 3F5h
F000:CDC1		  cli
F000:CDC2		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CDC3		  mov	  dx, 3F4h
F000:CDC6		  mov	  ah, 80h ; '€'
F000:CDC8		  jmp	  short	loc_FCDD4
F000:CDCA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDCA
F000:CDCA loc_FCDCA:						      ;	CODE XREF: int_13_02_dma_handler+BBj
F000:CDCA		  loop	  loc_FCDD7
F000:CDCC		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:CDD1		  jmp	  loc_FCE66
F000:CDD4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDD4
F000:CDD4 loc_FCDD4:						      ;	CODE XREF: int_13_02_dma_handler+A9j
F000:CDD4							      ;	int_13_02_dma_handler+C6j
F000:CDD4		  push	  cx
F000:CDD5		  xor	  cx, cx
F000:CDD7
F000:CDD7 loc_FCDD7:						      ;	CODE XREF: int_13_02_dma_handler:loc_FCDCAj
F000:CDD7		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:CDD7							      ;	0-3: diskette busy
F000:CDD7							      ;	4: 1=cntrlr busy
F000:CDD7							      ;	5: 1=non-DMA mode
F000:CDD7							      ;	6: Data	dir: 1=cntrlr to CPU
F000:CDD7							      ;	7: 1=OK	to snd/rcv cmd or data
F000:CDD8		  test	  al, ah
F000:CDDA		  jz	  short	loc_FCDCA
F000:CDDC		  test	  al, bh
F000:CDDE		  jz	  short	loc_FCDE9
F000:CDE0		  inc	  dx
F000:CDE1		  in	  al, dx			      ;	Floppy:	FDC command/data register.
F000:CDE2		  stosb
F000:CDE3		  pop	  cx
F000:CDE4		  dec	  dx
F000:CDE5		  loop	  loc_FCDD4
F000:CDE7		  jmp	  short	loc_FCE45
F000:CDE9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDE9
F000:CDE9 loc_FCDE9:						      ;	CODE XREF: int_13_02_dma_handler+BFj
F000:CDE9		  pop	  cx
F000:CDEA		  jmp	  short	loc_FCE45
F000:CDEC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDEC
F000:CDEC loc_FCDEC:						      ;	CODE XREF: int_13_02_dma_handler+9Bj
F000:CDEC		  mov	  al, dh
F000:CDEE		  mov	  dx, 3F5h
F000:CDF1		  cli
F000:CDF2		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CDF3		  dec	  dx
F000:CDF4		  mov	  ah, 80h ; '€'
F000:CDF6		  jmp	  short	loc_FCE01
F000:CDF8 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CDF8
F000:CDF8 loc_FCDF8:						      ;	CODE XREF: int_13_02_dma_handler+E8j
F000:CDF8		  loop	  loc_FCE04
F000:CDFA		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:CDFF		  jmp	  short	loc_FCE66
F000:CE01 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE01
F000:CE01 loc_FCE01:						      ;	CODE XREF: int_13_02_dma_handler+D7j
F000:CE01							      ;	int_13_02_dma_handler+F4j
F000:CE01		  push	  cx
F000:CE02		  xor	  cx, cx
F000:CE04
F000:CE04 loc_FCE04:						      ;	CODE XREF: int_13_02_dma_handler:loc_FCDF8j
F000:CE04		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:CE04							      ;	0-3: diskette busy
F000:CE04							      ;	4: 1=cntrlr busy
F000:CE04							      ;	5: 1=non-DMA mode
F000:CE04							      ;	6: Data	dir: 1=cntrlr to CPU
F000:CE04							      ;	7: 1=OK	to snd/rcv cmd or data
F000:CE05		  test	  al, ah
F000:CE07		  jz	  short	loc_FCDF8
F000:CE09		  test	  al, bh
F000:CE0B		  jz	  short	loc_FCE17
F000:CE0D		  lods	  byte ptr es:[si]
F000:CE0F		  inc	  dx
F000:CE10		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CE11		  pop	  cx
F000:CE12		  dec	  dx
F000:CE13		  loop	  loc_FCE01
F000:CE15		  jmp	  short	loc_FCE45
F000:CE17 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE17
F000:CE17 loc_FCE17:						      ;	CODE XREF: int_13_02_dma_handler+ECj
F000:CE17		  pop	  cx
F000:CE18		  jmp	  short	loc_FCE45
F000:CE1A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE1A
F000:CE1A loc_FCE1A:						      ;	CODE XREF: int_13_02_dma_handler+96j
F000:CE1A		  mov	  al, dh
F000:CE1C		  mov	  dx, 3F5h
F000:CE1F		  cli
F000:CE20		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CE21		  mov	  ah, 80h ; '€'
F000:CE23		  dec	  dx
F000:CE24
F000:CE24 loc_FCE24:						      ;	CODE XREF: int_13_02_dma_handler+121j
F000:CE24		  push	  cx
F000:CE25		  xor	  cx, cx
F000:CE27
F000:CE27 loc_FCE27:						      ;	CODE XREF: int_13_02_dma_handler+10Dj
F000:CE27		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:CE27							      ;	0-3: diskette busy
F000:CE27							      ;	4: 1=cntrlr busy
F000:CE27							      ;	5: 1=non-DMA mode
F000:CE27							      ;	6: Data	dir: 1=cntrlr to CPU
F000:CE27							      ;	7: 1=OK	to snd/rcv cmd or data
F000:CE28		  test	  al, 80h
F000:CE2A		  jnz	  short	loc_FCE35
F000:CE2C		  loop	  loc_FCE27
F000:CE2E		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:CE33		  jmp	  short	loc_FCE66
F000:CE35 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE35
F000:CE35 loc_FCE35:						      ;	CODE XREF: int_13_02_dma_handler+10Bj
F000:CE35		  test	  al, bh
F000:CE37		  jnz	  short	loc_FCE3C
F000:CE39		  jmp	  short	loc_FCE44
F000:CE39 ; END	OF FUNCTION CHUNK FOR int_13_02_dma_handler
F000:CE3B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE3B		  nop
F000:CE3C ; START OF FUNCTION CHUNK FOR	int_13_02_dma_handler
F000:CE3C
F000:CE3C loc_FCE3C:						      ;	CODE XREF: int_13_02_dma_handler+118j
F000:CE3C		  inc	  dx
F000:CE3D		  in	  al, dx			      ;	Floppy:	FDC command/data register.
F000:CE3E		  pop	  cx
F000:CE3F		  dec	  dx
F000:CE40		  loop	  loc_FCE24
F000:CE42		  jmp	  short	loc_FCE45
F000:CE44 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE44
F000:CE44 loc_FCE44:						      ;	CODE XREF: int_13_02_dma_handler+11Aj
F000:CE44		  pop	  cx
F000:CE45
F000:CE45 loc_FCE45:						      ;	CODE XREF: int_13_02_dma_handler+C8j
F000:CE45							      ;	int_13_02_dma_handler+CBj
F000:CE45							      ;	int_13_02_dma_handler+F6j
F000:CE45							      ;	int_13_02_dma_handler+F9j ...
F000:CE45		  pop	  ax
F000:CE46		  mov	  dx, 3F2h
F000:CE49		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:CE49							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:CE49							      ;	2:   0=reset diskette controller; 1=enable controller
F000:CE49							      ;	3:   1=enable diskette DMA and interrupts
F000:CE49							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:CE49							      ;
F000:CE4A		  and	  al, 0BFh
F000:CE4C		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:CE4C							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:CE4C							      ;	2:   0=reset diskette controller; 1=enable controller
F000:CE4C							      ;	3:   1=enable diskette DMA and interrupts
F000:CE4C							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:CE4C							      ;
F000:CE4D		  sti
F000:CE4E		  call	  sub_FD056
F000:CE51		  jb	  short	loc_FCE68
F000:CE53		  mov	  cx, 7
F000:CE56		  call	  sub_FD170
F000:CE59		  jb	  short	loc_FCE68
F000:CE5B		  pop	  cx
F000:CE5C		  test	  ah, 0C0h
F000:CE5F		  jz	  short	loc_FCE70
F000:CE61		  call	  sub_FD2D4
F000:CE64		  jmp	  short	loc_FCE70
F000:CE66 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE66
F000:CE66 loc_FCE66:						      ;	CODE XREF: int_13_02_dma_handler+B2j
F000:CE66							      ;	int_13_02_dma_handler+E0j
F000:CE66							      ;	int_13_02_dma_handler+114j
F000:CE66		  pop	  cx
F000:CE67		  pop	  dx
F000:CE68
F000:CE68 loc_FCE68:						      ;	CODE XREF: int_13_02_dma_handler+132j
F000:CE68							      ;	int_13_02_dma_handler+13Aj
F000:CE68		  pop	  cx
F000:CE69		  jmp	  short	loc_FCE70
F000:CE6B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE6B
F000:CE6B loc_FCE6B:						      ;	CODE XREF: int_13_02_dma_handler:loc_FCD4Cj
F000:CE6B		  pop	  bx
F000:CE6C		  pop	  es
F000:CE6D
F000:CE6D loc_FCE6D:						      ;	CODE XREF: int_13_02_dma_handler+1Ej
F000:CE6D		  pop	  ax
F000:CE6E		  pop	  ax
F000:CE6F		  pop	  cx
F000:CE70
F000:CE70 loc_FCE70:						      ;	CODE XREF: int_13_02_dma_handler+140j
F000:CE70							      ;	int_13_02_dma_handler+145j
F000:CE70							      ;	int_13_02_dma_handler+14Aj
F000:CE70		  xor	  al, al
F000:CE72		  mov	  ah, ds:p400.diskette_last_status
F000:CE76		  cmp	  ah, 0
F000:CE79		  jz	  short	loc_FCE7F
F000:CE7B		  stc
F000:CE7C		  jmp	  near ptr int_13_pop_and_exit
F000:CE7F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CE7F
F000:CE7F loc_FCE7F:						      ;	CODE XREF: int_13_02_dma_handler+15Aj
F000:CE7F		  clc
F000:CE80		  jmp	  near ptr int_13_pop_and_exit
F000:CE80 ; END	OF FUNCTION CHUNK FOR int_13_02_dma_handler
F000:CE83
F000:CE83 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CE83
F000:CE83 ; Attributes:	bp-based frame
F000:CE83
F000:CE83 sub_FCE83	  proc near				      ;	CODE XREF: int_13_02_dma_handler+2p
F000:CE83							      ;	int_13_03_dma_handler+2p
F000:CE83							      ;	int_13_04_dma_handler+2p
F000:CE83							      ;	int_13_05_dma_handler+12p
F000:CE83		  push	  cx
F000:CE84		  push	  dx
F000:CE85		  push	  es
F000:CE86		  push	  bx
F000:CE87		  push	  ax
F000:CE88		  mov	  al, 6
F000:CE8A		  out	  0Fh, al			      ;	DMA controller,	8237A-5.
F000:CE8A							      ;	master clear. Clear or mask any	or
F000:CE8A							      ;	all of the channels. Bits:
F000:CE8A							      ;	0: 1=mask channel 0; 0=enable
F000:CE8A							      ;	1: 1=mask channel 1;
F000:CE8A							      ;	2: 1=mask channel 2;
F000:CE8A							      ;	3: 1=mask channel 3;
F000:CE8C		  mov	  bp, sp
F000:CE8E		  call	  get_diskette_params_addr
F000:CE91		  mov	  cl, es:[si+3]
F000:CE95		  mov	  dx, 80h ; '€'
F000:CE98		  shl	  dx, cl
F000:CE9A		  mov	  ax, [bp+0]
F000:CE9D		  xor	  ah, ah
F000:CE9F		  mul	  dx
F000:CEA1		  cmp	  dx, 0
F000:CEA4		  jnz	  short	loc_FCEDB
F000:CEA6		  mov	  dx, bx
F000:CEA8		  add	  bx, ax
F000:CEAA		  jb	  short	loc_FCEAF
F000:CEAC		  clc
F000:CEAD		  jmp	  short	loc_FCEE1
F000:CEAF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CEAF
F000:CEAF loc_FCEAF:						      ;	CODE XREF: sub_FCE83+27j
F000:CEAF		  mov	  bx, dx
F000:CEB1		  and	  bx, 0Fh
F000:CEB5		  add	  bx, ax
F000:CEB7		  jb	  short	loc_FCEE1
F000:CEB9		  pop	  cx
F000:CEBA		  pop	  cx
F000:CEBB		  pop	  es
F000:CEBC		  mov	  bx, dx
F000:CEBE		  mov	  cl, 4
F000:CEC0		  shr	  bx, cl
F000:CEC2		  mov	  cx, es
F000:CEC4		  add	  cx, bx
F000:CEC6		  jb	  short	loc_FCED4
F000:CEC8		  mov	  es, cx
F000:CECA		  mov	  bx, dx
F000:CECC		  and	  bx, 0Fh
F000:CED0		  clc
F000:CED1
F000:CED1 loc_FCED1:						      ;	CODE XREF: sub_FCE83+56j
F000:CED1		  pop	  dx
F000:CED2		  pop	  cx
F000:CED3		  retn
F000:CED4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CED4
F000:CED4 loc_FCED4:						      ;	CODE XREF: sub_FCE83+43j
F000:CED4		  mov	  byte ptr ds:p400.diskette_last_status, 9
F000:CED9		  jmp	  short	loc_FCED1
F000:CEDB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CEDB
F000:CEDB loc_FCEDB:						      ;	CODE XREF: sub_FCE83+21j
F000:CEDB		  stc
F000:CEDC		  mov	  byte ptr ds:p400.diskette_last_status, 9
F000:CEE1
F000:CEE1 loc_FCEE1:						      ;	CODE XREF: sub_FCE83+2Aj
F000:CEE1							      ;	sub_FCE83+34j
F000:CEE1		  pop	  bx
F000:CEE2		  pop	  bx
F000:CEE3		  pop	  es
F000:CEE4		  pop	  dx
F000:CEE5		  pop	  cx
F000:CEE6		  retn
F000:CEE6 sub_FCE83	  endp
F000:CEE6
F000:CEE7
F000:CEE7 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CEE7
F000:CEE7 ;
F000:CEE7 ;	Initializes each sector	on a specified cylinder	with sector address
F000:CEE7 ;	and size information.
F000:CEE7 ;
F000:CEE7 ;	   On entry:	  AH	     05h
F000:CEE7 ;			  AL	     Number of sectors to format (diskette) or
F000:CEE7 ;				     Interleave	(XT)
F000:CEE7 ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CEE7 ;				     in	CL)
F000:CEE7 ;			  DH	     Head number
F000:CEE7 ;			  DL	     Drive number
F000:CEE7 ;			  ES:BX	     Pointer to	address	field list (See	below)
F000:CEE7 ;
F000:CEE7 ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CEE7 ;			  CF	     Set if error, cleared otherwise
F000:CEE7 ;
F000:CEE7
F000:CEE7 int_13_05_dma_handler	proc far			      ;	CODE XREF: int_13_main+2Aj
F000:CEE7							      ;	int_13_main:l1j
F000:CEE7							      ;	DATA XREF: int_13_main+4Ao
F000:CEE7		  cmp	  dl, 4
F000:CEEA		  jb	  short	loc_FCEF4
F000:CEEC		  mov	  byte ptr ds:p400.diskette_last_status, 1
F000:CEF1		  jmp	  loc_FCF7B
F000:CEF4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CEF4
F000:CEF4 loc_FCEF4:						      ;	CODE XREF: int_13_05_dma_handler+3j
F000:CEF4		  mov	  byte ptr ds:p400.diskette_last_status, 0
F000:CEF9		  call	  sub_FCE83
F000:CEFC		  push	  ax
F000:CEFD		  push	  es
F000:CEFE		  push	  bx
F000:CEFF		  jnb	  short	loc_FCF04
F000:CF01
F000:CF01 loc_FCF01:						      ;	CODE XREF: int_13_05_dma_handler+23j
F000:CF01							      ;	int_13_05_dma_handler+2Aj
F000:CF01		  jmp	  short	loc_FCF82
F000:CF03 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CF03		  nop
F000:CF04
F000:CF04 loc_FCF04:						      ;	CODE XREF: int_13_05_dma_handler+18j
F000:CF04		  call	  get_diskette_params_addr
F000:CF07		  call	  sub_FD1C4
F000:CF0A		  jb	  short	loc_FCF01
F000:CF0C		  mov	  al, 4Dh ; 'M'
F000:CF0E		  call	  sub_FD118
F000:CF11		  jb	  short	loc_FCF01
F000:CF13		  mov	  al, dl
F000:CF15		  and	  al, 3
F000:CF17		  shl	  dh, 1
F000:CF19		  shl	  dh, 1
F000:CF1B		  or	  al, dh
F000:CF1D		  call	  sub_FD118
F000:CF20		  jb	  short	loc_FCF82
F000:CF22		  mov	  bx, 3
F000:CF25		  mov	  cx, 2
F000:CF28		  call	  sub_FD317
F000:CF2B		  jb	  short	loc_FCF82
F000:CF2D		  dec	  bx
F000:CF2E		  mov	  dl, es:[bx+si]
F000:CF31		  cli
F000:CF32		  mov	  bx, 7
F000:CF35		  call	  sub_FD329
F000:CF38		  jb	  short	loc_FCF82
F000:CF3A		  pop	  bx
F000:CF3B		  pop	  es
F000:CF3C		  pop	  cx
F000:CF3D		  mov	  al, 4
F000:CF3F		  mul	  dl
F000:CF41		  mov	  cx, ax
F000:CF43		  mov	  al, dh
F000:CF45		  mov	  ah, 80h ; '€'
F000:CF47		  mov	  dx, 3F5h
F000:CF4A		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CF4B
F000:CF4B loc_FCF4B:						      ;	CODE XREF: int_13_05_dma_handler+7Dj
F000:CF4B		  push	  cx
F000:CF4C		  xor	  cx, cx
F000:CF4E		  dec	  dx
F000:CF4F
F000:CF4F loc_FCF4F:						      ;	CODE XREF: int_13_05_dma_handler+6Dj
F000:CF4F		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:CF4F							      ;	0-3: diskette busy
F000:CF4F							      ;	4: 1=cntrlr busy
F000:CF4F							      ;	5: 1=non-DMA mode
F000:CF4F							      ;	6: Data	dir: 1=cntrlr to CPU
F000:CF4F							      ;	7: 1=OK	to snd/rcv cmd or data
F000:CF50		  test	  al, ah
F000:CF52		  jnz	  short	loc_FCF5D
F000:CF54		  loop	  loc_FCF4F
F000:CF56		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:CF5B		  jmp	  short	loc_FCF84
F000:CF5D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CF5D
F000:CF5D loc_FCF5D:						      ;	CODE XREF: int_13_05_dma_handler+6Bj
F000:CF5D		  mov	  al, es:[bx]
F000:CF60		  inc	  dx
F000:CF61		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:CF62		  inc	  bx
F000:CF63		  pop	  cx
F000:CF64		  loop	  loc_FCF4B
F000:CF66		  call	  sub_FD056
F000:CF69		  mov	  cx, 7
F000:CF6C		  call	  sub_FD170
F000:CF6F		  jb	  short	loc_FCF85
F000:CF71		  test	  ah, 0C0h
F000:CF74		  jz	  short	loc_FCFEE
F000:CF76		  call	  sub_FD2D4
F000:CF79		  jmp	  short	loc_FCF85
F000:CF7B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CF7B
F000:CF7B loc_FCF7B:						      ;	CODE XREF: int_13_05_dma_handler+Aj
F000:CF7B		  mov	  ah, ds:p400.diskette_last_status
F000:CF7F		  clc
F000:CF80		  jmp	  short	near ptr int_13_pop_and_exit
F000:CF82 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CF82
F000:CF82 loc_FCF82:						      ;	CODE XREF: int_13_05_dma_handler:loc_FCF01j
F000:CF82							      ;	int_13_05_dma_handler+39j
F000:CF82							      ;	int_13_05_dma_handler+44j
F000:CF82							      ;	int_13_05_dma_handler+51j
F000:CF82		  pop	  bx
F000:CF83		  pop	  es
F000:CF84
F000:CF84 loc_FCF84:						      ;	CODE XREF: int_13_05_dma_handler+74j
F000:CF84		  pop	  ax
F000:CF85
F000:CF85 loc_FCF85:						      ;	CODE XREF: int_13_05_dma_handler+88j
F000:CF85							      ;	int_13_05_dma_handler+92j
F000:CF85		  mov	  ah, ds:p400.diskette_last_status
F000:CF89		  stc
F000:CF8A		  jmp	  short	near ptr int_13_pop_and_exit
F000:CF8A int_13_05_dma_handler	endp
F000:CF8A
F000:CF8C
F000:CF8C ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CF8C
F000:CF8C ;
F000:CF8C ;	Initializes each sector	on a specified cylinder	with sector address
F000:CF8C ;	and size information.
F000:CF8C ;
F000:CF8C ;	   On entry:	  AH	     05h
F000:CF8C ;			  AL	     Number of sectors to format (diskette) or
F000:CF8C ;				     Interleave	(XT)
F000:CF8C ;			  CH	     Cylinder number (10-bit value; upper 2 bits
F000:CF8C ;				     in	CL)
F000:CF8C ;			  DH	     Head number
F000:CF8C ;			  DL	     Drive number
F000:CF8C ;			  ES:BX	     Pointer to	address	field list (See	below)
F000:CF8C ;
F000:CF8C ;	   Returns:	  AH	     Status of operation (See Service 01h)
F000:CF8C ;			  CF	     Set if error, cleared otherwise
F000:CF8C ;
F000:CF8C
F000:CF8C int_13_05_handler proc far				      ;	CODE XREF: int_13_main:l1j
F000:CF8C							      ;	DATA XREF: int_13_main+3Eo
F000:CF8C		  cmp	  dl, 4
F000:CF8F		  jb	  short	loc_FCF98
F000:CF91		  mov	  byte ptr ds:p400.diskette_last_status, 1
F000:CF96		  jmp	  short	loc_FCFEE
F000:CF98 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CF98
F000:CF98 loc_FCF98:						      ;	CODE XREF: int_13_05_handler+3j
F000:CF98		  mov	  byte ptr ds:p400.diskette_last_status, 0
F000:CF9D		  mov	  ah, 4Ah ; 'J'
F000:CF9F		  call	  sub_FD089
F000:CFA2		  jnb	  short	loc_FCFA6
F000:CFA4		  jmp	  short	loc_FCFF5
F000:CFA6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CFA6
F000:CFA6 loc_FCFA6:						      ;	CODE XREF: int_13_05_handler+16j
F000:CFA6		  call	  get_diskette_params_addr
F000:CFA9		  call	  sub_FD1C4
F000:CFAC		  jb	  short	loc_FCFF5
F000:CFAE		  mov	  al, 4Dh ; 'M'
F000:CFB0		  call	  sub_FD118
F000:CFB3		  jb	  short	loc_FCFF5
F000:CFB5		  mov	  al, dl
F000:CFB7		  and	  al, 3
F000:CFB9		  shl	  dh, 1
F000:CFBB		  shl	  dh, 1
F000:CFBD		  or	  al, dh
F000:CFBF		  call	  sub_FD118
F000:CFC2		  jb	  short	loc_FCFF5
F000:CFC4		  mov	  bx, 3
F000:CFC7		  mov	  cx, 2
F000:CFCA		  call	  sub_FD317
F000:CFCD		  jb	  short	loc_FCFF5
F000:CFCF		  mov	  bx, 7
F000:CFD2		  call	  sub_FD317
F000:CFD5		  jb	  short	loc_FCFF5
F000:CFD7		  call	  sub_FD031
F000:CFDA		  jb	  short	loc_FCFF5
F000:CFDC		  mov	  cx, 7
F000:CFDF		  call	  sub_FD170
F000:CFE2		  jb	  short	loc_FCFF5
F000:CFE4		  test	  ah, 0C0h
F000:CFE7		  jz	  short	loc_FCFEE
F000:CFE9		  call	  sub_FD2D4
F000:CFEC		  jmp	  short	loc_FCFF5
F000:CFEE ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CFEE
F000:CFEE loc_FCFEE:						      ;	CODE XREF: int_13_05_dma_handler+8Dj
F000:CFEE							      ;	int_13_05_handler+Aj
F000:CFEE							      ;	int_13_05_handler+5Bj
F000:CFEE		  mov	  ah, ds:p400.diskette_last_status
F000:CFF2		  clc
F000:CFF3		  jmp	  short	near ptr int_13_pop_and_exit
F000:CFF5 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:CFF5
F000:CFF5 loc_FCFF5:						      ;	CODE XREF: int_13_05_handler+18j
F000:CFF5							      ;	int_13_05_handler+20j
F000:CFF5							      ;	int_13_05_handler+27j
F000:CFF5							      ;	int_13_05_handler+36j ...
F000:CFF5		  mov	  ah, ds:p400.diskette_last_status
F000:CFF9		  stc
F000:CFF9 int_13_05_handler endp
F000:CFF9
F000:CFFA
F000:CFFA ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:CFFA
F000:CFFA
F000:CFFA int_13_pop_and_exit proc far				      ;	CODE XREF: int_13_main+53j
F000:CFFA							      ;	int_13_00_handler+7Ej
F000:CFFA							      ;	int_13_00_handler+88j
F000:CFFA							      ;	int_13_01_handler+Cj ...
F000:CFFA		  pushf
F000:CFFB		  push	  ax
F000:CFFC		  call	  get_diskette_params_addr
F000:CFFF		  mov	  al, es:[si+2]
F000:D003		  cli
F000:D004		  mov	  ds:p400.diskette_motor_off_timeout, al
F000:D007		  sti
F000:D008		  pop	  ax
F000:D009		  and	  byte ptr ds:p400.diskette_recalibrate_status,	7Fh
F000:D00E		  popf
F000:D00F		  pop	  es
F000:D010		  pop	  ds
F000:D011		  pop	  bp
F000:D012		  pop	  di
F000:D013		  pop	  si
F000:D014		  pop	  dx
F000:D015		  pop	  cx
F000:D016		  pop	  bx
F000:D017		  retf	  2
F000:D017 int_13_pop_and_exit endp ; sp	=  10h
F000:D017
F000:D01A
F000:D01A ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D01A
F000:D01A
F000:D01A int_0e_handler  proc far				      ;	DATA XREF: F000:FEFFo
F000:D01A		  push	  ax
F000:D01B		  push	  dx
F000:D01C		  push	  ds
F000:D01D		  mov	  ax, 40h ; '@'
F000:D020		  mov	  ds, ax			      ;	ds = 0x40
F000:D022		  or	  byte ptr ds:p400.diskette_recalibrate_status,	80h ; signal that interrupt was	triggered
F000:D027		  mov	  al, 20h ; ' '
F000:D029		  mov	  dx, 20h ; ' '
F000:D02C		  out	  dx, al			      ;	Interrupt controller, 8259A.
F000:D02D		  pop	  ds
F000:D02E		  pop	  dx
F000:D02F		  pop	  ax
F000:D030		  iret
F000:D030 int_0e_handler  endp
F000:D030
F000:D031
F000:D031 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D031
F000:D031
F000:D031 sub_FD031	  proc near				      ;	CODE XREF: int_13_00_handler+46p
F000:D031							      ;	int_13_02_handler+6Dp
F000:D031							      ;	int_13_05_handler+4Bp
F000:D031							      ;	sub_FD1C4+6Dp ...
F000:D031		  push	  cx
F000:D032		  mov	  cx, 3
F000:D035		  xor	  bx, bx
F000:D037
F000:D037 l0:							      ;	CODE XREF: sub_FD031+11j
F000:D037							      ;	sub_FD031+13j
F000:D037		  test	  byte ptr ds:p400.diskette_recalibrate_status,	80h ; interrupt	triggered?
F000:D03C		  jnz	  short	ok			      ;	yes, exit
F000:D03E		  dec	  bx
F000:D03F		  cmp	  bx, 0
F000:D042		  jnz	  short	l0
F000:D044		  loop	  l0
F000:D046		  or	  byte ptr ds:p400.diskette_last_status, 80h ; timeout
F000:D04B		  stc
F000:D04C		  jmp	  short	exit
F000:D04E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D04E
F000:D04E ok:							      ;	CODE XREF: sub_FD031+Bj
F000:D04E		  and	  byte ptr ds:p400.diskette_recalibrate_status,	7Fh ; mask off "interrupt triggered"
F000:D053		  clc
F000:D054
F000:D054 exit:							      ;	CODE XREF: sub_FD031+1Bj
F000:D054		  pop	  cx
F000:D055		  retn
F000:D055 sub_FD031	  endp
F000:D055
F000:D056
F000:D056 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D056
F000:D056
F000:D056 sub_FD056	  proc near				      ;	CODE XREF: int_13_02_dma_handler+12Fp
F000:D056							      ;	int_13_05_dma_handler+7Fp
F000:D056		  push	  dx
F000:D057		  push	  ax
F000:D058		  push	  cx
F000:D059		  mov	  cx, 3
F000:D05C		  xor	  bx, bx
F000:D05E		  mov	  dx, 3F4h
F000:D061
F000:D061 l0:							      ;	CODE XREF: sub_FD056+14j
F000:D061							      ;	sub_FD056+16j
F000:D061							      ;	sub_FD056+27j
F000:D061		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D061							      ;	0-3: diskette busy
F000:D061							      ;	4: 1=cntrlr busy
F000:D061							      ;	5: 1=non-DMA mode
F000:D061							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D061							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D062		  test	  al, 80h
F000:D064		  jnz	  short	l1
F000:D066		  dec	  bx
F000:D067		  cmp	  bx, 0
F000:D06A		  jnz	  short	l0
F000:D06C		  loop	  l0
F000:D06E		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:D073		  stc
F000:D074		  jmp	  short	exit
F000:D076 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D076
F000:D076 l1:							      ;	CODE XREF: sub_FD056+Ej
F000:D076		  test	  al, 20h
F000:D078		  jz	  short	l2
F000:D07A		  inc	  dx
F000:D07B		  in	  al, dx			      ;	Floppy:	FDC command/data register.
F000:D07C		  dec	  dx
F000:D07D		  jmp	  short	l0
F000:D07F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D07F
F000:D07F l2:							      ;	CODE XREF: sub_FD056+22j
F000:D07F		  and	  byte ptr ds:p400.diskette_recalibrate_status,	7Fh
F000:D084		  clc
F000:D085
F000:D085 exit:							      ;	CODE XREF: sub_FD056+1Ej
F000:D085		  pop	  cx
F000:D086		  pop	  ax
F000:D087		  pop	  dx
F000:D088		  retn
F000:D088 sub_FD056	  endp
F000:D088
F000:D089
F000:D089 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D089
F000:D089 ; Attributes:	bp-based frame
F000:D089
F000:D089 sub_FD089	  proc near				      ;	CODE XREF: int_13_02_handler+2p
F000:D089							      ;	int_13_03_handler+2p
F000:D089							      ;	int_13_04_handler+2p
F000:D089							      ;	int_13_05_handler+13p
F000:D089		  push	  cx
F000:D08A		  push	  dx
F000:D08B		  push	  es
F000:D08C		  push	  bx
F000:D08D		  push	  ax
F000:D08E		  mov	  bp, sp
F000:D090		  call	  get_diskette_params_addr
F000:D093		  mov	  cl, es:[si+3]
F000:D097		  mov	  dx, 80h ; '€'
F000:D09A		  shl	  dx, cl
F000:D09C		  mov	  ax, [bp+0]
F000:D09F		  xor	  ah, ah
F000:D0A1		  mul	  dx
F000:D0A3		  cmp	  dx, 0
F000:D0A6		  jnz	  short	l2
F000:D0A8		  pop	  cx
F000:D0A9		  pop	  bx
F000:D0AA		  pop	  es
F000:D0AB		  push	  es
F000:D0AC		  push	  bx
F000:D0AD		  push	  cx
F000:D0AE		  mov	  dx, ax
F000:D0B0		  mov	  ax, es
F000:D0B2		  mov	  cl, 4
F000:D0B4		  shl	  ax, cl
F000:D0B6		  add	  bx, ax
F000:D0B8		  mov	  ax, dx
F000:D0BA		  dec	  dx
F000:D0BB		  add	  bx, dx
F000:D0BD		  jb	  short	l2
F000:D0BF		  dec	  ax
F000:D0C0		  cli
F000:D0C1		  mov	  dx, 0Ch
F000:D0C4		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D0C4							      ;	clear byte pointer flip-flop.
F000:D0C5		  mov	  dx, 5
F000:D0C8		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D0C8							      ;	channel	2 base address and word	count
F000:D0C9		  xchg	  ah, al
F000:D0CB		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D0CB							      ;	channel	2 base address and word	count
F000:D0CC		  pop	  ax
F000:D0CD		  xchg	  ah, al
F000:D0CF		  mov	  dx, 0Bh
F000:D0D2		  out	  dx, al			      ;	DMA 8237A-5. mode register bits:
F000:D0D2							      ;	0-1: channel (00=0; 01=1; 10=2;	11=3)
F000:D0D2							      ;	2-3: transfer type (00=verify=Nop; 01=write; 10=read)
F000:D0D2							      ;	4: 1=enable auto-initialization
F000:D0D2							      ;	5: 1=address increment;	0=address decrement
F000:D0D2							      ;	6-7: 00=demand mode; 01=single;	10=block; 11=cascade
F000:D0D3		  pop	  bx
F000:D0D4		  pop	  es
F000:D0D5		  mov	  ax, es
F000:D0D7		  mov	  cl, 4
F000:D0D9		  shl	  ax, cl
F000:D0DB		  add	  ax, bx
F000:D0DD		  mov	  bx, 0
F000:D0E0		  jnb	  short	l0
F000:D0E2		  mov	  bx, 1
F000:D0E5
F000:D0E5 l0:							      ;	CODE XREF: sub_FD089+57j
F000:D0E5		  mov	  dx, 4
F000:D0E8		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D0E8							      ;	channel	2 base address
F000:D0E8							      ;	(also sets current address)
F000:D0E9		  xchg	  ah, al
F000:D0EB		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D0EB							      ;	channel	2 base address
F000:D0EB							      ;	(also sets current address)
F000:D0EC		  mov	  ax, es
F000:D0EE		  and	  ax, 0F000h
F000:D0F1		  mov	  cl, 0Ch
F000:D0F3		  shr	  ax, cl
F000:D0F5		  cmp	  bx, 0
F000:D0F8		  jz	  short	l1
F000:D0FA		  inc	  al
F000:D0FC
F000:D0FC l1:							      ;	CODE XREF: sub_FD089+6Fj
F000:D0FC		  mov	  dx, 81h ; ''
F000:D0FF		  out	  dx, al			      ;	DMA page register 74LS612:
F000:D0FF							      ;	Channel	2 (diskette DMA)  (address bits	16-23)
F000:D100		  sti
F000:D101		  mov	  dx, 0Ah
F000:D104		  mov	  al, 2
F000:D106		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:D106							      ;	single mask bit	register
F000:D106							      ;	0-1: select channel (00=0; 01=1; 10=2; 11=3)
F000:D106							      ;	2: 1=set mask for channel; 0=clear mask	(enable)
F000:D107		  jmp	  short	ok
F000:D109 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D109
F000:D109 l2:							      ;	CODE XREF: sub_FD089+1Dj
F000:D109							      ;	sub_FD089+34j
F000:D109		  stc
F000:D10A		  mov	  byte ptr ds:p400.diskette_last_status, 9 ; attemp to DMA accross 64k boundary
F000:D10F		  pop	  ax
F000:D110		  pop	  bx
F000:D111		  pop	  es
F000:D112		  jmp	  short	exit
F000:D114 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D114
F000:D114 ok:							      ;	CODE XREF: sub_FD089+7Ej
F000:D114		  clc
F000:D115
F000:D115 exit:							      ;	CODE XREF: sub_FD089+89j
F000:D115		  pop	  dx
F000:D116		  pop	  cx
F000:D117		  retn
F000:D117 sub_FD089	  endp
F000:D117
F000:D118
F000:D118 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D118
F000:D118
F000:D118 sub_FD118	  proc near				      ;	CODE XREF: int_13_00_handler+5Cp
F000:D118							      ;	int_13_02_handler+37p
F000:D118							      ;	int_13_02_handler+48p
F000:D118							      ;	int_13_02_handler+4Fp ...
F000:D118		  push	  cx
F000:D119		  push	  dx
F000:D11A		  mov	  ah, al
F000:D11C		  mov	  dx, 3F4h
F000:D11F		  xor	  cx, cx
F000:D121
F000:D121 l0:							      ;	CODE XREF: sub_FD118+Ej
F000:D121		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D121							      ;	0-3: diskette busy
F000:D121							      ;	4: 1=cntrlr busy
F000:D121							      ;	5: 1=non-DMA mode
F000:D121							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D121							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D122		  test	  al, 80h
F000:D124		  jnz	  short	l1
F000:D126		  loop	  l0
F000:D128		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:D12D		  jmp	  short	error
F000:D12F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D12F
F000:D12F l1:							      ;	CODE XREF: sub_FD118+Cj
F000:D12F		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D12F							      ;	0-3: diskette busy
F000:D12F							      ;	4: 1=cntrlr busy
F000:D12F							      ;	5: 1=non-DMA mode
F000:D12F							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D12F							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D130		  test	  al, 40h
F000:D132		  jz	  short	l2
F000:D134		  or	  byte ptr ds:p400.diskette_last_status, 20h ; controller failure
F000:D139		  jmp	  short	error
F000:D13B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D13B
F000:D13B l2:							      ;	CODE XREF: sub_FD118+1Aj
F000:D13B		  mov	  dx, 3F5h
F000:D13E		  mov	  al, ah
F000:D140		  out	  dx, al			      ;	Floppy:	FDC command/data register.
F000:D141		  clc
F000:D142		  jmp	  short	exit
F000:D144 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D144
F000:D144 error:						      ;	CODE XREF: sub_FD118+15j
F000:D144							      ;	sub_FD118+21j
F000:D144		  stc
F000:D145
F000:D145 exit:							      ;	CODE XREF: sub_FD118+2Aj
F000:D145		  pop	  dx
F000:D146		  pop	  cx
F000:D147		  retn
F000:D147 sub_FD118	  endp
F000:D147
F000:D148
F000:D148 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D148
F000:D148
F000:D148 sub_FD148	  proc near				      ;	CODE XREF: sub_FD329+11p
F000:D148		  push	  cx
F000:D149		  push	  dx
F000:D14A		  mov	  dx, 3F4h
F000:D14D		  xor	  cx, cx
F000:D14F
F000:D14F l0:							      ;	CODE XREF: sub_FD148+Cj
F000:D14F		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D14F							      ;	0-3: diskette busy
F000:D14F							      ;	4: 1=cntrlr busy
F000:D14F							      ;	5: 1=non-DMA mode
F000:D14F							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D14F							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D150		  test	  al, 80h
F000:D152		  jnz	  short	l1
F000:D154		  loop	  l0
F000:D156		  or	  byte ptr ds:p400.diskette_last_status, 80h ; device timeout
F000:D15B		  jmp	  short	error
F000:D15D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D15D
F000:D15D l1:							      ;	CODE XREF: sub_FD148+Aj
F000:D15D		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D15D							      ;	0-3: diskette busy
F000:D15D							      ;	4: 1=cntrlr busy
F000:D15D							      ;	5: 1=non-DMA mode
F000:D15D							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D15D							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D15E		  test	  al, 40h
F000:D160		  jz	  short	l2
F000:D162		  or	  byte ptr ds:p400.diskette_last_status, 20h ; controller failure
F000:D167		  jmp	  short	error
F000:D169 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D169
F000:D169 l2:							      ;	CODE XREF: sub_FD148+18j
F000:D169		  clc
F000:D16A		  jmp	  short	exit
F000:D16C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D16C
F000:D16C error:						      ;	CODE XREF: sub_FD148+13j
F000:D16C							      ;	sub_FD148+1Fj
F000:D16C		  stc
F000:D16D
F000:D16D exit:							      ;	CODE XREF: sub_FD148+22j
F000:D16D		  pop	  dx
F000:D16E		  pop	  cx
F000:D16F		  retn
F000:D16F sub_FD148	  endp
F000:D16F
F000:D170
F000:D170 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D170
F000:D170
F000:D170 sub_FD170	  proc near				      ;	CODE XREF: int_13_02_handler+75p
F000:D170							      ;	int_13_02_dma_handler+137p
F000:D170							      ;	int_13_05_dma_handler+85p
F000:D170							      ;	int_13_05_handler+53p ...
F000:D170		  push	  dx
F000:D171		  push	  es
F000:D172		  mov	  ax, ds
F000:D174		  mov	  es, ax
F000:D176		  lea	  di, ds:p400.diskette_command_bytes
F000:D17A		  mov	  dx, 3F4h
F000:D17D		  xor	  bx, bx
F000:D17F
F000:D17F l0:							      ;	CODE XREF: sub_FD170+15j
F000:D17F		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D17F							      ;	0-3: diskette busy
F000:D17F							      ;	4: 1=cntrlr busy
F000:D17F							      ;	5: 1=non-DMA mode
F000:D17F							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D17F							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D180		  test	  al, 80h
F000:D182		  jnz	  short	l1
F000:D184		  dec	  bx
F000:D185		  jnz	  short	l0
F000:D187		  or	  byte ptr ds:p400.diskette_last_status, 80h
F000:D18C		  jmp	  short	error
F000:D18E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D18E
F000:D18E l1:							      ;	CODE XREF: sub_FD170+12j
F000:D18E		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D18E							      ;	0-3: diskette busy
F000:D18E							      ;	4: 1=cntrlr busy
F000:D18E							      ;	5: 1=non-DMA mode
F000:D18E							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D18E							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D18F		  test	  al, 40h
F000:D191		  jnz	  short	l2
F000:D193		  or	  byte ptr ds:p400.diskette_last_status, 20h
F000:D198		  jmp	  short	error
F000:D19A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D19A
F000:D19A l2:							      ;	CODE XREF: sub_FD170+21j
F000:D19A							      ;	sub_FD170+3Ej
F000:D19A		  mov	  dx, 3F5h
F000:D19D		  in	  al, dx			      ;	Floppy:	FDC command/data register.
F000:D19E		  stosb
F000:D19F		  push	  cx
F000:D1A0		  mov	  cx, 8
F000:D1A3
F000:D1A3 delay0:						      ;	CODE XREF: sub_FD170:delay0j
F000:D1A3		  loop	  delay0
F000:D1A5		  pop	  cx
F000:D1A6		  mov	  dx, 3F4h
F000:D1A9		  in	  al, dx			      ;	Floppy:	main status reg	bits:
F000:D1A9							      ;	0-3: diskette busy
F000:D1A9							      ;	4: 1=cntrlr busy
F000:D1A9							      ;	5: 1=non-DMA mode
F000:D1A9							      ;	6: Data	dir: 1=cntrlr to CPU
F000:D1A9							      ;	7: 1=OK	to snd/rcv cmd or data
F000:D1AA		  test	  al, 10h
F000:D1AC		  jz	  short	l3
F000:D1AE		  loop	  l2
F000:D1B0		  or	  byte ptr ds:p400.diskette_last_status, 20h ; controller failure
F000:D1B5		  jmp	  short	error
F000:D1B7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D1B7
F000:D1B7 l3:							      ;	CODE XREF: sub_FD170+3Cj
F000:D1B7		  lea	  di, ds:p400.diskette_command_bytes
F000:D1BB		  mov	  ah, [di]
F000:D1BD		  clc
F000:D1BE		  jmp	  short	exit
F000:D1C0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D1C0
F000:D1C0 error:						      ;	CODE XREF: sub_FD170+1Cj
F000:D1C0							      ;	sub_FD170+28j
F000:D1C0							      ;	sub_FD170+45j
F000:D1C0		  stc
F000:D1C1
F000:D1C1 exit:							      ;	CODE XREF: sub_FD170+4Ej
F000:D1C1		  pop	  es
F000:D1C2		  pop	  dx
F000:D1C3		  retn
F000:D1C3 sub_FD170	  endp
F000:D1C3
F000:D1C4
F000:D1C4 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D1C4
F000:D1C4
F000:D1C4 sub_FD1C4	  proc near				      ;	CODE XREF: int_13_02_handler+32p
F000:D1C4							      ;	int_13_02_dma_handler+38p
F000:D1C4							      ;	int_13_05_dma_handler+20p
F000:D1C4							      ;	int_13_05_handler+1Dp
F000:D1C4		  push	  ax
F000:D1C5		  push	  cx
F000:D1C6		  push	  dx
F000:D1C7		  mov	  al, 1
F000:D1C9		  mov	  cl, dl
F000:D1CB		  shl	  al, cl
F000:D1CD		  mov	  ah, al
F000:D1CF		  cli
F000:D1D0		  test	  ds:p400.diskette_motor_status, ah
F000:D1D4		  jnz	  short	l1
F000:D1D6		  cmp	  al, 4
F000:D1D8		  jnz	  short	l0
F000:D1DA		  mov	  al, 1
F000:D1DC
F000:D1DC l0:							      ;	CODE XREF: sub_FD1C4+14j
F000:D1DC		  mov	  cl, 4
F000:D1DE		  shl	  al, cl
F000:D1E0		  or	  al, 0Ch
F000:D1E2		  or	  al, dl
F000:D1E4		  mov	  dx, 3F2h
F000:D1E7		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:D1E7							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:D1E7							      ;	2:   0=reset diskette controller; 1=enable controller
F000:D1E7							      ;	3:   1=enable diskette DMA and interrupts
F000:D1E7							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:D1E7							      ;
F000:D1E8		  and	  byte ptr ds:p400.diskette_motor_status, 0F0h
F000:D1ED		  or	  ds:p400.diskette_motor_status, ah
F000:D1F1		  mov	  al, es:[si+0Ah]
F000:D1F5		  cmp	  al, 0
F000:D1F7		  jz	  short	l1
F000:D1F9		  xor	  cx, cx
F000:D1FB		  mov	  byte ptr ds:p400.diskette_motor_off_timeout, 0
F000:D200		  sti
F000:D201
F000:D201 delay0:						      ;	CODE XREF: sub_FD1C4:delay0j
F000:D201							      ;	sub_FD1C4+43j
F000:D201		  loop	  delay0
F000:D203		  dec	  al
F000:D205		  cmp	  al, 0
F000:D207		  jnz	  short	delay0
F000:D209
F000:D209 l1:							      ;	CODE XREF: sub_FD1C4+10j
F000:D209							      ;	sub_FD1C4+33j
F000:D209		  mov	  byte ptr ds:p400.diskette_motor_off_timeout, 0FFh
F000:D20E		  sti
F000:D20F		  pop	  dx
F000:D210		  pop	  cx
F000:D211		  push	  cx
F000:D212		  push	  dx
F000:D213		  mov	  al, 1
F000:D215		  mov	  cl, dl
F000:D217		  shl	  al, cl
F000:D219		  mov	  cl, al
F000:D21B		  test	  ds:3Eh, al
F000:D21F		  jnz	  short	l2
F000:D221		  mov	  al, 7
F000:D223		  call	  sub_FD118
F000:D226		  jb	  short	l5
F000:D228		  mov	  al, dl
F000:D22A		  and	  al, 3
F000:D22C		  call	  sub_FD118
F000:D22F		  jb	  short	l5
F000:D231		  call	  sub_FD031
F000:D234		  jb	  short	l5
F000:D236		  call	  sub_FD2AD
F000:D239		  jb	  short	l5
F000:D23B		  mov	  al, 7
F000:D23D		  call	  sub_FD118
F000:D240		  jb	  short	l5
F000:D242		  mov	  al, dl
F000:D244		  and	  al, 3
F000:D246		  call	  sub_FD118
F000:D249		  jb	  short	l5
F000:D24B		  call	  sub_FD031
F000:D24E		  jb	  short	l5
F000:D250		  call	  sub_FD2AD
F000:D253		  jb	  short	l5
F000:D255		  test	  ah, 0C0h
F000:D258		  jnz	  short	l5
F000:D25A		  or	  ds:3Eh, cl
F000:D25E
F000:D25E l2:							      ;	CODE XREF: sub_FD1C4+5Bj
F000:D25E		  mov	  al, 0Fh
F000:D260		  call	  sub_FD118
F000:D263		  jb	  short	l5
F000:D265		  mov	  al, dl
F000:D267		  and	  al, 3
F000:D269		  shl	  dh, 1
F000:D26B		  shl	  dh, 1
F000:D26D		  or	  al, dh
F000:D26F		  call	  sub_FD118
F000:D272		  jb	  short	l5
F000:D274		  mov	  al, ch
F000:D276		  call	  sub_FD118
F000:D279		  jb	  short	l5
F000:D27B		  call	  sub_FD031
F000:D27E		  jb	  short	l5
F000:D280		  call	  sub_FD2AD
F000:D283		  jb	  short	l5
F000:D285		  test	  ah, 0C0h
F000:D288		  jnz	  short	l5
F000:D28A		  mov	  al, es:[si+9]
F000:D28E		  cmp	  al, 0
F000:D290		  jz	  short	l4
F000:D292
F000:D292 l3:							      ;	CODE XREF: sub_FD1C4+D7j
F000:D292		  mov	  cx, 442h
F000:D295
F000:D295 delay1:						      ;	CODE XREF: sub_FD1C4:delay1j
F000:D295		  loop	  delay1
F000:D297		  dec	  al
F000:D299		  cmp	  al, 0
F000:D29B		  jnz	  short	l3
F000:D29D
F000:D29D l4:							      ;	CODE XREF: sub_FD1C4+CCj
F000:D29D		  clc
F000:D29E		  jmp	  short	exit
F000:D2A0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D2A0
F000:D2A0 l5:							      ;	CODE XREF: sub_FD1C4+62j
F000:D2A0							      ;	sub_FD1C4+6Bj
F000:D2A0							      ;	sub_FD1C4+70j
F000:D2A0							      ;	sub_FD1C4+75j ...
F000:D2A0		  or	  byte ptr ds:p400.diskette_last_status, 40h ; seek failure
F000:D2A5		  call	  sub_FD2D4
F000:D2A8		  stc
F000:D2A9
F000:D2A9 exit:							      ;	CODE XREF: sub_FD1C4+DAj
F000:D2A9		  pop	  dx
F000:D2AA		  pop	  cx
F000:D2AB		  pop	  ax
F000:D2AC		  retn
F000:D2AC sub_FD1C4	  endp
F000:D2AC
F000:D2AD
F000:D2AD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D2AD
F000:D2AD
F000:D2AD sub_FD2AD	  proc near				      ;	CODE XREF: int_13_00_handler+49p
F000:D2AD							      ;	sub_FD1C4+72p
F000:D2AD							      ;	sub_FD1C4+8Cp
F000:D2AD							      ;	sub_FD1C4+BCp
F000:D2AD		  push	  cx
F000:D2AE		  push	  si
F000:D2AF		  lea	  si, ds:p400.diskette_command_bytes
F000:D2B3		  mov	  ax, [si]
F000:D2B5		  push	  ax
F000:D2B6		  mov	  al, 8
F000:D2B8		  call	  sub_FD118
F000:D2BB		  jb	  short	error
F000:D2BD		  mov	  cx, 2
F000:D2C0		  call	  sub_FD170
F000:D2C3		  jb	  short	error
F000:D2C5		  mov	  ax, [si]
F000:D2C7		  xchg	  ah, al
F000:D2C9		  pop	  bx
F000:D2CA		  mov	  [si],	bx
F000:D2CC		  clc
F000:D2CD		  jmp	  short	exit
F000:D2CF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D2CF
F000:D2CF error:						      ;	CODE XREF: sub_FD2AD+Ej
F000:D2CF							      ;	sub_FD2AD+16j
F000:D2CF		  pop	  bx
F000:D2D0		  stc
F000:D2D1
F000:D2D1 exit:							      ;	CODE XREF: sub_FD2AD+20j
F000:D2D1		  pop	  si
F000:D2D2		  pop	  cx
F000:D2D3		  retn
F000:D2D3 sub_FD2AD	  endp
F000:D2D3
F000:D2D4
F000:D2D4 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D2D4
F000:D2D4
F000:D2D4 sub_FD2D4	  proc near				      ;	CODE XREF: int_13_02_handler+80p
F000:D2D4							      ;	int_13_02_dma_handler+142p
F000:D2D4							      ;	int_13_05_dma_handler+8Fp
F000:D2D4							      ;	int_13_05_handler+5Dp ...
F000:D2D4		  lea	  si, ds:p400.diskette_command_bytes
F000:D2D8		  mov	  al, [si+1]
F000:D2DB		  or	  al, [si+2]
F000:D2DE		  mov	  cx, 8
F000:D2E1		  xor	  bx, bx
F000:D2E3		  and	  al, 0B7h
F000:D2E5
F000:D2E5 l0:							      ;	CODE XREF: sub_FD2D4+18j
F000:D2E5		  test	  al, 1
F000:D2E7		  jnz	  short	l1
F000:D2E9		  inc	  bx
F000:D2EA		  ror	  al, 1
F000:D2EC		  loop	  l0
F000:D2EE		  jmp	  short	exit
F000:D2F0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D2F0
F000:D2F0 l1:							      ;	CODE XREF: sub_FD2D4+13j
F000:D2F0		  mov	  al, cs:diskette_something[bx]
F000:D2F5		  or	  ds:p400.diskette_last_status,	al
F000:D2F9
F000:D2F9 exit:							      ;	CODE XREF: sub_FD2D4+1Aj
F000:D2F9		  retn
F000:D2F9 sub_FD2D4	  endp
F000:D2F9
F000:D2F9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D2FA diskette_something db	2				      ;	DATA XREF: sub_FD2D4:l1r
F000:D2FB		  db	3
F000:D2FC		  db	4
F000:D2FD		  db	0
F000:D2FE		  db	8
F000:D2FF		  db  10h
F000:D300		  db	0
F000:D301		  db	4
F000:D302
F000:D302 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D302
F000:D302
F000:D302 get_diskette_params_addr proc	near			      ;	CODE XREF: int_13_02_handler+2Fp
F000:D302							      ;	int_13_02_dma_handler+35p
F000:D302							      ;	sub_FCE83+Bp
F000:D302							      ;	int_13_05_dma_handler:loc_FCF04p ...
F000:D302		  push	  ax
F000:D303		  xor	  ax, ax
F000:D305		  mov	  es, ax
F000:D307		  push	  bx
F000:D308		  mov	  bx, 78h ; 'x'
F000:D30B		  mov	  si, es:[bx]			      ;	int 1e low
F000:D30E		  mov	  ax, es:[bx+2]			      ;	int 1e hi
F000:D312		  mov	  es, ax
F000:D314		  pop	  bx
F000:D315		  pop	  ax
F000:D316		  retn
F000:D316 get_diskette_params_addr endp
F000:D316
F000:D317
F000:D317 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D317
F000:D317
F000:D317 sub_FD317	  proc near				      ;	CODE XREF: int_13_00_handler:loc_FCC5Bp
F000:D317							      ;	int_13_02_handler+68p
F000:D317							      ;	int_13_05_dma_handler+41p
F000:D317							      ;	int_13_05_handler+3Ep ...
F000:D317		  push	  cx
F000:D318		  call	  get_diskette_params_addr
F000:D31B
F000:D31B l0:							      ;	CODE XREF: sub_FD317+Dj
F000:D31B		  mov	  al, es:[bx+si]
F000:D31E		  call	  sub_FD118
F000:D321		  jb	  short	exit
F000:D323		  inc	  bx
F000:D324		  loop	  l0
F000:D326		  clc
F000:D327
F000:D327 exit:							      ;	CODE XREF: sub_FD317+Aj
F000:D327		  pop	  cx
F000:D328		  retn
F000:D328 sub_FD317	  endp
F000:D328
F000:D329
F000:D329 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D329
F000:D329
F000:D329 sub_FD329	  proc near				      ;	CODE XREF: int_13_02_dma_handler+6Ep
F000:D329							      ;	int_13_05_dma_handler+4Ep
F000:D329		  push	  cx
F000:D32A		  call	  get_diskette_params_addr
F000:D32D		  dec	  cx
F000:D32E
F000:D32E l0:							      ;	CODE XREF: sub_FD329+Ej
F000:D32E		  mov	  al, es:[bx+si]
F000:D331		  call	  sub_FD118
F000:D334		  jb	  short	exit
F000:D336		  inc	  bx
F000:D337		  loop	  l0
F000:D339		  clc
F000:D33A		  call	  sub_FD148
F000:D33D		  jb	  short	exit
F000:D33F		  mov	  dh, es:[bx+si]
F000:D342
F000:D342 exit:							      ;	CODE XREF: sub_FD329+Bj
F000:D342							      ;	sub_FD329+14j
F000:D342		  pop	  cx
F000:D343		  retn
F000:D343 sub_FD329	  endp
F000:D343
F000:D344
F000:D344 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D344
F000:D344
F000:D344 sub_FD344	  proc near				      ;	CODE XREF: int_13_00_handler+6Ep
F000:D344		  push	  cx
F000:D345		  call	  get_diskette_params_addr
F000:D348		  mov	  al, es:[bx+si]
F000:D34B		  call	  sub_FD118
F000:D34E		  jb	  short	exit
F000:D350		  inc	  bx
F000:D351		  mov	  al, es:[bx+si]
F000:D354		  or	  al, 1
F000:D356		  call	  sub_FD118
F000:D359		  jb	  short	exit
F000:D35B		  clc
F000:D35C
F000:D35C exit:							      ;	CODE XREF: sub_FD344+Aj
F000:D35C							      ;	sub_FD344+15j
F000:D35C		  pop	  cx
F000:D35D		  retn
F000:D35D sub_FD344	  endp
F000:D35D
F000:D35D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D35E value_b000	  dw 0B000h				      ;	DATA XREF: scroll_graphics_up_or_downr
F000:D35E							      ;	gfx_get_ascii_value_for_row_col+15r
F000:D35E							      ;	gfx_print_char+CEr
F000:D35E							      ;	gfx_print_char+127r
F000:D360
F000:D360 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D360
F000:D360 ;	Scrolls	a specified window upward/downward a specified number of lines.
F000:D360 ;
F000:D360 ;	   On entry:	  AH	     06h
F000:D360 ;			  AL	     Number of lines to	scroll (if 0, clear entire
F000:D360 ;				     window)
F000:D360 ;			  BH	     Attribute (alpha modes) or	color (graphics	modes) to be used on blank line
F000:D360 ;			  CH	     Row number	of upper left corner
F000:D360 ;			  CL	     Column number of upper left corner
F000:D360 ;			  DH	     Row number	of lower right corner
F000:D360 ;			  DL	     Column number of lower right corner
F000:D360 ;			  [BP+0]     Direction:	0=Upwards. 1=Downwards
F000:D360 ;
F000:D360 ;	   Returns:	  None
F000:D360 ; Attributes:	bp-based frame
F000:D360
F000:D360 scroll_graphics_up_or_down proc near			      ;	CODE XREF: scroll_up_or_down+1Dj
F000:D360
F000:D360 var_orig_di	  = word ptr -4
F000:D360 var_orig_si	  = word ptr -2
F000:D360 arg_scroll_direction=	word ptr  4
F000:D360 arg_row_bottom  = byte ptr  11h
F000:D360 arg_row_top	  = byte ptr  13h
F000:D360 arg_color	  = byte ptr  15h
F000:D360
F000:D360		  mov	  es, cs:value_b000		      ;	es = 0xb000 (graphics segment)
F000:D365		  cmp	  word ptr [bp+0], 0		      ;	0=scroll up, 1=	scroll down
F000:D369		  jz	  short	s0
F000:D36B		  mov	  dh, ch
F000:D36D
F000:D36D s0:							      ;	CODE XREF: scroll_graphics_up_or_down+9j
F000:D36D		  inc	  dl
F000:D36F		  push	  ax
F000:D370		  mov	  ax, ds:p400.crt_nr_cols
F000:D373		  mov	  ch, al
F000:D375		  pop	  ax
F000:D376		  cmp	  dl, ch
F000:D378		  jnz	  short	s1
F000:D37A		  inc	  dh
F000:D37C		  xor	  dl, dl
F000:D37E		  call	  multiply_dl_dh_by_8_bis	      ;	cx = dl	* 8; dx	= dh * 8
F000:D381		  jmp	  short	s2
F000:D383 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D383
F000:D383 s1:							      ;	CODE XREF: scroll_graphics_up_or_down+18j
F000:D383		  call	  multiply_dl_dh_by_8_bis
F000:D386		  add	  bx, 0F0h ; 'ğ'
F000:D38A		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D38F		  jb	  short	s2
F000:D391		  sub	  bx, 50h ; 'P'
F000:D394
F000:D394 s2:							      ;	CODE XREF: scroll_graphics_up_or_down+21j
F000:D394							      ;	scroll_graphics_up_or_down+2Fj
F000:D394		  add	  bh, 20h ; ' '
F000:D397		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D39C		  jb	  short	s3
F000:D39E		  add	  bh, 40h ; '@'
F000:D3A1
F000:D3A1 s3:							      ;	CODE XREF: scroll_graphics_up_or_down+3Cj
F000:D3A1		  push	  bx				      ;	sp += 2
F000:D3A2		  mov	  bp, sp			      ;	bp = sp
F000:D3A4		  xor	  ch, ch
F000:D3A6		  cmp	  [bp+arg_scroll_direction], 0
F000:D3AA		  jz	  short	s4
F000:D3AC		  mov	  ch, [bp+arg_row_bottom]
F000:D3AF		  sub	  ch, [bp+arg_row_top]
F000:D3B2
F000:D3B2 s4:							      ;	CODE XREF: scroll_graphics_up_or_down+4Aj
F000:D3B2		  mov	  dx, [bp+12h]
F000:D3B5		  add	  dh, ch
F000:D3B7		  push	  cx
F000:D3B8		  call	  multiply_dl_dh_by_8_bis
F000:D3BB		  mov	  di, bx
F000:D3BD		  pop	  cx
F000:D3BE		  mov	  dh, [bp+arg_row_bottom]
F000:D3C1		  sub	  dh, [bp+arg_row_top]
F000:D3C4		  cmp	  dh, 0
F000:D3C7		  jnz	  short	s5
F000:D3C9		  jmp	  l1
F000:D3CC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D3CC
F000:D3CC s5:							      ;	CODE XREF: scroll_graphics_up_or_down+67j
F000:D3CC		  mov	  dx, [bp+12h]
F000:D3CF		  add	  dh, ch
F000:D3D1		  cmp	  [bp+arg_scroll_direction], 0
F000:D3D5		  jnz	  short	s6
F000:D3D7		  add	  dh, al
F000:D3D9		  jmp	  short	s7
F000:D3DB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D3DB
F000:D3DB s6:							      ;	CODE XREF: scroll_graphics_up_or_down+75j
F000:D3DB		  sub	  dh, al
F000:D3DD
F000:D3DD s7:							      ;	CODE XREF: scroll_graphics_up_or_down+79j
F000:D3DD		  call	  multiply_dl_dh_by_8_bis
F000:D3E0		  mov	  si, bx
F000:D3E2		  xor	  cx, cx
F000:D3E4		  cmp	  al, 0
F000:D3E6		  jnz	  short	l0
F000:D3E8		  jmp	  l1
F000:D3EB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D3EB
F000:D3EB l0:							      ;	CODE XREF: scroll_graphics_up_or_down+86j
F000:D3EB							      ;	scroll_graphics_up_or_down+12Cj
F000:D3EB		  push	  si
F000:D3EC		  push	  di
F000:D3ED		  push	  ds
F000:D3EE		  xor	  bx, bx
F000:D3F0		  mov	  cl, ah
F000:D3F2		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D3F7		  jz	  short	s10
F000:D3F9		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D3FE		  jb	  short	s9
F000:D400		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:D405		  jnb	  short	s9
F000:D407		  shl	  cl, 1
F000:D409
F000:D409 s9:							      ;	CODE XREF: scroll_graphics_up_or_down+9Ej
F000:D409							      ;	scroll_graphics_up_or_down+A5j
F000:D409		  shl	  cl, 1
F000:D40B
F000:D40B s10:							      ;	CODE XREF: scroll_graphics_up_or_down+97j
F000:D40B		  mov	  dh, ds:p400.crt_mode
F000:D40F		  push	  ax
F000:D410		  mov	  ax, es
F000:D412		  mov	  ds, ax
F000:D414		  pop	  ax
F000:D415		  mov	  dl, 4
F000:D417		  cmp	  dh, 9
F000:D41A		  jb	  short	s11
F000:D41C		  mov	  dl, 2
F000:D41E
F000:D41E s11:							      ;	CODE XREF: scroll_graphics_up_or_down+BAj
F000:D41E							      ;	scroll_graphics_up_or_down+11Fj
F000:D41E		  mov	  si, [bp+var_orig_si]		      ;	do the scroll (copy lines from one place to another)
F000:D421		  mov	  di, [bp+var_orig_di]
F000:D424		  add	  si, bx
F000:D426		  add	  di, bx
F000:D428		  push	  cx
F000:D429		  rep movsb
F000:D42B		  pop	  cx
F000:D42C		  mov	  si, [bp+var_orig_si]
F000:D42F		  mov	  di, [bp+var_orig_di]
F000:D432		  add	  si, 2000h
F000:D436		  add	  di, 2000h
F000:D43A		  add	  si, bx
F000:D43C		  add	  di, bx
F000:D43E		  push	  cx
F000:D43F		  rep movsb
F000:D441		  pop	  cx
F000:D442		  cmp	  dh, 9
F000:D445		  jb	  short	s12
F000:D447		  mov	  si, [bp+var_orig_si]
F000:D44A		  mov	  di, [bp+var_orig_di]
F000:D44D		  add	  si, 4000h
F000:D451		  add	  di, 4000h
F000:D455		  add	  si, bx
F000:D457		  add	  di, bx
F000:D459		  push	  cx
F000:D45A		  rep movsb
F000:D45C		  pop	  cx
F000:D45D		  mov	  si, [bp+var_orig_si]
F000:D460		  mov	  di, [bp+var_orig_di]
F000:D463		  add	  si, 6000h
F000:D467		  add	  di, 6000h
F000:D46B		  add	  si, bx
F000:D46D		  add	  di, bx
F000:D46F		  push	  cx
F000:D470		  rep movsb
F000:D472		  pop	  cx
F000:D473		  add	  bx, 0A0h ; ' '
F000:D477		  jmp	  short	s13
F000:D479 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D479		  nop
F000:D47A
F000:D47A s12:							      ;	CODE XREF: scroll_graphics_up_or_down+E5j
F000:D47A		  add	  bx, 50h ; 'P'
F000:D47D
F000:D47D s13:							      ;	CODE XREF: scroll_graphics_up_or_down+117j
F000:D47D		  dec	  dl
F000:D47F		  jnz	  short	s11
F000:D481		  pop	  ds
F000:D482		  cmp	  si, [bp+0]
F000:D485		  jz	  short	s14
F000:D487		  pop	  di
F000:D488		  pop	  si
F000:D489		  call	  add_or_sub_320
F000:D48C		  jmp	  l0
F000:D48F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D48F
F000:D48F s14:							      ;	CODE XREF: scroll_graphics_up_or_down+125j
F000:D48F		  pop	  di
F000:D490		  pop	  si
F000:D491		  call	  add_or_sub_320
F000:D494
F000:D494 l1:							      ;	CODE XREF: scroll_graphics_up_or_down+69j
F000:D494							      ;	scroll_graphics_up_or_down+88j
F000:D494							      ;	scroll_graphics_up_or_down+1AFj
F000:D494		  push	  di
F000:D495		  mov	  al, [bp+arg_color]
F000:D498		  xor	  bx, bx
F000:D49A		  mov	  cl, ah
F000:D49C		  mov	  dx, 4
F000:D49F		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D4A4		  jb	  short	s15
F000:D4A6		  mov	  dx, 2
F000:D4A9
F000:D4A9 s15:							      ;	CODE XREF: scroll_graphics_up_or_down+144j
F000:D4A9		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D4AE		  jz	  short	l2
F000:D4B0		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D4B5		  jb	  short	s16
F000:D4B7		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:D4BC		  jnb	  short	s16
F000:D4BE		  shl	  cl, 1
F000:D4C0
F000:D4C0 s16:							      ;	CODE XREF: scroll_graphics_up_or_down+155j
F000:D4C0							      ;	scroll_graphics_up_or_down+15Cj
F000:D4C0		  shl	  cl, 1
F000:D4C2
F000:D4C2 l2:							      ;	CODE XREF: scroll_graphics_up_or_down+14Ej
F000:D4C2							      ;	scroll_graphics_up_or_down+1A4j
F000:D4C2		  mov	  di, [bp+var_orig_si]		      ;	clean the new lines
F000:D4C5		  add	  di, bx
F000:D4C7		  push	  cx
F000:D4C8		  rep stosb
F000:D4CA		  pop	  cx
F000:D4CB		  mov	  di, [bp+var_orig_si]
F000:D4CE		  add	  di, 2000h
F000:D4D2		  add	  di, bx
F000:D4D4		  push	  cx
F000:D4D5		  rep stosb
F000:D4D7		  pop	  cx
F000:D4D8		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D4DD		  jb	  short	s17
F000:D4DF		  mov	  di, [bp+var_orig_si]
F000:D4E2		  add	  di, 4000h
F000:D4E6		  add	  di, bx
F000:D4E8		  push	  cx
F000:D4E9		  rep stosb
F000:D4EB		  pop	  cx
F000:D4EC		  mov	  di, [bp+var_orig_si]
F000:D4EF		  add	  di, 6000h
F000:D4F3		  add	  di, bx
F000:D4F5		  push	  cx
F000:D4F6		  rep stosb
F000:D4F8		  pop	  cx
F000:D4F9		  add	  bx, 0A0h ; ' '
F000:D4FD		  jmp	  short	s18
F000:D4FF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D4FF		  nop
F000:D500
F000:D500 s17:							      ;	CODE XREF: scroll_graphics_up_or_down+17Dj
F000:D500		  add	  bx, 50h ; 'P'
F000:D503
F000:D503 s18:							      ;	CODE XREF: scroll_graphics_up_or_down+19Dj
F000:D503		  dec	  dx
F000:D504		  jnz	  short	l2
F000:D506		  cmp	  di, [bp+0]
F000:D509		  jz	  short	exit
F000:D50B		  pop	  di
F000:D50C		  call	  add_or_sub_320
F000:D50F		  jmp	  short	l1
F000:D511 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D511
F000:D511 exit:							      ;	CODE XREF: scroll_graphics_up_or_down+1A9j
F000:D511		  pop	  di
F000:D512		  pop	  bx
F000:D513		  retn
F000:D513 scroll_graphics_up_or_down endp
F000:D513
F000:D514
F000:D514 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D514
F000:D514
F000:D514 gfx_get_ascii_value_for_row_col proc near		      ;	CODE XREF: int_10_08_handler+Ap
F000:D514		  call	  multiply_dl_dh_by_8_bis
F000:D517		  sub	  sp, 0Ah
F000:D51A		  mov	  bp, sp
F000:D51C		  push	  bx
F000:D51D		  xor	  bx, bx
F000:D51F		  mov	  cx, 8
F000:D522		  xor	  dl, dl
F000:D524
F000:D524 l0:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col:l24j
F000:D524		  pop	  si
F000:D525		  push	  si
F000:D526		  add	  si, bx
F000:D528		  push	  es
F000:D529		  mov	  es, cs:value_b000
F000:D52E		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D533		  jnz	  short	l1
F000:D535		  jmp	  l18
F000:D538 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D538
F000:D538 l1:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+1Fj
F000:D538		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:D53D		  jnz	  short	l2
F000:D53F		  jmp	  l15
F000:D542 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D542
F000:D542 l2:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+29j
F000:D542		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D547		  jnb	  short	l7
F000:D549		  mov	  ax, es:[si]
F000:D54C		  inc	  si
F000:D54D		  inc	  si
F000:D54E		  xchg	  ah, al
F000:D550		  push	  bx
F000:D551		  push	  cx
F000:D552		  mov	  cx, 8
F000:D555		  xor	  dh, dh
F000:D557
F000:D557 l3:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col:l6j
F000:D557		  xor	  bl, bl
F000:D559		  shl	  dh, 1
F000:D55B		  shl	  ax, 1
F000:D55D		  jnb	  short	l4
F000:D55F		  or	  dl, 2
F000:D562		  mov	  bl, 1
F000:D564
F000:D564 l4:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+49j
F000:D564		  shl	  ax, 1
F000:D566		  jnb	  short	l5
F000:D568		  or	  dl, 1
F000:D56B		  mov	  bl, 1
F000:D56D
F000:D56D l5:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+52j
F000:D56D		  cmp	  bl, 0
F000:D570		  jz	  short	l6
F000:D572		  or	  dh, 1
F000:D575
F000:D575 l6:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+5Cj
F000:D575		  loop	  l3
F000:D577		  pop	  cx
F000:D578		  pop	  bx
F000:D579		  mov	  al, dh
F000:D57B		  jmp	  short	l19
F000:D57D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D57D
F000:D57D l7:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+33j
F000:D57D		  push	  bx
F000:D57E		  push	  cx
F000:D57F		  xor	  dh, dh
F000:D581		  mov	  cx, 2
F000:D584
F000:D584 l8:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+AEj
F000:D584		  push	  cx
F000:D585		  mov	  cx, 4
F000:D588		  mov	  ax, es:[si]
F000:D58B		  inc	  si
F000:D58C		  inc	  si
F000:D58D		  xchg	  ah, al
F000:D58F
F000:D58F l9:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col:l14j
F000:D58F		  xor	  bl, bl
F000:D591		  shl	  dh, 1
F000:D593		  shl	  ax, 1
F000:D595		  jnb	  short	l10
F000:D597		  or	  dl, 8
F000:D59A		  mov	  bl, 1
F000:D59C
F000:D59C l10:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+81j
F000:D59C		  shl	  ax, 1
F000:D59E		  jnb	  short	l11
F000:D5A0		  or	  dl, 4
F000:D5A3		  mov	  bl, 1
F000:D5A5
F000:D5A5 l11:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+8Aj
F000:D5A5		  shl	  ax, 1
F000:D5A7		  jnb	  short	l12
F000:D5A9		  or	  dl, 2
F000:D5AC		  mov	  bl, 1
F000:D5AE
F000:D5AE l12:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+93j
F000:D5AE		  shl	  ax, 1
F000:D5B0		  jnb	  short	l13
F000:D5B2		  or	  dl, 1
F000:D5B5		  mov	  bl, 1
F000:D5B7
F000:D5B7 l13:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+9Cj
F000:D5B7		  cmp	  bl, 0
F000:D5BA		  jz	  short	l14
F000:D5BC		  or	  dh, 1
F000:D5BF
F000:D5BF l14:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+A6j
F000:D5BF		  loop	  l9
F000:D5C1		  pop	  cx
F000:D5C2		  loop	  l8
F000:D5C4		  pop	  cx
F000:D5C5		  pop	  bx
F000:D5C6		  mov	  al, dh
F000:D5C8		  jmp	  short	l19
F000:D5CA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D5CA
F000:D5CA l15:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+2Bj
F000:D5CA		  mov	  al, es:[si]
F000:D5CD		  cmp	  al, 0
F000:D5CF		  jz	  short	l16
F000:D5D1		  or	  dl, 1
F000:D5D4
F000:D5D4 l16:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+BBj
F000:D5D4		  mov	  ah, es:[si+1]
F000:D5D8		  cmp	  ah, 0
F000:D5DB		  jz	  short	l17
F000:D5DD		  or	  dl, 2
F000:D5E0
F000:D5E0 l17:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+C7j
F000:D5E0		  or	  al, ah
F000:D5E2		  jmp	  short	l19
F000:D5E4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D5E4		  nop
F000:D5E5
F000:D5E5 l18:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+21j
F000:D5E5		  mov	  al, es:[si]
F000:D5E8		  inc	  si
F000:D5E9		  cmp	  al, 0
F000:D5EB		  jz	  short	l19
F000:D5ED		  mov	  dl, 1
F000:D5EF
F000:D5EF l19:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+67j
F000:D5EF							      ;	gfx_get_ascii_value_for_row_col+B4j
F000:D5EF							      ;	gfx_get_ascii_value_for_row_col+CEj
F000:D5EF							      ;	gfx_get_ascii_value_for_row_col+D7j
F000:D5EF		  pop	  es
F000:D5F0		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D5F5		  jb	  short	l20
F000:D5F7		  cmp	  cx, 5
F000:D5FA		  jnz	  short	l21
F000:D5FC		  sub	  bx, 5F60h
F000:D600		  jmp	  short	l23
F000:D602 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D602		  nop
F000:D603
F000:D603 l20:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+E1j
F000:D603		  test	  cx, 1
F000:D607		  jnz	  short	l22
F000:D609
F000:D609 l21:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+E6j
F000:D609		  add	  bh, 20h ; ' '
F000:D60C		  jmp	  short	l23
F000:D60E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D60E
F000:D60E l22:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+F3j
F000:D60E		  sub	  bx, 1FB0h
F000:D612
F000:D612 l23:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+ECj
F000:D612							      ;	gfx_get_ascii_value_for_row_col+F8j
F000:D612		  mov	  [bp+0], al
F000:D615		  inc	  bp
F000:D616		  loop	  l24
F000:D618		  jmp	  short	l25
F000:D61A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D61A		  nop
F000:D61B
F000:D61B l24:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+102j
F000:D61B		  jmp	  l0
F000:D61E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D61E
F000:D61E l25:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+104j
F000:D61E		  sub	  bp, 8
F000:D621		  mov	  [bp+8], dl
F000:D624		  xor	  ax, ax
F000:D626		  mov	  es, ax
F000:D628		  mov	  bx, 110h			      ;	0000:0110 = int	44 (charset 0-127)
F000:D62B		  mov	  di, es:[bx]			      ;	int 44 low
F000:D62E		  mov	  ax, es:[bx+2]			      ;	int 44 hi
F000:D632		  mov	  es, ax
F000:D634		  xor	  cx, cx
F000:D636		  push	  ds
F000:D637		  mov	  ax, ss
F000:D639		  mov	  ds, ax
F000:D63B		  xor	  ax, ax
F000:D63D		  jmp	  short	l27
F000:D63F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D63F
F000:D63F l26:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+13Ej
F000:D63F							      ;	gfx_get_ascii_value_for_row_col+143j
F000:D63F		  inc	  ax
F000:D640		  cmp	  ax, 7Fh ; ''                       ; char is 0x80 or bigger ?
F000:D643		  ja	  short	l29
F000:D645
F000:D645 l27:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+129j
F000:D645		  mov	  si, bp
F000:D647		  mov	  cx, 4
F000:D64A		  repe cmpsw
F000:D64C		  jz	  short	l28
F000:D64E		  add	  di, cx
F000:D650		  add	  di, cx
F000:D652		  jmp	  short	l26
F000:D654 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D654
F000:D654 l28:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+138j
F000:D654		  cmp	  cx, 0
F000:D657		  jnz	  short	l26
F000:D659		  jmp	  short	l34
F000:D65B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D65B
F000:D65B l29:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+12Fj
F000:D65B		  xor	  ax, ax
F000:D65D		  mov	  es, ax
F000:D65F		  mov	  bx, 7Ch ; '|'                       ; 0000:007c int 1f (charset 128-255)
F000:D662		  mov	  di, es:[bx]
F000:D665		  mov	  ax, es:[bx+2]
F000:D669		  mov	  es, ax
F000:D66B		  xor	  cx, cx
F000:D66D		  mov	  ax, ss
F000:D66F		  mov	  ds, ax
F000:D671		  xor	  ax, ax
F000:D673		  jmp	  short	l31
F000:D675 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D675
F000:D675 l30:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+174j
F000:D675							      ;	gfx_get_ascii_value_for_row_col+179j
F000:D675		  inc	  ax
F000:D676		  cmp	  ax, 7Fh ; ''
F000:D679		  ja	  short	l33
F000:D67B
F000:D67B l31:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+15Fj
F000:D67B		  mov	  si, bp
F000:D67D		  mov	  cx, 4
F000:D680		  repe cmpsw
F000:D682		  jz	  short	l32
F000:D684		  add	  di, cx
F000:D686		  add	  di, cx
F000:D688		  jmp	  short	l30
F000:D68A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D68A
F000:D68A l32:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+16Ej
F000:D68A		  cmp	  cx, 0
F000:D68D		  jnz	  short	l30
F000:D68F		  add	  ax, 80h ; '€'
F000:D692		  jmp	  short	l34
F000:D694 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D694
F000:D694 l33:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+165j
F000:D694		  pop	  ds
F000:D695		  xor	  ax, ax
F000:D697		  jmp	  short	exit
F000:D699 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D699
F000:D699 l34:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+145j
F000:D699							      ;	gfx_get_ascii_value_for_row_col+17Ej
F000:D699		  pop	  ds
F000:D69A		  mov	  ah, [bp+8]
F000:D69D
F000:D69D exit:							      ;	CODE XREF: gfx_get_ascii_value_for_row_col+183j
F000:D69D		  add	  sp, 0Ah
F000:D6A0		  pop	  bx
F000:D6A1		  retn
F000:D6A1 gfx_get_ascii_value_for_row_col endp
F000:D6A1
F000:D6A2
F000:D6A2 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D6A2
F000:D6A2
F000:D6A2 gfx_print_char  proc near				      ;	CODE XREF: int_10_0a_handler+12p
F000:D6A2
F000:D6A2 ; FUNCTION CHUNK AT F000:D869	SIZE 00000003 BYTES
F000:D6A2
F000:D6A2		  mov	  bx, cx
F000:D6A4		  call	  multiply_dl_dh_by_8
F000:D6A7		  push	  cx
F000:D6A8		  push	  dx
F000:D6A9		  push	  bx
F000:D6AA		  push	  ax
F000:D6AB		  cmp	  al, 7Fh ; ''                       ; char to print is between 0-127?
F000:D6AD		  jbe	  short	get_charset_0_127
F000:D6AF		  pop	  ax
F000:D6B0		  sub	  al, 80h ; '€'
F000:D6B2		  push	  ax
F000:D6B3		  xor	  ax, ax
F000:D6B5		  mov	  es, ax
F000:D6B7		  mov	  bx, 7Ch ; '|'                       ; int 1f (charset 128-255)
F000:D6BA		  mov	  si, es:[bx]
F000:D6BD		  mov	  ax, es:[bx+2]
F000:D6C1		  mov	  es, ax			      ;	es:si ptr to charset
F000:D6C3		  jmp	  short	calc_offset_and_print
F000:D6C5 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D6C5
F000:D6C5 get_charset_0_127:					      ;	CODE XREF: gfx_print_char+Bj
F000:D6C5		  xor	  ax, ax
F000:D6C7		  mov	  es, ax
F000:D6C9		  mov	  bx, 110h			      ;	int 44 (charset	0-127)
F000:D6CC		  mov	  si, es:[bx]
F000:D6CF		  mov	  ax, es:[bx+2]
F000:D6D3		  mov	  es, ax			      ;	es:si ptr to charset
F000:D6D5
F000:D6D5 calc_offset_and_print:				      ;	CODE XREF: gfx_print_char+21j
F000:D6D5		  pop	  ax
F000:D6D6		  xor	  bh, bh
F000:D6D8		  mov	  bl, al
F000:D6DA		  shl	  bx, 1
F000:D6DC		  shl	  bx, 1
F000:D6DE		  shl	  bx, 1				      ;	char * 8.  es:si ptr to	charset[char]
F000:D6E0		  add	  si, bx
F000:D6E2		  jmp	  short	print_char_at_offset
F000:D6E4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D6E4
F000:D6E4 something_with_screen_width:				      ;	CODE XREF: gfx_print_char:l14j
F000:D6E4		  mov	  bp, cx
F000:D6E6		  pop	  dx
F000:D6E7		  pop	  cx
F000:D6E8		  sub	  si, 8
F000:D6EB		  mov	  bx, 160
F000:D6EE		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D6F3		  jz	  short	l0
F000:D6F5		  mov	  bx, 320
F000:D6F8		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D6FD		  jz	  short	l0
F000:D6FF		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D704		  jb	  short	l0
F000:D706		  mov	  bx, 640
F000:D709
F000:D709 l0:							      ;	CODE XREF: gfx_print_char+51j
F000:D709							      ;	gfx_print_char+5Bj
F000:D709							      ;	gfx_print_char+62j
F000:D709		  add	  cx, 8
F000:D70C		  cmp	  cx, bx
F000:D70E		  jnz	  short	l1
F000:D710		  add	  dx, 8
F000:D713		  xor	  cx, cx
F000:D715		  cmp	  dx, 200
F000:D719		  jnz	  short	l1
F000:D71B		  retn
F000:D71C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D71C
F000:D71C l1:							      ;	CODE XREF: gfx_print_char+6Cj
F000:D71C							      ;	gfx_print_char+77j
F000:D71C		  push	  cx
F000:D71D		  push	  dx
F000:D71E		  push	  bp
F000:D71F
F000:D71F print_char_at_offset:					      ;	CODE XREF: gfx_print_char+40j
F000:D71F		  call	  get_address_for_pixel
F000:D722		  mov	  di, bx
F000:D724		  push	  di
F000:D725		  mov	  bp, sp
F000:D727		  xor	  bx, bx
F000:D729		  mov	  cx, 8
F000:D72C		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D731		  jnz	  short	l2
F000:D733		  jmp	  do_video_mode_8_9
F000:D736 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D736
F000:D736 l2:							      ;	CODE XREF: gfx_print_char+8Fj
F000:D736		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:D73B		  jnz	  short	l3
F000:D73D		  jmp	  short	do_video_mode_8_9
F000:D73F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D73F		  nop
F000:D740
F000:D740 l3:							      ;	CODE XREF: gfx_print_char+99j
F000:D740		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:D745		  jnz	  short	l4
F000:D747		  jmp	  do_video_mode_a
F000:D74A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D74A
F000:D74A l4:							      ;	CODE XREF: gfx_print_char+A3j
F000:D74A							      ;	gfx_print_char:l12j
F000:D74A		  mov	  dl, es:[si]
F000:D74D		  inc	  si
F000:D74E		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D753		  jz	  short	do_video_mode_6
F000:D755		  push	  cx
F000:D756		  mov	  cx, 8
F000:D759		  mov	  al, dl
F000:D75B		  xor	  dx, dx
F000:D75D
F000:D75D l5:							      ;	CODE XREF: gfx_print_char:l6j
F000:D75D		  shl	  dx, 1
F000:D75F		  shl	  dx, 1
F000:D761		  shl	  al, 1
F000:D763		  jnb	  short	l6
F000:D765		  push	  ax
F000:D766		  and	  ah, 3
F000:D769		  or	  dl, ah
F000:D76B		  pop	  ax
F000:D76C
F000:D76C l6:							      ;	CODE XREF: gfx_print_char+C1j
F000:D76C		  loop	  l5
F000:D76E		  pop	  cx
F000:D76F
F000:D76F do_video_mode_6:					      ;	CODE XREF: gfx_print_char+B1j
F000:D76F		  push	  es
F000:D770		  mov	  es, cs:value_b000
F000:D775		  push	  ax
F000:D776		  xchg	  ax, dx
F000:D777		  mov	  di, [bp+0]
F000:D77A		  add	  di, bx
F000:D77C		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D781		  jz	  short	l8
F000:D783		  xchg	  ah, al
F000:D785		  test	  dh, 80h
F000:D788		  jz	  short	l7
F000:D78A		  xor	  es:[di], ax
F000:D78D		  inc	  di
F000:D78E		  inc	  di
F000:D78F		  jmp	  short	l10
F000:D791 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D791
F000:D791 l7:							      ;	CODE XREF: gfx_print_char+E6j
F000:D791		  stosw
F000:D792		  jmp	  short	l10
F000:D794 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D794
F000:D794 l8:							      ;	CODE XREF: gfx_print_char+DFj
F000:D794		  test	  dh, 80h
F000:D797		  jz	  short	l9
F000:D799		  xor	  es:[di], al
F000:D79C		  inc	  di
F000:D79D		  jmp	  short	l10
F000:D79F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D79F
F000:D79F l9:							      ;	CODE XREF: gfx_print_char+F5j
F000:D79F		  stosb
F000:D7A0
F000:D7A0 l10:							      ;	CODE XREF: gfx_print_char+EDj
F000:D7A0							      ;	gfx_print_char+F0j
F000:D7A0							      ;	gfx_print_char+FBj
F000:D7A0		  pop	  ax
F000:D7A1		  pop	  es
F000:D7A2		  test	  cx, 1
F000:D7A6		  jnz	  short	l11
F000:D7A8		  add	  bh, 20h ; ' '
F000:D7AB		  jmp	  short	l12
F000:D7AD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D7AD
F000:D7AD l11:							      ;	CODE XREF: gfx_print_char+104j
F000:D7AD		  sub	  bx, 1FB0h
F000:D7B1
F000:D7B1 l12:							      ;	CODE XREF: gfx_print_char+109j
F000:D7B1		  loop	  l4
F000:D7B3
F000:D7B3 l13:							      ;	CODE XREF: gfx_print_char+198j
F000:D7B3		  pop	  di
F000:D7B4		  pop	  cx
F000:D7B5		  loop	  l14
F000:D7B7		  pop	  dx
F000:D7B8		  pop	  cx
F000:D7B9		  retn
F000:D7BA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D7BA
F000:D7BA l14:							      ;	CODE XREF: gfx_print_char+113j
F000:D7BA		  jmp	  something_with_screen_width
F000:D7BD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D7BD
F000:D7BD do_video_mode_8_9:					      ;	CODE XREF: gfx_print_char+91j
F000:D7BD							      ;	gfx_print_char+9Bj
F000:D7BD							      ;	gfx_print_char:do_video_mode_aj
F000:D7BD		  mov	  cx, 8
F000:D7C0
F000:D7C0 l15:							      ;	CODE XREF: gfx_print_char:l26j
F000:D7C0		  push	  cx
F000:D7C1		  mov	  dl, es:[si]
F000:D7C4		  inc	  si
F000:D7C5		  mov	  al, dl
F000:D7C7		  push	  es
F000:D7C8		  push	  bx
F000:D7C9		  mov	  es, cs:value_b000
F000:D7CE		  mov	  di, [bp+0]
F000:D7D1		  add	  di, bx
F000:D7D3		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:D7D8		  jnz	  short	l20
F000:D7DA		  xchg	  ax, dx
F000:D7DB		  mov	  ah, al
F000:D7DD		  test	  dh, 1
F000:D7E0		  jnz	  short	l16
F000:D7E2		  mov	  al, 0
F000:D7E4
F000:D7E4 l16:							      ;	CODE XREF: gfx_print_char+13Ej
F000:D7E4		  test	  dh, 2
F000:D7E7		  jnz	  short	l17
F000:D7E9		  mov	  ah, 0
F000:D7EB
F000:D7EB l17:							      ;	CODE XREF: gfx_print_char+145j
F000:D7EB		  test	  dh, 80h
F000:D7EE		  jz	  short	l18
F000:D7F0		  xor	  es:[di], ax
F000:D7F3		  inc	  di
F000:D7F4		  inc	  di
F000:D7F5		  jmp	  short	l19
F000:D7F7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D7F7		  nop
F000:D7F8
F000:D7F8 l18:							      ;	CODE XREF: gfx_print_char+14Cj
F000:D7F8		  stosw
F000:D7F9
F000:D7F9 l19:							      ;	CODE XREF: gfx_print_char+153j
F000:D7F9		  xchg	  ax, dx
F000:D7FA		  jmp	  short	l24
F000:D7FC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D7FC		  nop
F000:D7FD
F000:D7FD l20:							      ;	CODE XREF: gfx_print_char+136j
F000:D7FD		  call	  sub_FD84E
F000:D800		  mov	  dx, bx
F000:D802		  call	  sub_FD84E
F000:D805		  mov	  cx, 2
F000:D808
F000:D808 l21:							      ;	CODE XREF: gfx_print_char+17Aj
F000:D808		  xchg	  ax, dx
F000:D809		  xchg	  ah, al
F000:D80B		  test	  dh, 80h
F000:D80E		  jz	  short	l22
F000:D810		  xor	  es:[di], ax
F000:D813		  inc	  di
F000:D814		  inc	  di
F000:D815		  jmp	  short	l23
F000:D817 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D817		  nop
F000:D818
F000:D818 l22:							      ;	CODE XREF: gfx_print_char+16Cj
F000:D818		  stosw
F000:D819
F000:D819 l23:							      ;	CODE XREF: gfx_print_char+173j
F000:D819		  xchg	  ax, dx
F000:D81A		  mov	  dx, bx
F000:D81C		  loop	  l21
F000:D81E
F000:D81E l24:							      ;	CODE XREF: gfx_print_char+158j
F000:D81E		  pop	  bx
F000:D81F		  pop	  es
F000:D820		  pop	  cx
F000:D821		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:D826		  jnz	  short	l27
F000:D828		  test	  cx, 1
F000:D82C		  jnz	  short	l25
F000:D82E		  add	  bh, 20h ; ' '
F000:D831		  jmp	  short	l26
F000:D833 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D833		  nop
F000:D834
F000:D834 l25:							      ;	CODE XREF: gfx_print_char+18Aj
F000:D834		  sub	  bx, 1FB0h
F000:D838
F000:D838 l26:							      ;	CODE XREF: gfx_print_char+18Fj
F000:D838							      ;	gfx_print_char:exitj
F000:D838		  loop	  l15
F000:D83A		  jmp	  l13
F000:D83D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D83D
F000:D83D l27:							      ;	CODE XREF: gfx_print_char+184j
F000:D83D		  cmp	  cx, 5
F000:D840		  jnz	  short	l28
F000:D842		  sub	  bx, 5F60h
F000:D846		  jmp	  short	exit
F000:D848 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D848		  nop
F000:D849
F000:D849 l28:							      ;	CODE XREF: gfx_print_char+19Ej
F000:D849		  add	  bh, 20h ; ' '
F000:D84C
F000:D84C exit:							      ;	CODE XREF: gfx_print_char+1A4j
F000:D84C		  jmp	  short	l26
F000:D84C gfx_print_char  endp
F000:D84C
F000:D84E
F000:D84E ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D84E
F000:D84E ; Entry:
F000:D84E ;    AL = ?
F000:D84E ;    AH = ?
F000:D84E ; Returns:
F000:D84E ;    BX = ?
F000:D84E
F000:D84E sub_FD84E	  proc near				      ;	CODE XREF: gfx_print_char:l20p
F000:D84E							      ;	gfx_print_char+160p
F000:D84E		  xor	  bx, bx
F000:D850		  mov	  cx, 4
F000:D853
F000:D853 l0:							      ;	CODE XREF: sub_FD84E:l1j
F000:D853		  shl	  bx, 1
F000:D855		  shl	  bx, 1
F000:D857		  shl	  bx, 1
F000:D859		  shl	  bx, 1
F000:D85B		  shl	  al, 1
F000:D85D		  jnb	  short	l1
F000:D85F		  push	  ax
F000:D860		  and	  ah, 0Fh
F000:D863		  or	  bl, ah
F000:D865		  pop	  ax
F000:D866
F000:D866 l1:							      ;	CODE XREF: sub_FD84E+Fj
F000:D866		  loop	  l0
F000:D868		  retn
F000:D868 sub_FD84E	  endp
F000:D868
F000:D869 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D869 ; START OF FUNCTION CHUNK FOR	gfx_print_char
F000:D869
F000:D869 do_video_mode_a:					      ;	CODE XREF: gfx_print_char+A5j
F000:D869		  jmp	  do_video_mode_8_9
F000:D869 ; END	OF FUNCTION CHUNK FOR gfx_print_char
F000:D86C
F000:D86C ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D86C
F000:D86C ;	   On entry:	  BH	     Active page
F000:D86C ;			  BL	     0=Use DX for Row/Column
F000:D86C ;				     1=Use current cursor Row/Column
F000:D86C ;			  DH	     Row
F000:D86C ;			  DL	     Column
F000:D86C ;	   Returns:	  ES	     Screen segment
F000:D86C ;			  BX	     Screen offset of Row/Column
F000:D86C
F000:D86C get_screen_offset proc near				      ;	CODE XREF: scroll_up_or_down+2Ep
F000:D86C							      ;	scroll_up_or_down+4Fp
F000:D86C							      ;	scroll_up_or_down+78p
F000:D86C							      ;	int_10_08_handler+11p ...
F000:D86C		  push	  ax
F000:D86D		  push	  dx
F000:D86E		  push	  di
F000:D86F		  mov	  ax, ds:p400.installed_hardware
F000:D872		  and	  al, 110000b			      ;	80x25 mono ?
F000:D874		  cmp	  al, 110000b
F000:D876		  mov	  ax, 0B000h			      ;	value for es. segment for mono
F000:D879		  jz	  short	is_mono
F000:D87B		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	mono ?
F000:D880		  jnz	  short	is_color
F000:D882
F000:D882 is_mono:						      ;	CODE XREF: get_screen_offset+Dj
F000:D882		  xor	  bh, bh			      ;	active page = 0	?
F000:D884		  mov	  es, ax			      ;	es = 0xb000
F000:D886		  jmp	  short	s0
F000:D888 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D888
F000:D888 is_color:						      ;	CODE XREF: get_screen_offset+14j
F000:D888		  add	  ah, 8				      ;	ax = 0xb800
F000:D88B		  mov	  es, ax			      ;	es = 0xb800 (segment for color)
F000:D88D		  cmp	  byte ptr ds:p400.crt_mode, 4	      ;	text modes ? (0-3)
F000:D892		  jl	  short	s0
F000:D894		  xor	  bh, bh			      ;	active page = 0
F000:D896
F000:D896 s0:							      ;	CODE XREF: get_screen_offset+1Aj
F000:D896							      ;	get_screen_offset+26j
F000:D896		  cmp	  bl, 0
F000:D899		  jz	  short	s1
F000:D89B		  mov	  bl, bh			      ;	page number
F000:D89D		  call	  get_cursor_row_col_for_page	      ;	dh/dl =	(row/column) cursor position
F000:D8A0
F000:D8A0 s1:							      ;	CODE XREF: get_screen_offset+2Dj
F000:D8A0		  xor	  di, di			      ;	di = 0
F000:D8A2		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	skip page len for mono (assuming there is only page?)
F000:D8A7		  jz	  short	s2
F000:D8A9		  push	  dx
F000:D8AA		  mov	  ax, ds:p400.crt_page_len	      ;	ax = page len
F000:D8AD		  mov	  bl, bh
F000:D8AF		  xor	  bh, bh			      ;	bx = page number
F000:D8B1		  mul	  bx				      ;	ax = page len *	page number
F000:D8B3		  add	  di, ax			      ;	di += ax (offset to the	page)
F000:D8B5		  pop	  dx
F000:D8B6
F000:D8B6 s2:							      ;	CODE XREF: get_screen_offset+3Bj
F000:D8B6		  xor	  ah, ah
F000:D8B8		  mov	  al, dh			      ;	ax = row number
F000:D8BA		  mul	  byte ptr ds:p400.crt_nr_cols	      ;	ax = row number	* nro of columns
F000:D8BE		  shl	  ax, 1				      ;	ax *= 2	(includes attribute byte)
F000:D8C0		  xor	  dh, dh
F000:D8C2		  shl	  dx, 1				      ;	dx = column * 2	(includes attribute byte)
F000:D8C4		  add	  ax, dx
F000:D8C6		  mov	  bx, ax			      ;	bx = offset for	row/column including attribute byte
F000:D8C8		  add	  bx, di			      ;	bx += page offset
F000:D8CA		  pop	  di
F000:D8CB		  pop	  dx
F000:D8CC		  pop	  ax
F000:D8CD		  retn
F000:D8CD get_screen_offset endp
F000:D8CD
F000:D8CE
F000:D8CE ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D8CE
F000:D8CE
F000:D8CE multiply_dl_dh_by_8_bis proc near			      ;	CODE XREF: scroll_graphics_up_or_down+1Ep
F000:D8CE							      ;	scroll_graphics_up_or_down:s1p
F000:D8CE							      ;	scroll_graphics_up_or_down+58p
F000:D8CE							      ;	scroll_graphics_up_or_down:s7p	...
F000:D8CE		  call	  multiply_dl_dh_by_8
F000:D8CE multiply_dl_dh_by_8_bis endp
F000:D8CE
F000:D8D1
F000:D8D1 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D8D1
F000:D8D1 ;	Entry:
F000:D8D1 ;	    cx = pixel horizontal position
F000:D8D1 ;	    dx = pixel vertical	position
F000:D8D1 ;
F000:D8D1 ;	Returns:
F000:D8D1 ;	    bx = address for pixel
F000:D8D1 ;	    cx = horizontal byte offset
F000:D8D1 ;	    dx = horizontal bit	offset
F000:D8D1
F000:D8D1 get_address_for_pixel	proc near			      ;	CODE XREF: gfx_print_char:print_char_at_offsetp
F000:D8D1							      ;	get_pixel_addr_and_mask:s0p
F000:D8D1							      ;	get_pixel_addr_and_mask+50p
F000:D8D1		  push	  ax
F000:D8D2		  push	  cx
F000:D8D3		  push	  dx
F000:D8D4		  cmp	  byte ptr ds:p400.crt_mode, 8	      ;	160x200	16 colors
F000:D8D9		  jnz	  short	test_video_modes_4_5_6_9_a
F000:D8DB		  jmp	  short	do_video_mode_8
F000:D8DD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D8DD		  nop
F000:D8DE
F000:D8DE test_video_modes_4_5_6_9_a:				      ;	CODE XREF: get_address_for_pixel+8j
F000:D8DE		  cmp	  byte ptr ds:p400.crt_mode, 9	      ;	320x200	16 colors
F000:D8E3		  jnz	  short	test_video_modes_4_5_6_a
F000:D8E5		  jmp	  do_video_mode_9
F000:D8E8 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D8E8
F000:D8E8 test_video_modes_4_5_6_a:				      ;	CODE XREF: get_address_for_pixel+12j
F000:D8E8		  cmp	  byte ptr ds:p400.crt_mode, 0Ah      ;	640x200	4 colors
F000:D8ED		  jnz	  short	do_video_mode_4_5_6
F000:D8EF		  jmp	  do_video_mode_a
F000:D8F2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D8F2
F000:D8F2 do_video_mode_4_5_6:					      ;	CODE XREF: get_address_for_pixel+1Cj
F000:D8F2		  mov	  ax, 40
F000:D8F5		  and	  dx, 1111111111111110b		      ;	calculate for even value
F000:D8F9		  mul	  dx				      ;	ax:dx =	vertical pos * 40 (40 bytes per	row)
F000:D8FB		  shr	  cx, 1
F000:D8FD		  shr	  cx, 1				      ;	cx = horizotal pixel / 4
F000:D8FF		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D904		  jnz	  short	s0
F000:D906		  shr	  cx, 1				      ;	cx = horizontal	pixel /	8 (only	for 640x200)
F000:D908
F000:D908 s0:							      ;	CODE XREF: get_address_for_pixel+33j
F000:D908		  add	  ax, cx			      ;	ax = y * 40 + x	/ bits_per_byte
F000:D90A		  add	  ah, 80h ; '€'                       ; modes 4,5,6 uses b000:8000 first byte
F000:D90D		  pop	  bx				      ;	orignal	vertical pos in	pixels
F000:D90E		  test	  bx, 1
F000:D912		  jz	  short	s1
F000:D914		  add	  ah, 20h ; ' '                       ; if odd, add 0x2000 (second band for CGA graphics)
F000:D917
F000:D917 s1:							      ;	CODE XREF: get_address_for_pixel+41j
F000:D917		  mov	  bx, ax			      ;	bx = final value
F000:D919		  pop	  ax				      ;	original horizontal pos	in pixels
F000:D91A		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:D91F		  jnz	  short	epilog_modes_4_5
F000:D921		  mov	  cx, 8				      ;	mode 6 only
F000:D924		  div	  cx				      ;	ax = byte offset
F000:D926		  mov	  cl, 7
F000:D928		  sub	  cl, dl			      ;	cx = bit offset
F000:D92A		  jmp	  short	exit
F000:D92C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D92C
F000:D92C epilog_modes_4_5:					      ;	CODE XREF: get_address_for_pixel+4Ej
F000:D92C		  mov	  cx, 4
F000:D92F		  div	  cx				      ;	ax = dx:ax / cx,  dx = dx:ax % cx
F000:D931		  shl	  dx, 1				      ;	dx *= 2
F000:D933		  mov	  cl, 6
F000:D935		  sub	  cl, dl
F000:D937
F000:D937 exit:							      ;	CODE XREF: get_address_for_pixel+59j
F000:D937							      ;	get_address_for_pixel:loc_FD965j
F000:D937							      ;	get_address_for_pixel:loc_FD9A8j
F000:D937							      ;	get_address_for_pixel+11Bj
F000:D937		  pop	  ax
F000:D938		  retn
F000:D939 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D939
F000:D939 do_video_mode_8:					      ;	CODE XREF: get_address_for_pixel+Aj
F000:D939		  mov	  ax, 40
F000:D93C		  and	  dx, 1111111111111110b
F000:D940		  mul	  dx
F000:D942		  shr	  cx, 1
F000:D944		  add	  ax, cx
F000:D946		  add	  ah, 80h ; '€'
F000:D949		  pop	  bx				      ;	vertical pos
F000:D94A		  test	  bx, 1
F000:D94E		  jz	  short	loc_FD953
F000:D950		  add	  ah, 20h ; ' '
F000:D953
F000:D953 loc_FD953:						      ;	CODE XREF: get_address_for_pixel+7Dj
F000:D953		  mov	  bx, ax
F000:D955		  pop	  ax				      ;	horizontal pos
F000:D956		  mov	  cx, 2
F000:D959		  div	  cx
F000:D95B		  mov	  cx, 4
F000:D95E		  and	  dl, dl
F000:D960		  jz	  short	loc_FD965
F000:D962		  mov	  cx, 0
F000:D965
F000:D965 loc_FD965:						      ;	CODE XREF: get_address_for_pixel+8Fj
F000:D965		  jmp	  short	exit
F000:D967 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D967
F000:D967 do_video_mode_9:					      ;	CODE XREF: get_address_for_pixel+14j
F000:D967		  mov	  ax, 80			      ;	ax = cols(80) *	(y&1)
F000:D96A		  and	  dx, 0FFFCh
F000:D96E		  shr	  dx, 1
F000:D970		  mul	  dx
F000:D972		  shr	  cx, 1				      ;	x = x /	2 (i guess because 2 bits per color)
F000:D974		  add	  ax, cx			      ;	ax += x
F000:D976		  add	  ah, 128			      ;	ax += 128 (why)
F000:D979		  pop	  bx				      ;	vertical position
F000:D97A		  and	  bx, 3				      ;	which band: 0, 1, 2 or 3 ?
F000:D97E		  cmp	  bx, 3
F000:D981		  jb	  short	loc_FD986
F000:D983		  add	  ah, 20h ; ' '                       ; ax += 0x2000
F000:D986
F000:D986 loc_FD986:						      ;	CODE XREF: get_address_for_pixel+B0j
F000:D986		  cmp	  bx, 2
F000:D989		  jb	  short	loc_FD98E
F000:D98B		  add	  ah, 20h ; ' '                       ; ax += 0x2000
F000:D98E
F000:D98E loc_FD98E:						      ;	CODE XREF: get_address_for_pixel+B8j
F000:D98E		  cmp	  bx, 1
F000:D991		  jb	  short	loc_FD996
F000:D993		  add	  ah, 20h ; ' '                       ; ax += 0x2000
F000:D996
F000:D996 loc_FD996:						      ;	CODE XREF: get_address_for_pixel+C0j
F000:D996		  mov	  bx, ax
F000:D998		  pop	  ax
F000:D999		  mov	  cx, 2
F000:D99C		  div	  cx
F000:D99E		  mov	  cx, 4
F000:D9A1		  and	  dl, dl
F000:D9A3		  jz	  short	loc_FD9A8
F000:D9A5		  mov	  cx, 0
F000:D9A8
F000:D9A8 loc_FD9A8:						      ;	CODE XREF: get_address_for_pixel+D2j
F000:D9A8		  jmp	  short	exit
F000:D9AA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:D9AA
F000:D9AA do_video_mode_a:					      ;	CODE XREF: get_address_for_pixel+1Ej
F000:D9AA		  mov	  ax, 80
F000:D9AD		  and	  dx, 1111111111111100b
F000:D9B1		  shr	  dx, 1
F000:D9B3		  mul	  dx
F000:D9B5		  shr	  cx, 1
F000:D9B7		  shr	  cx, 1
F000:D9B9		  and	  cx, 1111111111111110b
F000:D9BD		  add	  ax, cx
F000:D9BF		  add	  ah, 80h ; '€'
F000:D9C2		  pop	  bx
F000:D9C3		  and	  bx, 3
F000:D9C7		  cmp	  bx, 3
F000:D9CA		  jb	  short	loc_FD9CF
F000:D9CC		  add	  ah, 20h ; ' '
F000:D9CF
F000:D9CF loc_FD9CF:						      ;	CODE XREF: get_address_for_pixel+F9j
F000:D9CF		  cmp	  bx, 2
F000:D9D2		  jb	  short	loc_FD9D7
F000:D9D4		  add	  ah, 20h ; ' '
F000:D9D7
F000:D9D7 loc_FD9D7:						      ;	CODE XREF: get_address_for_pixel+101j
F000:D9D7		  cmp	  bx, 1
F000:D9DA		  jb	  short	loc_FD9DF
F000:D9DC		  add	  ah, 20h ; ' '
F000:D9DF
F000:D9DF loc_FD9DF:						      ;	CODE XREF: get_address_for_pixel+109j
F000:D9DF		  mov	  bx, ax
F000:D9E1		  pop	  ax
F000:D9E2		  mov	  cx, 8
F000:D9E5		  div	  cx
F000:D9E7		  mov	  cx, 7
F000:D9EA		  sub	  cx, dx
F000:D9EC		  jmp	  exit
F000:D9EC get_address_for_pixel	endp
F000:D9EC
F000:D9EF
F000:D9EF ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:D9EF
F000:D9EF ; return
F000:D9EF ;    cx = dl * 8
F000:D9EF ;    dx = dh * 8
F000:D9EF
F000:D9EF multiply_dl_dh_by_8 proc near				      ;	CODE XREF: gfx_print_char+2p
F000:D9EF							      ;	multiply_dl_dh_by_8_bisp
F000:D9EF		  xor	  ch, ch			      ;	cx = 0
F000:D9F1		  mov	  cl, dl
F000:D9F3		  shl	  cx, 1
F000:D9F5		  shl	  cx, 1
F000:D9F7		  shl	  cx, 1				      ;	cx = dl	* 8
F000:D9F9		  mov	  dl, dh
F000:D9FB		  xor	  dh, dh			      ;	dh = 0
F000:D9FD		  shl	  dx, 1
F000:D9FF		  shl	  dx, 1
F000:DA01		  shl	  dx, 1				      ;	dx = dh	* 8
F000:DA03		  retn
F000:DA03 multiply_dl_dh_by_8 endp
F000:DA03
F000:DA04
F000:DA04 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA04
F000:DA04 ; entry:
F000:DA04 ;   bl = page	to query
F000:DA04 ; returns:
F000:DA04 ;   dx = cursor position (row/column)
F000:DA04
F000:DA04 get_cursor_row_col_for_page proc near			      ;	CODE XREF: get_screen_offset+31p
F000:DA04							      ;	int_10_03_handler+Bp
F000:DA04							      ;	int_10_05_handler+2Ep
F000:DA04							      ;	int_10_08_handler+7p ...
F000:DA04		  push	  bx
F000:DA05		  xor	  bh, bh
F000:DA07		  shl	  bx, 1				      ;	bl = page
F000:DA09		  mov	  dx, [bx+p400.cursor_row_col_in_pages]
F000:DA0D		  pop	  bx
F000:DA0E		  retn
F000:DA0E get_cursor_row_col_for_page endp
F000:DA0E
F000:DA0F
F000:DA0F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA0F
F000:DA0F ;	Add/Sub	number of bytes	per row	to SI and DI
F000:DA0F ;
F000:DA0F ;	   On entry:	  [BP+4] (arg 0)  0=Add. 1=Sub
F000:DA0F ;
F000:DA0F ;	   Returns:	  DI	     +/- Bytes per row
F000:DA0F ;			  SI	     +/- Bytes per row
F000:DA0F ; Attributes:	bp-based frame
F000:DA0F
F000:DA0F add_or_sub_bytes_per_row proc	near			      ;	CODE XREF: scroll_up_or_down+A2p
F000:DA0F							      ;	scroll_up_or_down+A9p
F000:DA0F							      ;	scroll_up_or_down+C0p
F000:DA0F
F000:DA0F arg_add_sub	  = word ptr  4
F000:DA0F
F000:DA0F		  push	  dx
F000:DA10		  mov	  dx, ds:p400.crt_nr_cols	      ;	columns	on screen
F000:DA14		  shl	  dx, 1				      ;	columns	* 2 (includes attribute	byte)
F000:DA16		  cmp	  [bp+arg_add_sub], 0
F000:DA1A		  jnz	  short	do_sub
F000:DA1C
F000:DA1C do_add:
F000:DA1C		  add	  si, dx
F000:DA1E		  add	  di, dx
F000:DA20		  jmp	  short	exit
F000:DA22 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DA22		  nop
F000:DA23
F000:DA23 do_sub:						      ;	CODE XREF: add_or_sub_bytes_per_row+Bj
F000:DA23		  sub	  si, dx
F000:DA25		  sub	  di, dx
F000:DA27
F000:DA27 exit:							      ;	CODE XREF: add_or_sub_bytes_per_row+11j
F000:DA27		  pop	  dx
F000:DA28		  retn
F000:DA28 add_or_sub_bytes_per_row endp
F000:DA28
F000:DA29
F000:DA29 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA29
F000:DA29
F000:DA29 add_or_sub_320  proc near				      ;	CODE XREF: scroll_graphics_up_or_down+129p
F000:DA29							      ;	scroll_graphics_up_or_down+131p
F000:DA29							      ;	scroll_graphics_up_or_down+1ACp
F000:DA29		  push	  ax
F000:DA2A		  mov	  ax, 320
F000:DA2D		  cmp	  word ptr [bp+4], 0		      ;	direction: 0=scroll up,	1=scroll down
F000:DA31		  jz	  short	s0
F000:DA33		  neg	  ax
F000:DA35
F000:DA35 s0:							      ;	CODE XREF: add_or_sub_320+8j
F000:DA35		  add	  si, ax
F000:DA37		  add	  di, ax
F000:DA39		  pop	  ax
F000:DA3A		  retn
F000:DA3A add_or_sub_320  endp
F000:DA3A
F000:DA3B
F000:DA3B ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA3B
F000:DA3B
F000:DA3B disable_video_in_80x25_mode proc near			      ;	CODE XREF: scroll_up_or_down+84p
F000:DA3B		  push	  ax
F000:DA3C		  push	  dx
F000:DA3D		  call	  is_80x25_text_mode
F000:DA40		  jnb	  short	exit
F000:DA42		  mov	  dx, 3DAh
F000:DA45		  cli
F000:DA46
F000:DA46 wait_retrace:						      ;	CODE XREF: disable_video_in_80x25_mode+Ej
F000:DA46		  in	  al, dx			      ;	Video status bits:
F000:DA46							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:DA46							      ;	1: 1=light pen is triggered; 0=armed
F000:DA46							      ;	2: 1=light pen switch is open; 0=closed
F000:DA46							      ;	3: 1=vertical sync pulse is occurring.
F000:DA47		  test	  al, 8
F000:DA49		  jz	  short	wait_retrace
F000:DA4B		  sti
F000:DA4C		  mov	  dx, 3D8h
F000:DA4F		  mov	  al, ds:p400.crt_mode_set
F000:DA52		  and	  al, 110111b			      ;	disable	video
F000:DA54		  out	  dx, al
F000:DA55
F000:DA55 exit:							      ;	CODE XREF: disable_video_in_80x25_mode+5j
F000:DA55		  pop	  dx
F000:DA56		  pop	  ax
F000:DA57		  retn
F000:DA57 disable_video_in_80x25_mode endp
F000:DA57
F000:DA58
F000:DA58 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA58
F000:DA58
F000:DA58 enable_video_in_80x25_mode proc near			      ;	CODE XREF: scroll_up_or_down+CEp
F000:DA58		  call	  is_80x25_text_mode
F000:DA5B		  jnb	  short	exit
F000:DA5D		  mov	  dx, 3D8h
F000:DA60		  mov	  al, ds:p400.crt_mode_set
F000:DA63		  out	  dx, al
F000:DA64
F000:DA64 exit:							      ;	CODE XREF: enable_video_in_80x25_mode+3j
F000:DA64		  retn
F000:DA64 enable_video_in_80x25_mode endp
F000:DA64
F000:DA65
F000:DA65 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA65
F000:DA65
F000:DA65 play_bell_sound proc near				      ;	CODE XREF: POST_init_ints_and_more:l9p
F000:DA65							      ;	int_09_handler+25p
F000:DA65							      ;	put_char_in_keyb_buffer+1Ep
F000:DA65							      ;	int_10_0e_handler+Dp
F000:DA65		  push	  ax
F000:DA66		  push	  cx
F000:DA67		  mov	  al, 10110110b
F000:DA69		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:DA6B		  mov	  ax, 700h
F000:DA6E		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:DA70		  mov	  al, ah
F000:DA72		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:DA74		  in	  al, 61h			      ;	PC/XT PPI port B bits:
F000:DA74							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:DA74							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:DA74							      ;	3: 1=read high switches
F000:DA74							      ;	4: 0=enable RAM	parity checking
F000:DA74							      ;	5: 0=enable I/O	channel	check
F000:DA74							      ;	6: 0=hold keyboard clock low
F000:DA74							      ;	7: 0=enable kbrd
F000:DA76		  mov	  ah, al
F000:DA78		  or	  al, 3
F000:DA7A		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:DA7A							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:DA7A							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:DA7A							      ;	3: 1=read high switches
F000:DA7A							      ;	4: 0=enable RAM	parity checking
F000:DA7A							      ;	5: 0=enable I/O	channel	check
F000:DA7A							      ;	6: 0=hold keyboard clock low
F000:DA7A							      ;	7: 0=enable kbrd
F000:DA7C		  mov	  cx, 4000h
F000:DA7F
F000:DA7F delay0:						      ;	CODE XREF: play_bell_sound:delay0j
F000:DA7F		  loop	  delay0			      ;	delay
F000:DA81		  mov	  al, ah
F000:DA83		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:DA83							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:DA83							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:DA83							      ;	3: 1=read high switches
F000:DA83							      ;	4: 0=enable RAM	parity checking
F000:DA83							      ;	5: 0=enable I/O	channel	check
F000:DA83							      ;	6: 0=hold keyboard clock low
F000:DA83							      ;	7: 0=enable kbrd
F000:DA85		  pop	  cx
F000:DA86		  pop	  ax
F000:DA87		  retn
F000:DA87 play_bell_sound endp
F000:DA87
F000:DA88
F000:DA88 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA88
F000:DA88 ;	Returns:
F000:DA88 ;	    Carry: Set = Graphics mode
F000:DA88 ;		   Clear = Text	mode
F000:DA88
F000:DA88 is_80x25_text_mode proc near				      ;	CODE XREF: disable_video_in_80x25_mode+2p
F000:DA88							      ;	enable_video_in_80x25_modep
F000:DA88							      ;	int_10_08_handler+1Bp
F000:DA88							      ;	int_10_0a_handler+30p ...
F000:DA88		  cmp	  byte ptr ds:p400.crt_mode, 2
F000:DA8D		  jl	  short	is_not_80x25
F000:DA8F		  cmp	  byte ptr ds:p400.crt_mode, 3
F000:DA94		  jg	  short	is_not_80x25
F000:DA96		  stc
F000:DA97		  retn
F000:DA98 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DA98
F000:DA98 is_not_80x25:						      ;	CODE XREF: is_80x25_text_mode+5j
F000:DA98							      ;	is_80x25_text_mode+Cj
F000:DA98		  clc
F000:DA99		  retn
F000:DA99 is_80x25_text_mode endp
F000:DA99
F000:DA9A
F000:DA9A ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DA9A
F000:DA9A
F000:DA9A int_1a_main	  proc far				      ;	CODE XREF: F000:int_1a_handlerj
F000:DA9A		  push	  ds
F000:DA9B		  mov	  ds, cs:value_0040		      ;	ds = 040h
F000:DAA0		  or	  ah, ah
F000:DAA2		  jz	  short	int_1a_00_handler
F000:DAA4		  dec	  ah
F000:DAA6		  jz	  short	int_1a_01_handler
F000:DAA8		  jmp	  short	exit
F000:DAAA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DAAA
F000:DAAA int_1a_00_handler:					      ;	CODE XREF: int_1a_main+8j
F000:DAAA		  mov	  dx, ds:p400.timer_ticks_since_midnight
F000:DAAE		  mov	  cx, ds:p400.timer_ticks_since_midnight+2
F000:DAB2		  mov	  al, ds:p400.timer_overflow
F000:DAB5		  mov	  byte ptr ds:p400.timer_overflow, 0
F000:DABA		  jmp	  short	exit
F000:DABC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DABC
F000:DABC int_1a_01_handler:					      ;	CODE XREF: int_1a_main+Cj
F000:DABC		  mov	  byte ptr ds:p400.timer_overflow, 0
F000:DAC1		  mov	  ds:p400.timer_ticks_since_midnight, dx
F000:DAC5		  mov	  ds:p400.timer_ticks_since_midnight+2,	cx
F000:DAC9		  xor	  ah, ah
F000:DACB
F000:DACB exit:							      ;	CODE XREF: int_1a_main+Ej
F000:DACB							      ;	int_1a_main+20j
F000:DACB		  pop	  ds
F000:DACC		  iret
F000:DACC int_1a_main	  endp
F000:DACC
F000:DACD
F000:DACD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DACD
F000:DACD ;	This interrupt is a hardware interrupt (IRQ 0) activated by the	system
F000:DACD ;	timer 18.2 times per second (every 55 ms). The default handler does
F000:DACD ;	the following:
F000:DACD ;
F000:DACD ;	     .	 Keeps a count of the number of	timer ticks at memory location
F000:DACD ;		 0:46Ch	(System	Timer Counter--long integer). After 24 hours of
F000:DACD ;		 operation, a flag is set at memory location 0:470h to signal
F000:DACD ;		 this condition	and the	System Timer Counter (0:46Ch) is reset to
F000:DACD ;		 0.
F000:DACD ;
F000:DACD ;	     .	 Decrements the	Diskette Drive Motor Off Counter at memory
F000:DACD ;		 location 0:440h if it is not 0. When this location reaches 0,
F000:DACD ;		 the diskette drive motor is turned off	and the	Diskette Drive
F000:DACD ;		 Motor Status byte at memory location 0:43Fh is	updated	to
F000:DACD ;		 reflect that the motor	has been turned	off.
F000:DACD ;
F000:DACD ;	     .	 Generates INT 1Ch.
F000:DACD ;
F000:DACD ;	     .	 For the PC Convertible, generates INT 4Ah if an alarm interrupt
F000:DACD ;		 occurs.
F000:DACD ;
F000:DACD
F000:DACD int_08_main	  proc far				      ;	CODE XREF: F000:int_08_handlerj
F000:DACD		  push	  ax
F000:DACE		  push	  dx
F000:DACF		  push	  ds
F000:DAD0		  xor	  dx, dx
F000:DAD2		  mov	  ds, cs:value_0040		      ;	ds = 40h
F000:DAD7		  inc	  word ptr ds:p400.timer_ticks_since_midnight
F000:DADB		  jnz	  short	l0
F000:DADD		  inc	  word ptr ds:p400.timer_ticks_since_midnight+2
F000:DAE1
F000:DAE1 l0:							      ;	CODE XREF: int_08_main+Ej
F000:DAE1		  cmp	  word ptr ds:p400.timer_ticks_since_midnight, 0B0h ; '°'
F000:DAE7		  jnz	  short	l1
F000:DAE9		  cmp	  word ptr ds:p400.timer_ticks_since_midnight+2, 18h
F000:DAEE		  jnz	  short	l1
F000:DAF0		  inc	  byte ptr ds:p400.timer_overflow
F000:DAF4		  mov	  ds:p400.timer_ticks_since_midnight, dx
F000:DAF8		  mov	  ds:p400.timer_ticks_since_midnight+2,	dx
F000:DAFC
F000:DAFC l1:							      ;	CODE XREF: int_08_main+1Aj
F000:DAFC							      ;	int_08_main+21j
F000:DAFC		  dec	  byte ptr ds:p400.diskette_motor_off_timeout
F000:DB00		  jnz	  short	l2
F000:DB02		  mov	  dx, 3F2h			      ;	turn off diskette motor
F000:DB05		  mov	  al, 1111b
F000:DB07		  out	  dx, al			      ;	Floppy:	digital	output reg bits:
F000:DB07							      ;	0-1: Drive to select 0-3 (AT: bit 1 not	used)
F000:DB07							      ;	2:   0=reset diskette controller; 1=enable controller
F000:DB07							      ;	3:   1=enable diskette DMA and interrupts
F000:DB07							      ;	4-7: drive motor enable.  Set bits to turn drive ON.
F000:DB07							      ;
F000:DB08		  and	  byte ptr ds:p400.diskette_motor_status, 0F0h
F000:DB0D
F000:DB0D l2:							      ;	CODE XREF: int_08_main+33j
F000:DB0D		  int	  1Ch				      ;	CLOCK TICK
F000:DB0F		  mov	  al, 20h ; ' '
F000:DB11		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:DB13		  pop	  ds
F000:DB14		  pop	  dx
F000:DB15		  pop	  ax
F000:DB16		  iret
F000:DB16 int_08_main	  endp
F000:DB16
F000:DB16 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DB17 value_0040_00b0 dd 4000B0h				      ;	DATA XREF: perhaps_obsolete_function+Ar
F000:DB1B
F000:DB1B ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DB1B
F000:DB1B ; It seems that nobody is calling this function.
F000:DB1B ; And	also, this function treats the 0040:00b0 as a table.
F000:DB1B ; While in the Keyboard handler (0xEAF3), it is being	treated	as a jump address.
F000:DB1B ; Perhaps this code is deprecated and	someone	forgot to delete it ?
F000:DB1B ; Attributes:	bp-based frame
F000:DB1B
F000:DB1B perhaps_obsolete_function proc far
F000:DB1B		  push	  ax
F000:DB1C		  push	  cx
F000:DB1D		  push	  bp
F000:DB1E		  mov	  bp, sp
F000:DB20		  push	  bx
F000:DB21		  push	  dx
F000:DB22		  push	  di
F000:DB23		  push	  ds
F000:DB24		  push	  es
F000:DB25		  lds	  di, cs:value_0040_00b0	      ;	address	0040:00b0 == 04b0
F000:DB2A		  lds	  di, [di]			      ;	load ds:di with	intl_support address
F000:DB2C		  push	  ds
F000:DB2D		  pop	  es
F000:DB2E		  mov	  al, ds:25h
F000:DB31		  mov	  ah, al
F000:DB33		  mov	  dx, cx
F000:DB35		  test	  ch, 8
F000:DB38		  jnz	  short	l4
F000:DB3A		  cmp	  byte ptr ds:24h, 0FFh
F000:DB3F		  jnz	  short	l4
F000:DB41		  mov	  di, 0
F000:DB44		  cmp	  ah, 3Bh ; ';'
F000:DB47		  jz	  short	l0
F000:DB49		  mov	  di, 0FFh
F000:DB4C		  cmp	  ah, 3Ch ; '<'
F000:DB4F		  jz	  short	l0
F000:DB51		  mov	  di, 0FFFFh
F000:DB54		  cmp	  ah, 3Dh ; '='
F000:DB57		  jnz	  short	l2
F000:DB59
F000:DB59 l0:							      ;	CODE XREF: perhaps_obsolete_function+2Cj
F000:DB59							      ;	perhaps_obsolete_function+34j
F000:DB59		  mov	  ds:2,	di
F000:DB5D
F000:DB5D l1:							      ;	CODE XREF: perhaps_obsolete_function+52j
F000:DB5D		  jmp	  l14
F000:DB60 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DB60
F000:DB60 l2:							      ;	CODE XREF: perhaps_obsolete_function+3Cj
F000:DB60		  cmp	  byte ptr ds:2, 0FFh
F000:DB65		  jnz	  short	l3
F000:DB67		  mov	  di, 8
F000:DB6A		  call	  sub_FDC20
F000:DB6D		  jb	  short	l1
F000:DB6F		  jmp	  short	l8
F000:DB71 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DB71
F000:DB71 l3:							      ;	CODE XREF: perhaps_obsolete_function+4Aj
F000:DB71							      ;	perhaps_obsolete_function+5Ej
F000:DB71		  jmp	  l16
F000:DB74 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DB74
F000:DB74 l4:							      ;	CODE XREF: perhaps_obsolete_function+1Dj
F000:DB74							      ;	perhaps_obsolete_function+24j
F000:DB74		  cmp	  byte ptr ds:2, 0FFh
F000:DB79		  jnz	  short	l3
F000:DB7B		  mov	  di, 0Ch
F000:DB7E		  test	  dh, 8
F000:DB81		  jnz	  short	l6
F000:DB83		  mov	  di, 10h
F000:DB86		  test	  dh, 4
F000:DB89		  jnz	  short	l6
F000:DB8B		  mov	  di, 14h
F000:DB8E		  mov	  bx, 18h
F000:DB91		  test	  dh, 40h
F000:DB94		  jz	  short	l5
F000:DB96		  push	  ax
F000:DB97		  push	  di
F000:DB98		  mov	  di, 1Ch
F000:DB9B		  call	  sub_FDC20
F000:DB9E		  pop	  di
F000:DB9F		  pop	  ax
F000:DBA0		  jb	  short	l5
F000:DBA2		  xchg	  di, bx
F000:DBA4
F000:DBA4 l5:							      ;	CODE XREF: perhaps_obsolete_function+79j
F000:DBA4							      ;	perhaps_obsolete_function+85j
F000:DBA4		  test	  dh, 3
F000:DBA7		  jnz	  short	l6
F000:DBA9		  xchg	  di, bx
F000:DBAB
F000:DBAB l6:							      ;	CODE XREF: perhaps_obsolete_function+66j
F000:DBAB							      ;	perhaps_obsolete_function+6Ej
F000:DBAB							      ;	perhaps_obsolete_function+8Cj
F000:DBAB		  call	  sub_FDC20
F000:DBAE		  jb	  short	l8
F000:DBB0		  cmp	  al, 0FFh
F000:DBB2		  jz	  short	l14
F000:DBB4		  test	  dh, 8
F000:DBB7		  jnz	  short	l7
F000:DBB9		  test	  dh, 4
F000:DBBC		  jz	  short	l8
F000:DBBE		  cmp	  al, 80h ; '€'
F000:DBC0		  jb	  short	l8
F000:DBC2
F000:DBC2 l7:							      ;	CODE XREF: perhaps_obsolete_function+9Cj
F000:DBC2		  mov	  ah, al
F000:DBC4		  xor	  al, al
F000:DBC6
F000:DBC6 l8:							      ;	CODE XREF: perhaps_obsolete_function+54j
F000:DBC6							      ;	perhaps_obsolete_function+93j
F000:DBC6							      ;	perhaps_obsolete_function+A1j
F000:DBC6							      ;	perhaps_obsolete_function+A5j
F000:DBC6		  mov	  cx, ds:20h
F000:DBCA		  jcxz	  short	l12
F000:DBCC		  mov	  di, ds:22h
F000:DBD0		  cld
F000:DBD1
F000:DBD1 l9:							      ;	CODE XREF: perhaps_obsolete_function+BCj
F000:DBD1		  scasw
F000:DBD2		  jz	  short	l13
F000:DBD4		  add	  di, 4
F000:DBD7		  loop	  l9
F000:DBD9		  cmp	  word ptr ds:4, 0
F000:DBDE		  jz	  short	l12
F000:DBE0		  cmp	  al, 20h ; ' '
F000:DBE2		  jnz	  short	l10
F000:DBE4		  mov	  ax, ds:4
F000:DBE7		  jmp	  short	l11
F000:DBE9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DBE9
F000:DBE9 l10:							      ;	CODE XREF: perhaps_obsolete_function+C7j
F000:DBE9		  mov	  [bp+4], ax
F000:DBEC		  mov	  di, ds:6
F000:DBF0		  call	  sub_FDC20
F000:DBF3		  jb	  short	l11
F000:DBF5		  sub	  ah, ah
F000:DBF7
F000:DBF7 l11:							      ;	CODE XREF: perhaps_obsolete_function+CCj
F000:DBF7							      ;	perhaps_obsolete_function+D8j
F000:DBF7		  mov	  word ptr ds:4, 0
F000:DBFD
F000:DBFD l12:							      ;	CODE XREF: perhaps_obsolete_function+AFj
F000:DBFD							      ;	perhaps_obsolete_function+C3j
F000:DBFD		  cmp	  byte ptr ds:3, 0FFh
F000:DC02		  jnz	  short	l15
F000:DC04		  call	  convert_something_2
F000:DC07		  jmp	  short	l15
F000:DC09 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC09
F000:DC09 l13:							      ;	CODE XREF: perhaps_obsolete_function+B7j
F000:DC09		  mov	  ds:4,	ax
F000:DC0C		  mov	  ds:6,	di
F000:DC10
F000:DC10 l14:							      ;	CODE XREF: perhaps_obsolete_function:l1j
F000:DC10							      ;	perhaps_obsolete_function+97j
F000:DC10		  stc
F000:DC11		  jmp	  short	l17
F000:DC13 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC13
F000:DC13 l15:							      ;	CODE XREF: perhaps_obsolete_function+E7j
F000:DC13							      ;	perhaps_obsolete_function+ECj
F000:DC13		  mov	  [bp+4], ax
F000:DC16
F000:DC16 l16:							      ;	CODE XREF: perhaps_obsolete_function:l3j
F000:DC16		  clc
F000:DC17
F000:DC17 l17:							      ;	CODE XREF: perhaps_obsolete_function+F6j
F000:DC17		  pop	  es
F000:DC18		  pop	  ds
F000:DC19		  pop	  di
F000:DC1A		  pop	  dx
F000:DC1B		  pop	  bx
F000:DC1C		  pop	  bp
F000:DC1D		  pop	  cx
F000:DC1E		  pop	  ax
F000:DC1F		  retf
F000:DC1F perhaps_obsolete_function endp
F000:DC1F
F000:DC20
F000:DC20 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DC20
F000:DC20
F000:DC20 sub_FDC20	  proc near				      ;	CODE XREF: perhaps_obsolete_function+4Fp
F000:DC20							      ;	perhaps_obsolete_function+80p
F000:DC20							      ;	perhaps_obsolete_function:l6p
F000:DC20							      ;	perhaps_obsolete_function+D5p
F000:DC20		  mov	  cx, [di]
F000:DC22		  jcxz	  short	error
F000:DC24		  push	  cx
F000:DC25		  mov	  di, [di+2]
F000:DC28		  cld
F000:DC29		  repne	scasb
F000:DC2B		  pop	  cx
F000:DC2C		  jnz	  short	error
F000:DC2E		  add	  di, cx
F000:DC30		  dec	  di
F000:DC31		  mov	  al, [di]
F000:DC33		  clc
F000:DC34		  jmp	  short	exit
F000:DC36 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC36
F000:DC36 error:						      ;	CODE XREF: sub_FDC20+2j
F000:DC36							      ;	sub_FDC20+Cj
F000:DC36		  mov	  ax, [bp+4]
F000:DC39		  stc
F000:DC3A
F000:DC3A exit:							      ;	CODE XREF: sub_FDC20+14j
F000:DC3A		  retn
F000:DC3A sub_FDC20	  endp
F000:DC3A
F000:DC3B
F000:DC3B ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DC3B
F000:DC3B
F000:DC3B convert_something_2 proc near				      ;	CODE XREF: perhaps_obsolete_function+E9p
F000:DC3B		  cmp	  ah, 0
F000:DC3E		  jz	  short	exit
F000:DC40		  cmp	  al, 0
F000:DC42		  jz	  short	exit
F000:DC44		  jl	  short	l3
F000:DC46		  push	  cs
F000:DC47		  pop	  ds
F000:DC48		  push	  cs
F000:DC49		  pop	  es
F000:DC4A		  cmp	  ah, 47h ; 'G'
F000:DC4D		  jl	  short	l4
F000:DC4F		  cmp	  ah, 57h ; 'W'
F000:DC52		  jg	  short	l4
F000:DC54		  mov	  cx, 9
F000:DC57		  nop
F000:DC58		  lea	  di, some_kind_of_table
F000:DC5C		  cld
F000:DC5D
F000:DC5D l0:							      ;	CODE XREF: convert_something_2+26j
F000:DC5D		  scasb
F000:DC5E		  jz	  short	l1
F000:DC60		  inc	  di
F000:DC61		  loop	  l0
F000:DC63		  jmp	  short	l2
F000:DC65 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC65
F000:DC65 l1:							      ;	CODE XREF: convert_something_2+23j
F000:DC65		  mov	  ah, [di]
F000:DC67
F000:DC67 l2:							      ;	CODE XREF: convert_something_2+28j
F000:DC67		  jmp	  short	exit
F000:DC69 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC69
F000:DC69 l3:							      ;	CODE XREF: convert_something_2+9j
F000:DC69		  xor	  ah, ah
F000:DC6B		  jmp	  short	exit
F000:DC6D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC6D
F000:DC6D l4:							      ;	CODE XREF: convert_something_2+12j
F000:DC6D							      ;	convert_something_2+17j
F000:DC6D		  cmp	  ah, 1
F000:DC70		  jz	  short	exit
F000:DC72		  cmp	  ah, 0Eh
F000:DC75		  jz	  short	exit
F000:DC77		  cmp	  ah, 0Fh
F000:DC7A		  jz	  short	exit
F000:DC7C		  cmp	  ah, 1Ch
F000:DC7F		  jz	  short	exit
F000:DC81		  lea	  bx, sort_of_abc_to_scancode_tbl
F000:DC85		  mov	  ah, al
F000:DC87		  xlat					      ;	al = [ds:bx + al]
F000:DC88		  xchg	  ah, al
F000:DC8A
F000:DC8A exit:							      ;	CODE XREF: convert_something_2+3j
F000:DC8A							      ;	convert_something_2+7j
F000:DC8A							      ;	convert_something_2:l2j
F000:DC8A							      ;	convert_something_2+30j ...
F000:DC8A		  retn
F000:DC8A convert_something_2 endp
F000:DC8A
F000:DC8A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DC8B some_kind_of_table db	 5Ch, 2Bh, 7Eh,	29h, 7Ch, 2Bh, 60h, 29h, 2Dh
F000:DC8B							      ;	DATA XREF: convert_something_2+1Do
F000:DC94		  db  4Ah ; J
F000:DC95		  db  2Bh ; +
F000:DC96		  db  4Eh ; N
F000:DC97		  db  2Eh ; .
F000:DC98		  db  53h ; S
F000:DC99		  db  0Dh
F000:DC9A		  db  1Ch
F000:DC9B		  db  0Ah
F000:DC9C		  db  1Ch
F000:DC9D sort_of_abc_to_scancode_tbl db    3, 1Eh, 30h, 2Eh, 20h, 12h,	21h, 22h, 23h, 17h, 24h, 25h, 26h, 32h,	31h, 18h, 19h
F000:DC9D							      ;	DATA XREF: convert_something_2+46o
F000:DC9D		  db  10h, 13h,	1Fh, 14h, 16h, 2Fh, 11h, 2Dh, 15h, 2Ch,	1Ah, 2Bh, 1Bh,	 7, 0Ch, 39h,	2
F000:DC9D		  db  28h,   4,	  5,   6,   8, 28h, 0Ah, 0Bh,	9, 0Dh,	33h, 0Ch, 34h, 35h, 0Bh,   2,	3
F000:DC9D		  db	4,   5,	  6,   7,   8,	 9, 0Ah,2 dup( 27h), 33h, 0Dh, 34h, 35h,   3, 1Eh, 30h
F000:DC9D		  db  2Eh, 20h,	12h, 21h, 22h, 23h, 17h, 24h, 25h, 26h,	32h, 31h, 18h, 19h, 10h, 13h, 1Fh
F000:DC9D		  db  14h, 16h,	2Fh, 11h, 2Dh, 15h, 2Ch, 1Ah, 2Bh, 1Bh,	  7, 0Ch, 29h, 1Eh, 30h, 2Eh, 20h
F000:DC9D		  db  12h, 21h,	22h, 23h, 17h, 24h, 25h, 26h, 32h, 31h,	18h, 19h, 10h, 13h, 1Fh, 14h, 16h
F000:DC9D		  db  2Fh, 11h,	2Dh, 15h, 2Ch, 1Ah, 2Bh, 1Bh, 29h, 0Eh
F000:DD1D
F000:DD1D ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD1D
F000:DD1D
F000:DD1D int_15_handler  proc far				      ;	DATA XREF: F000:FF0Do
F000:DD1D		  sti					      ;	read / write to	EEPROM ?
F000:DD1E
F000:DD1E int_15_handler_bis:					      ;	CODE XREF: POST_test_8259+97j
F000:DD1E		  cmp	  ah, 70h ; 'p'
F000:DD21		  jz	  short	ok
F000:DD23
F000:DD23 exit_with_error:					      ;	CODE XREF: int_15_handler+1Aj
F000:DD23		  mov	  ah, 86h ; '†'
F000:DD25		  stc
F000:DD26
F000:DD26 exit:							      ;	CODE XREF: int_15_handler+20j
F000:DD26		  retf	  2
F000:DD29 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DD29
F000:DD29 ok:							      ;	CODE XREF: int_15_handler+4j
F000:DD29		  push	  ax
F000:DD2A		  push	  bx
F000:DD2B		  push	  cx
F000:DD2C		  or	  al, al
F000:DD2E		  jz	  short	near ptr int_15_00_handler
F000:DD30		  dec	  al
F000:DD32		  jz	  short	near ptr int_15_01_handler
F000:DD34		  pop	  cx
F000:DD35		  pop	  bx
F000:DD36		  pop	  ax
F000:DD37		  jmp	  short	exit_with_error
F000:DD39 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DD39
F000:DD39 pop_and_exit:						      ;	CODE XREF: int_15_00_handler+16j
F000:DD39							      ;	int_15_01_handler+21j
F000:DD39		  clc
F000:DD3A		  pop	  cx
F000:DD3B		  pop	  bx
F000:DD3C		  pop	  ax
F000:DD3D		  jmp	  short	exit
F000:DD3D int_15_handler  endp
F000:DD3D
F000:DD3F
F000:DD3F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD3F
F000:DD3F ; Read From EEROM
F000:DD3F ;
F000:DD3F ; Read the 16	bit value from the indicated EEROM word.
F000:DD3F ; Entry Conditions:
F000:DD3F ;   AH = 70H
F000:DD3F ;   AL = 0
F000:DD3F ;   BL = word	number to read (0 -15)
F000:DD3F ;
F000:DD3F ; Exit Conditions:
F000:DD3F ;   DX = word	value
F000:DD3F ;   Carry Flag set indicates EEROM call not supported, system	is not a 1000HX
F000:DD3F
F000:DD3F int_15_00_handler proc far				      ;	CODE XREF: int_15_handler+11j
F000:DD3F		  mov	  dx, 37Ch			      ;	EEPROM port
F000:DD42		  mov	  ah, bl			      ;	word number to read (0-15)
F000:DD44		  and	  ah, 0Fh
F000:DD47		  or	  ah, 80h
F000:DD4A		  call	  EEPROM_init_1?
F000:DD4D		  call	  EEPROM_read
F000:DD50		  mov	  al, 0
F000:DD52		  out	  dx, al
F000:DD53		  mov	  dx, bx			      ;	EEPROM value in	dx
F000:DD55		  jmp	  short	pop_and_exit
F000:DD55 int_15_00_handler endp
F000:DD55
F000:DD57
F000:DD57 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD57
F000:DD57 ; Write To EEROM
F000:DD57 ;
F000:DD57 ; Write a 16 bit value to the	indicated EEROM	word
F000:DD57 ;
F000:DD57 ; Entry Conditions:
F000:DD57 ;   AH = 70H
F000:DD57 ;   AL = 1
F000:DD57 ;   BL = word	number to write	(0-15)
F000:DD57 ;   DX = word	value to write
F000:DD57 ;
F000:DD57 ; Exit Conditions:
F000:DD57 ;   Carry Flag set indicates EEROM call not supported, system	is not a 1000HX
F000:DD57
F000:DD57 int_15_01_handler proc far				      ;	CODE XREF: int_15_handler+15j
F000:DD57		  push	  dx				      ;	EEPROM value to	write in dx
F000:DD58		  push	  dx
F000:DD59		  mov	  dx, 37Ch			      ;	EEPROM port
F000:DD5C		  call	  EEPROM_init_3?
F000:DD5F		  call	  EEPROM_init_2?
F000:DD62		  mov	  ah, bl
F000:DD64		  and	  ah, 0Fh
F000:DD67		  or	  ah, 40h
F000:DD6A		  call	  EEPROM_init_1?
F000:DD6D		  pop	  bx				      ;	bx has value to	write to EEPROM
F000:DD6E		  call	  EEPROM_write_word
F000:DD71		  call	  EEPROM_write_finish_1?
F000:DD74		  call	  EEPROM_write_finish_2?
F000:DD77		  pop	  dx
F000:DD78		  jmp	  short	pop_and_exit
F000:DD78 int_15_01_handler endp
F000:DD78
F000:DD7A
F000:DD7A ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD7A
F000:DD7A
F000:DD7A EEPROM_out_something proc near			      ;	CODE XREF: EEPROM_init_1?+5p
F000:DD7A							      ;	EEPROM_init_1?+Ap
F000:DD7A							      ;	EEPROM_init_1?+Fp
F000:DD7A							      ;	EEPROM_init_1?+1Ap ...
F000:DD7A		  out	  dx, al
F000:DD7B		  or	  al, 4
F000:DD7D		  out	  dx, al
F000:DD7E		  retn
F000:DD7E EEPROM_out_something endp
F000:DD7E
F000:DD7F
F000:DD7F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD7F
F000:DD7F
F000:DD7F EEPROM_write_finish_2? proc near			      ;	CODE XREF: int_15_01_handler+1Dp
F000:DD7F							      ;	EEPROM_init_3?+11p
F000:DD7F		  mov	  ah, 0
F000:DD81		  call	  EEPROM_init_1?
F000:DD84		  mov	  al, 0
F000:DD86		  out	  dx, al
F000:DD87		  retn
F000:DD87 EEPROM_write_finish_2? endp
F000:DD87
F000:DD88
F000:DD88 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD88
F000:DD88
F000:DD88 EEPROM_init_2?  proc near				      ;	CODE XREF: int_15_01_handler+8p
F000:DD88							      ;	EEPROM_init_3?p
F000:DD88		  mov	  ah, 30h ; '0'
F000:DD8A		  call	  EEPROM_init_1?
F000:DD8D		  mov	  al, 0
F000:DD8F		  out	  dx, al
F000:DD90		  retn
F000:DD90 EEPROM_init_2?  endp
F000:DD90
F000:DD91
F000:DD91 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DD91
F000:DD91
F000:DD91 EEPROM_init_3?  proc near				      ;	CODE XREF: int_15_01_handler+5p
F000:DD91		  call	  EEPROM_init_2?
F000:DD94		  mov	  ah, bl
F000:DD96		  and	  ah, 0Fh
F000:DD99		  or	  ah, 0C0h
F000:DD9C		  call	  EEPROM_init_1?
F000:DD9F		  call	  EEPROM_write_finish_1?
F000:DDA2		  call	  EEPROM_write_finish_2?
F000:DDA5		  retn
F000:DDA5 EEPROM_init_3?  endp
F000:DDA5
F000:DDA6
F000:DDA6 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DDA6
F000:DDA6
F000:DDA6 EEPROM_read_bit proc near				      ;	CODE XREF: EEPROM_readp
F000:DDA6							      ;	EEPROM_read+Ap
F000:DDA6		  mov	  al, 2
F000:DDA8		  out	  dx, al			      ;	dx = 37c
F000:DDA9		  in	  al, 62h			      ;	0-2: Not Used
F000:DDA9							      ;	3: CPU Clock Rate
F000:DDA9							      ;	    0 =	4.77 MHz (PC Compatible	Rate)
F000:DDA9							      ;	    1 =	7.16 MHz (Default by Boot ROM)
F000:DDA9							      ;	4: EEPROM Serial Data Read
F000:DDA9							      ;	5: 8253	Out #2
F000:DDA9							      ;	6: Monochrome Mode
F000:DDA9							      ;	    0 =	Color Monitor
F000:DDA9							      ;	    1 =	Not supported
F000:DDA9							      ;	7: 0 = Reserved
F000:DDAB		  and	  al, 10000b			      ;	interested in bit 4 only
F000:DDAD		  shr	  al, 1
F000:DDAF		  shr	  al, 1
F000:DDB1		  shr	  al, 1
F000:DDB3		  shr	  al, 1				      ;	move bit 4 to bit 0
F000:DDB5		  mov	  ah, al			      ;	copy al	to ah
F000:DDB7		  mov	  al, 6
F000:DDB9		  out	  dx, al			      ;	dx = 37c
F000:DDBA		  retn
F000:DDBA EEPROM_read_bit endp
F000:DDBA
F000:DDBB
F000:DDBB ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DDBB
F000:DDBB
F000:DDBB EEPROM_read	  proc near				      ;	CODE XREF: int_15_00_handler+Ep
F000:DDBB		  call	  EEPROM_read_bit
F000:DDBE		  xor	  bx, bx			      ;	first bit discarded ?
F000:DDC0		  mov	  cx, 10h
F000:DDC3
F000:DDC3 loc_FDDC3:						      ;	CODE XREF: EEPROM_read+Fj
F000:DDC3		  rol	  bx, 1
F000:DDC5		  call	  EEPROM_read_bit
F000:DDC8		  or	  bl, ah
F000:DDCA		  loop	  loc_FDDC3			      ;	repeat 16 times	(read a	word)
F000:DDCC		  retn
F000:DDCC EEPROM_read	  endp
F000:DDCC
F000:DDCD
F000:DDCD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DDCD
F000:DDCD
F000:DDCD EEPROM_init_1?  proc near				      ;	CODE XREF: int_15_00_handler+Bp
F000:DDCD							      ;	int_15_01_handler+13p
F000:DDCD							      ;	EEPROM_write_finish_2?+2p
F000:DDCD							      ;	EEPROM_init_2?+2p ...
F000:DDCD		  mov	  cx, 8
F000:DDD0		  mov	  al, 0
F000:DDD2		  call	  EEPROM_out_something
F000:DDD5		  mov	  al, 2
F000:DDD7		  call	  EEPROM_out_something
F000:DDDA		  mov	  al, 3
F000:DDDC		  call	  EEPROM_out_something
F000:DDDF
F000:DDDF l0:							      ;	CODE XREF: EEPROM_init_1?+1Dj
F000:DDDF		  rol	  ah, 1				      ;	ah = bl	| 80h.	ah 'rols' once per loop
F000:DDE1		  mov	  al, ah
F000:DDE3		  and	  al, 1
F000:DDE5		  or	  al, 2
F000:DDE7		  call	  EEPROM_out_something
F000:DDEA		  loop	  l0				      ;	repeat 8 times
F000:DDEC		  retn
F000:DDEC EEPROM_init_1?  endp
F000:DDEC
F000:DDED
F000:DDED ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DDED
F000:DDED
F000:DDED EEPROM_write_word proc near				      ;	CODE XREF: int_15_01_handler+17p
F000:DDED		  mov	  cx, 10h
F000:DDF0
F000:DDF0 l0:							      ;	CODE XREF: EEPROM_write_word+Ej
F000:DDF0		  rol	  bx, 1
F000:DDF2		  mov	  al, bl
F000:DDF4		  and	  al, 1				      ;	0: bit to write
F000:DDF4							      ;	1: 1=means write ?
F000:DDF4							      ;	2-7: should be 0?
F000:DDF6		  or	  al, 2
F000:DDF8		  call	  EEPROM_out_something
F000:DDFB		  loop	  l0				      ;	repeat 16 times	(write 16 bits)
F000:DDFD		  retn
F000:DDFD EEPROM_write_word endp
F000:DDFD
F000:DDFE
F000:DDFE ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:DDFE
F000:DDFE
F000:DDFE EEPROM_write_finish_1? proc near			      ;	CODE XREF: int_15_01_handler+1Ap
F000:DDFE							      ;	EEPROM_init_3?+Ep
F000:DDFE		  mov	  al, 0				      ;	1-7: 0=init ?
F000:DE00		  out	  dx, al
F000:DE01		  mov	  al, 4
F000:DE03		  out	  dx, al
F000:DE04		  mov	  cx, 3840h
F000:DE07
F000:DE07 delay:						      ;	CODE XREF: EEPROM_write_finish_1?:delayj
F000:DE07		  loop	  delay				      ;	delay
F000:DE09		  mov	  al, 0				      ;	1-7: 0=init ?
F000:DE0B		  out	  dx, al
F000:DE0C		  retn
F000:DE0C EEPROM_write_finish_1? endp
F000:DE0C
F000:DE0C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:DE0D		  db 103h dup(0FFh)
F000:DF10 video_6845_init_tbl_a	db 38h,	28h, 2Dh, 0Ah, 1Fh, 6, 19h, 1Ch, 2, 7, 6, 7, 4 dup(0); init_modes_0_1
F000:DF10							      ;	DATA XREF: POST_main:l4o
F000:DF10							      ;	int_10_00_handler+10Do
F000:DF10		  db 71h, 50h, 5Ah, 0Ah, 1Fh, 6, 19h, 1Ch, 2, 7, 6, 7, 4 dup(0); init_modes_2_3	; 3d5 values for index 0-15
F000:DF10		  db 38h, 28h, 2Dh, 0Ah, 7Fh, 6, 64h, 70h, 2, 1, 6, 7, 4 dup(0); init_modes_4_5_6_8
F000:DF10		  db 61h, 50h, 52h, 0Fh, 19h, 6, 2 dup(19h), 2,	0Dh, 0Bh, 0Ch, 4 dup(0); init_mode_7
F000:DF10		  db 71h, 50h, 5Ah, 0Eh, 3Fh, 6, 32h, 38h, 2, 3, 6, 7, 4 dup(0); init_modes_9_a
F000:DF60 video_6845_init_tbl_b	db 38h,	28h, 2Dh, 8, 21h, 7, 19h, 1Dh, 2, 8, 6,	7, 4 dup(0); init_modes_0_1
F000:DF60							      ;	DATA XREF: POST_init_ints_and_more+387o
F000:DF60		  db 71h, 50h, 59h, 10h, 21h, 7, 19h, 1Dh, 2, 8, 6, 7, 4 dup(0); init_modes_2_3
F000:DF60		  db 38h, 28h, 2Dh, 8, 9Bh, 1, 64h, 7Ch, 2, 1, 6, 7, 4 dup(0); init_modes_4_5_6_8
F000:DF60		  db 61h, 50h, 52h, 0Fh, 19h, 6, 2 dup(19h), 2,	0Dh, 0Bh, 0Ch, 4 dup(0); init_mode_7
F000:DF60		  db 71h, 50h, 59h, 10h, 4Dh, 1, 32h, 3Eh, 2, 3, 6, 7, 4 dup(0); init_modes_9_a
F000:DFB0 video_6845_init_tbl_c	db 38h,	28h, 2Dh, 8, 26h, 1, 19h, 1Fh, 2, 7, 6,	7, 4 dup(0); init_modes_0_1
F000:DFB0							      ;	DATA XREF: POST_init_ints_and_more+39Eo
F000:DFB0		  db 71h, 50h, 59h, 10h, 26h, 1, 19h, 1Fh, 2, 7, 6, 7, 4 dup(0); init_modes_2_3
F000:DFB0		  db 38h, 28h, 2Dh, 8, 9Bh, 1, 64h, 7Ch, 2, 1, 6, 7, 4 dup(0); init_modes_4_5_6_8
F000:DFB0		  db 61h, 50h, 52h, 0Fh, 19h, 6, 2 dup(19h), 2,	0Dh, 0Bh, 0Ch, 4 dup(0); init_mode_7
F000:DFB0		  db 71h, 50h, 59h, 10h, 4Dh, 1, 32h, 3Eh, 2, 3, 6, 7, 4 dup(0); init_modes_9_a
F000:E000 video_6845_init_tbl_d	db 38h,	28h, 2Dh, 8, 1Ch, 1, 19h, 1Ah, 2, 8, 6,	7, 4 dup(0); init_modes_0_1
F000:E000							      ;	DATA XREF: POST_main+ADo
F000:E000							      ;	POST_main+136o	F000:FF1Do
F000:E000		  db 71h, 50h, 59h, 10h, 1Ch, 1, 19h, 1Ah, 2, 8, 6, 7, 4 dup(0); init_modes_2_3	; value	for 3d5. index 0-15
F000:E000		  db 38h, 28h, 2Dh, 8, 7Fh, 6, 64h, 70h, 2, 1, 6, 7, 4 dup(0); init_modes_4_5_6_8
F000:E000		  db 61h, 50h, 52h, 0Fh, 19h, 6, 2 dup(19h), 2,	0Dh, 0Bh, 0Ch, 4 dup(0); init_mode_7
F000:E000		  db 71h, 50h, 59h, 10h, 3Fh, 6, 32h, 38h, 2, 3, 6, 7, 4 dup(0); init_modes_9_a
F000:E050		  db  4Ch ; L
F000:E051		  db  49h ; I
F000:E052		  db 0E9h ; é
F000:E053		  db 0C6h ; Æ
F000:E054		  db 0FAh ; ú
F000:E055		  db 0FFh
F000:E056		  db 0FFh
F000:E057		  db 0FFh
F000:E058		  db 0FFh
F000:E059		  db 0FFh
F000:E05A		  db 0FFh
F000:E05B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E05B ; START OF FUNCTION CHUNK FOR	POST_main
F000:E05B
F000:E05B POST_entry:						      ;	CODE XREF: POST_init_ints_and_more+40Fj
F000:E05B							      ;	F000:reset_vectorJ
F000:E05B		  mov	  ax, 40h ; '@'
F000:E05E		  mov	  ds, ax			      ;	ds = 40h
F000:E060		  xor	  di, di
F000:E062		  cmp	  word ptr ds:p400.POST_reset_flag, 1234h ; requested by Ctrl+Alt+Del?
F000:E068		  jnz	  short	loc_FE072
F000:E06A		  mov	  di, ds:p400.keyb_status_flags_1     ;	417 = keyboard status flags
F000:E06E		  and	  di, 110000001100000b		      ;	caps or	numlock	pressed	or locked ?
F000:E072
F000:E072 loc_FE072:						      ;	CODE XREF: POST_main+1BC0j
F000:E072		  mov	  si, ds:p400.POST_reset_flag
F000:E076		  jmp	  near ptr POST_main
F000:E076 ; END	OF FUNCTION CHUNK FOR POST_main
F000:E079
F000:E079 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E079
F000:E079
F000:E079 POST_init_ints_and_more proc far			      ;	CODE XREF: POST_test_8259+17Cj
F000:E079		  mov	  ax, 40h ; '@'
F000:E07C		  mov	  ds, ax			      ;	ds = 40h
F000:E07E		  mov	  ax, 0BBE8h
F000:E081		  mov	  es, ax			      ;	es = bbe8h
F000:E083		  cmp	  word ptr es:pbbe80.shadow_reset_flag,	1234h ;	bbe8:0008 = bbe88: somewhere video in addr
F000:E08A		  jnz	  short	l0
F000:E08C		  mov	  ax, es:pbbe80.shadow_caps_numlock
F000:E090		  mov	  ds:p400.keyb_status_flags_1, ax     ;	keyboard status	flags?
F000:E093
F000:E093 l0:							      ;	CODE XREF: POST_init_ints_and_more+11j
F000:E093		  cli
F000:E094		  cld
F000:E095		  mov	  ax, 36h ; '6'
F000:E098		  mov	  dx, 43h ; 'C'
F000:E09B		  out	  dx, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E09C		  jmp	  short	$+2
F000:E09E		  mov	  dx, 40h ; '@'
F000:E0A1		  mov	  al, 0
F000:E0A3		  out	  dx, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E0A4		  jmp	  short	$+2
F000:E0A6		  out	  dx, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E0A7		  jmp	  short	$+2
F000:E0A9		  mov	  al, 0B6h ; '¶'
F000:E0AB		  out	  43h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E0AD		  jmp	  short	$+2
F000:E0AF		  xor	  al, al
F000:E0B1		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E0B3		  jmp	  short	$+2
F000:E0B5		  mov	  al, 5
F000:E0B7		  out	  42h, al			      ;	Timer 8253-5 (AT: 8254.2).
F000:E0B9		  xor	  ax, ax			      ;	es:si =	zero page
F000:E0BB		  mov	  es, ax			      ;	es = 0
F000:E0BD		  mov	  ax, 30h ; '0'
F000:E0C0		  mov	  ss, ax
F000:E0C2		  mov	  ax, 100h			      ;	setup stack tmp	at 0100:0000 (0x1000)
F000:E0C5		  mov	  sp, ax
F000:E0C7		  mov	  ax, cs			      ;	setup interrupt	table
F000:E0C9		  mov	  ds, ax
F000:E0CB		  mov	  si, offset int_00_07_table
F000:E0CE		  xor	  di, di			      ;	ptr to Int 0 vector table
F000:E0D0		  mov	  cx, 8				      ;	copy first 8 interrupts
F000:E0D3		  call	  copy_to_vector_tbl
F000:E0D6		  mov	  si, offset int_08_1f_table
F000:E0D9		  mov	  di, 20h ; ' '                       ; Interrupt ptr to int 8 vector table
F000:E0DC		  mov	  cx, 18h			      ;	copy first 24 interrupts
F000:E0DF		  call	  copy_to_vector_tbl
F000:E0E2		  mov	  si, offset int_44_44_table
F000:E0E5		  mov	  di, 110h			      ;	Interrupt 0x44 (68)
F000:E0E8		  mov	  cx, 1
F000:E0EB		  call	  copy_to_vector_tbl
F000:E0EE		  mov	  ax, 0BBE8h
F000:E0F1		  mov	  es, ax			      ;	es = bbe8h
F000:E0F3		  mov	  ax, 40h ; '@'
F000:E0F6		  mov	  ds, ax			      ;	ds = 40h
F000:E0F8		  mov	  al, 0FFh
F000:E0FA		  out	  21h, al			      ;	Interrupt controller, 8259A.
F000:E0FC		  in	  al, 61h			      ;	PC/XT PPI port B bits:
F000:E0FC							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:E0FC							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:E0FC							      ;	3: 1=read high switches
F000:E0FC							      ;	4: 0=enable RAM	parity checking
F000:E0FC							      ;	5: 0=enable I/O	channel	check
F000:E0FC							      ;	6: 0=hold keyboard clock low
F000:E0FC							      ;	7: 0=enable kbrd
F000:E0FE		  or	  al, 1
F000:E100		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:E100							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:E100							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:E100							      ;	3: 1=read high switches
F000:E100							      ;	4: 0=enable RAM	parity checking
F000:E100							      ;	5: 0=enable I/O	channel	check
F000:E100							      ;	6: 0=hold keyboard clock low
F000:E100							      ;	7: 0=enable kbrd
F000:E102		  and	  al, 0EEh
F000:E104		  out	  61h, al			      ;	PC/XT PPI port B bits:
F000:E104							      ;	0: Tmr 2 gate ÍËÍ OR 03H=spkr ON
F000:E104							      ;	1: Tmr 2 data Í¼  AND 0fcH=spkr	OFF
F000:E104							      ;	3: 1=read high switches
F000:E104							      ;	4: 0=enable RAM	parity checking
F000:E104							      ;	5: 0=enable I/O	channel	check
F000:E104							      ;	6: 0=hold keyboard clock low
F000:E104							      ;	7: 0=enable kbrd
F000:E106		  mov	  dx, 213h
F000:E109		  mov	  al, 1
F000:E10B		  out	  dx, al			      ;	XT Expansion chassis enable
F000:E10C		  nop
F000:E10D		  mov	  al, es:pbbe80.tmp_reg6_byte
F000:E111		  xor	  ah, ah
F000:E113		  mov	  cl, 4
F000:E115		  shl	  ax, cl
F000:E117		  or	  al, 8
F000:E119		  mov	  ds:p400.extra_status,	ax
F000:E11C		  mov	  bx, 1000000101101b		      ;	default	values:
F000:E11C							      ;	1 diskette installed
F000:E11C							      ;	0 math copro
F000:E11C							      ;	11 number of 64k banks
F000:E11C							      ;	10 initial video mode (80x25 color)
F000:E11C							      ;	00 number of diskette drives
F000:E11C							      ;	0 dma present
F000:E11C							      ;	000 number of rs232
F000:E11C							      ;	1 game i/o attached
F000:E11C							      ;	0 serial printer installed
F000:E11C							      ;	00 number of printers
F000:E11C							      ;
F000:E11F		  in	  al, 62h			      ;	0-2: Not used
F000:E11F							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:E11F							      ;	4: EEPROM data-serial read only
F000:E11F							      ;	5: 1=Timer 2 channel out
F000:E11F							      ;	6: Monochrome mode. 0=Color monitor
F000:E11F							      ;	7: Reserved
F000:E121		  test	  al, 1000000b			      ;	color mode?
F000:E123		  jz	  short	l1			      ;	yes, is	color
F000:E125		  test	  word ptr ds:p400.extra_status, 20h
F000:E12B		  jz	  short	l1
F000:E12D		  or	  bx, 110000b			      ;	initial	video mode = 80x25 mono
F000:E131
F000:E131 l1:							      ;	CODE XREF: POST_init_ints_and_more+AAj
F000:E131							      ;	POST_init_ints_and_more+B2j
F000:E131		  mov	  ds:p400.installed_hardware, bx      ;	set installed hardware
F000:E135		  mov	  bx, es:0
F000:E13A		  mov	  cl, 6
F000:E13C		  shr	  bx, cl
F000:E13E		  add	  bx, 256			      ;	256k base memory
F000:E142		  mov	  ds:p400.IO_channel_RAM_size, bx
F000:E146		  mov	  ds:p400.base_mem_kb, bx	      ;	base memory size in Kb
F000:E14A		  mov	  cl, 6
F000:E14C		  shr	  bx, cl
F000:E14E		  sub	  bx, 2
F000:E151		  or	  bl, 10h
F000:E154		  mov	  al, bl
F000:E156		  or	  al, 1
F000:E158		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:E15A		  push	  bx
F000:E15B		  push	  ds
F000:E15C		  push	  es
F000:E15D		  mov	  ax, 0C000h			      ;	ROM cartridge at c000h ?
F000:E160		  mov	  ds, ax			      ;	ds = c000h
F000:E162		  mov	  cx, 10h
F000:E165		  call	  run_boot_sector_if_valid
F000:E168		  pop	  es
F000:E169		  pop	  ds
F000:E16A		  test	  byte ptr ds:p400.extra_status, 10h
F000:E16F		  jnz	  short	l2
F000:E171		  pop	  ax
F000:E172		  push	  ax
F000:E173		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:E175
F000:E175 l2:							      ;	CODE XREF: POST_init_ints_and_more+F6j
F000:E175		  mov	  ah, 12h
F000:E177		  mov	  bl, 10h
F000:E179		  int	  10h				      ;	- VIDEO	- ALTERNATE FUNCTION SELECT (PS, EGA, VGA, MCGA) - GET EGA INFO
F000:E179							      ;	Return:	BH = 00h color mode in effect CH = feature bits, CL = switch settings
F000:E17B		  pop	  cx
F000:E17C		  cmp	  bl, 10h
F000:E17F		  jz	  short	l4
F000:E181		  or	  bh, bh
F000:E183		  jnz	  short	l3
F000:E185		  or	  byte ptr ds:p400.extra_status, 10h  ;	external color video enabled
F000:E18A		  mov	  al, cl
F000:E18C		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:E18E		  xor	  al, al
F000:E190		  mov	  dx, 3D8h
F000:E193		  out	  dx, al
F000:E194		  mov	  al, cl
F000:E196		  or	  al, 1
F000:E198		  out	  0A0h,	al			      ;	PIC 2  same as 0020 for	PIC 1
F000:E19A		  jmp	  short	l4
F000:E19C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E19C
F000:E19C l3:							      ;	CODE XREF: POST_init_ints_and_more+10Aj
F000:E19C		  or	  byte ptr ds:p400.extra_status, 20h  ;	external monochrome monitor installed
F000:E1A1
F000:E1A1 l4:							      ;	CODE XREF: POST_init_ints_and_more+106j
F000:E1A1							      ;	POST_init_ints_and_more+121j
F000:E1A1		  test	  word ptr ds:p400.extra_status, 10h  ;	external color video enabled?
F000:E1A7		  jnz	  short	l5
F000:E1A9		  sub	  word ptr ds:p400.base_mem_kb,	10h   ;	base memory size in Kb
F000:E1AE
F000:E1AE l5:							      ;	CODE XREF: POST_init_ints_and_more+12Ej
F000:E1AE		  mov	  ax, 1Eh
F000:E1B1		  mov	  ds:p400.keyb_buffer_head_ptr,	ax
F000:E1B4		  mov	  ds:p400.keyb_buffer_tail_ptr,	ax
F000:E1B7		  mov	  ds:p400.keyb_buffer_start_offset_ptr,	ax
F000:E1BA		  add	  ax, 20h ; ' '
F000:E1BD		  mov	  ds:p400.keyb_buffer_end_offset_ptr, ax
F000:E1C0		  mov	  byte ptr ds:p400.video_page_data, 3Fh	; '?'
F000:E1C5		  mov	  al, 0Eh
F000:E1C7		  out	  0Fh, al			      ;	DMA controller,	8237A-5.
F000:E1C7							      ;	master clear. Clear or mask any	or
F000:E1C7							      ;	all of the channels. Bits:
F000:E1C7							      ;	0: 1=mask channel 0; 0=enable
F000:E1C7							      ;	1: 1=mask channel 1;
F000:E1C7							      ;	2: 1=mask channel 2;
F000:E1C7							      ;	3: 1=mask channel 3;
F000:E1C9		  out	  0Ch, al			      ;	DMA controller,	8237A-5.
F000:E1C9							      ;	clear byte pointer flip-flop.
F000:E1CB		  mov	  dx, 4
F000:E1CE
F000:E1CE l6:							      ;	CODE XREF: POST_init_ints_and_more+171j
F000:E1CE		  mov	  cx, 1
F000:E1D1
F000:E1D1 l7:							      ;	CODE XREF: POST_init_ints_and_more+16Bj
F000:E1D1		  mov	  ax, cx
F000:E1D3		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:E1D3							      ;	channel	2 base address
F000:E1D3							      ;	(also sets current address)
F000:E1D4		  mov	  al, ah
F000:E1D6		  out	  dx, al			      ;	DMA controller,	8237A-5.
F000:E1D6							      ;	channel	2 base address
F000:E1D6							      ;	(also sets current address)
F000:E1D7		  nop
F000:E1D8		  in	  al, dx			      ;	DMA controller,	8237A-5.
F000:E1D8							      ;	channel	2 current address
F000:E1D9		  mov	  ah, al
F000:E1DB		  in	  al, dx			      ;	DMA controller,	8237A-5.
F000:E1DB							      ;	channel	2 current address
F000:E1DC		  xchg	  ah, al
F000:E1DE		  cmp	  ax, cx
F000:E1E0		  jnz	  short	l8
F000:E1E2		  rcl	  cx, 1
F000:E1E4		  jnb	  short	l7
F000:E1E6		  inc	  dx
F000:E1E7		  cmp	  dx, 6
F000:E1EA		  jnz	  short	l6
F000:E1EC		  jmp	  short	l9
F000:E1EE ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E1EE
F000:E1EE l8:							      ;	CODE XREF: POST_init_ints_and_more+167j
F000:E1EE		  or	  word ptr ds:p400.installed_hardware, 100h ; XXX reserved bit... what could it	be?
F000:E1F4
F000:E1F4 l9:							      ;	CODE XREF: POST_init_ints_and_more+173j
F000:E1F4		  call	  play_bell_sound
F000:E1F7		  mov	  ax, 7000h
F000:E1FA		  mov	  bl, 2
F000:E1FC		  int	  15h				      ;	read EEPROM
F000:E1FE		  mov	  al, dl
F000:E200		  ror	  al, 1
F000:E202		  ror	  al, 1
F000:E204		  and	  al, 11000000b
F000:E206		  and	  byte ptr ds:p400.installed_hardware, 111111b ; set number of diskettes to 0
F000:E20B		  or	  ds:p400.installed_hardware, al
F000:E20F		  mov	  al, dl
F000:E211		  and	  al, 0F0h
F000:E213		  cmp	  al, 30h ; '0'
F000:E215		  jnz	  short	l10
F000:E217		  or	  byte ptr ds:p400.extra_status, 1    ;	drive A	is 3 1/2
F000:E21C
F000:E21C l10:							      ;	CODE XREF: POST_init_ints_and_more+19Cj
F000:E21C		  mov	  al, dh
F000:E21E		  and	  al, 0Fh
F000:E220		  cmp	  al, 3
F000:E222		  jnz	  short	l11
F000:E224		  or	  byte ptr ds:p400.extra_status, 2    ;	drive B	is 3 1/2
F000:E229
F000:E229 l11:							      ;	CODE XREF: POST_init_ints_and_more+1A9j
F000:E229		  mov	  al, dh
F000:E22B		  and	  al, 0F0h
F000:E22D		  cmp	  al, 30h ; '0'
F000:E22F		  jnz	  short	l12
F000:E231		  or	  byte ptr ds:p400.extra_status_2, 1  ;	drive C	is 3 1/2
F000:E236
F000:E236 l12:							      ;	CODE XREF: POST_init_ints_and_more+1B6j
F000:E236		  test	  word ptr ds:p400.installed_hardware, 11000000b ; number of diskettes
F000:E23C		  jnz	  short	l13
F000:E23E		  test	  word ptr ds:p400.extra_status, 1    ;	is drive A 3 1/2?
F000:E244		  jz	  short	l13
F000:E246		  or	  word ptr ds:p400.extra_status, 2    ;	drive B	is 3 1/2
F000:E24C
F000:E24C l13:							      ;	CODE XREF: POST_init_ints_and_more+1C3j
F000:E24C							      ;	POST_init_ints_and_more+1CBj
F000:E24C		  mov	  bx, p400.lpt0_base_addr
F000:E24F		  mov	  dx, 3BCh
F000:E252		  mov	  al, 0A5h ; '¥'
F000:E254		  out	  dx, al			      ;	Printer	Data Latch:
F000:E254							      ;	send byte to printer
F000:E255		  jmp	  short	$+2
F000:E257		  in	  al, dx			      ;	Printer	Data Latch:
F000:E257							      ;	fetch last byte	sent
F000:E258		  cmp	  al, 0A5h ; '¥'
F000:E25A		  jnz	  short	l14
F000:E25C		  mov	  [bx],	dx			      ;	base addresss for lpt0
F000:E25E		  inc	  bx
F000:E25F		  inc	  bx
F000:E260		  add	  word ptr ds:p400.installed_hardware, 4000h ; printer installed + 1
F000:E266
F000:E266 l14:							      ;	CODE XREF: POST_init_ints_and_more+1E1j
F000:E266		  mov	  dx, 378h
F000:E269		  mov	  al, 0A5h ; '¥'
F000:E26B		  out	  dx, al			      ;	Printer	Data Latch:
F000:E26B							      ;	send byte to printer
F000:E26C		  jmp	  short	$+2
F000:E26E		  in	  al, dx			      ;	Printer	Data Latch:
F000:E26E							      ;	fetch last byte	sent
F000:E26F		  cmp	  al, 0A5h ; '¥'
F000:E271		  jnz	  short	l15
F000:E273		  mov	  [bx],	dx			      ;	base address for lpt1
F000:E275		  inc	  bx
F000:E276		  inc	  bx
F000:E277		  add	  word ptr ds:p400.installed_hardware, 4000h ; printer installed + 1
F000:E27D
F000:E27D l15:							      ;	CODE XREF: POST_init_ints_and_more+1F8j
F000:E27D		  mov	  dx, 278h
F000:E280		  mov	  al, 0A5h ; '¥'
F000:E282		  out	  dx, al			      ;	Printer	Data Latch:
F000:E282							      ;	send byte to printer
F000:E283		  jmp	  short	$+2
F000:E285		  in	  al, dx			      ;	Printer	Data Latch:
F000:E285							      ;	fetch last byte	sent
F000:E286		  cmp	  al, 0A5h ; '¥'
F000:E288		  jnz	  short	l16
F000:E28A		  mov	  [bx],	dx			      ;	base address for lpt2
F000:E28C		  add	  word ptr ds:p400.installed_hardware, 4000h ; printer installed + 1
F000:E292
F000:E292 l16:							      ;	CODE XREF: POST_init_ints_and_more+20Fj
F000:E292		  mov	  bx, p400.lpt0_timeout
F000:E295		  mov	  word ptr [bx], 1414h		      ;	timeout	14h for	all four lpt
F000:E299		  mov	  word ptr [bx+2], 1414h
F000:E29E		  mov	  bx, p400
F000:E2A1		  mov	  dx, 3FBh
F000:E2A4		  mov	  al, 80h ; '€'
F000:E2A6		  out	  dx, al			      ;	COM: line control register bits:
F000:E2A6							      ;	0-1: word length: 00=5,	01=6, 10=7, 11=8
F000:E2A6							      ;	2:   stop bits:	0=1,1=2
F000:E2A6							      ;	3-4: parity: x0=None, 01=Odd, 11=Even
F000:E2A6							      ;	5:   stuck parity
F000:E2A6							      ;	6:   enable break control. 1=start sending 0s (spaces)
F000:E2A6							      ;	7:   DLAB (Divisor Latch Access	Bit)
F000:E2A7		  mov	  dx, 3F8h
F000:E2AA		  mov	  al, 0AAh ; 'ª'
F000:E2AC		  out	  dx, al			      ;	COM: transmitter holding register
F000:E2AC							      ;	or (when DLAB=1) divisor latch low byte.
F000:E2AD		  jmp	  short	$+2
F000:E2AF		  in	  al, dx			      ;	COM: receiver buffer register.
F000:E2AF							      ;	8 bits of character received.
F000:E2B0		  cmp	  al, 0AAh ; 'ª'
F000:E2B2		  jnz	  short	l17
F000:E2B4		  mov	  [bx],	dx			      ;	com0 base address
F000:E2B6		  inc	  bx
F000:E2B7		  inc	  bx
F000:E2B8		  add	  word ptr ds:p400.installed_hardware, 200h ; number of	RS232 ports + 1
F000:E2BE
F000:E2BE l17:							      ;	CODE XREF: POST_init_ints_and_more+239j
F000:E2BE		  mov	  dx, 2FBh
F000:E2C1		  mov	  al, 80h ; '€'
F000:E2C3		  out	  dx, al			      ;	COM: line control register bits:
F000:E2C3							      ;	0-1: word length: 00=5,	01=6, 10=7, 11=8
F000:E2C3							      ;	2:   stop bits:	0=1,1=2
F000:E2C3							      ;	3-4: parity: x0=None, 01=Odd, 11=Even
F000:E2C3							      ;	5:   stuck parity
F000:E2C3							      ;	6:   enable break control. 1=start sending 0s (spaces)
F000:E2C3							      ;	7:   DLAB (Divisor Latch Access	Bit)
F000:E2C4		  mov	  dx, 2F8h
F000:E2C7		  mov	  al, 0AAh ; 'ª'
F000:E2C9		  out	  dx, al			      ;	COM: transmitter holding register
F000:E2C9							      ;	or (when DLAB=1) divisor latch low byte.
F000:E2CA		  jmp	  short	$+2
F000:E2CC		  in	  al, dx			      ;	COM: receiver buffer register.
F000:E2CC							      ;	8 bits of character received.
F000:E2CD		  cmp	  al, 0AAh ; 'ª'
F000:E2CF		  jnz	  short	l18
F000:E2D1		  mov	  [bx],	dx			      ;	comm1 base address
F000:E2D3		  add	  word ptr ds:p400.installed_hardware, 200h ; number of	RS232 ports + 1
F000:E2D9
F000:E2D9 l18:							      ;	CODE XREF: POST_init_ints_and_more+256j
F000:E2D9		  mov	  bx, p400.comm_0_timeout
F000:E2DC		  mov	  word ptr [bx], 101h		      ;	01h timeout for	all four comms
F000:E2E0		  mov	  word ptr [bx+2], 101h
F000:E2E5		  xor	  ax, ax
F000:E2E7		  mov	  ds:p400.POST_entry_point_offset, ax
F000:E2EA		  finit					      ;	test math coprocessor
F000:E2ED		  wait
F000:E2EE		  fstcw	  word ptr ds:p400.POST_entry_point_offset
F000:E2F3		  wait
F000:E2F4		  cmp	  ax, ds:p400.POST_entry_point_offset
F000:E2F8		  jz	  short	l19
F000:E2FA		  or	  byte ptr ds:p400.installed_hardware, 2 ; math	coprocessor installed
F000:E2FF
F000:E2FF l19:							      ;	CODE XREF: POST_init_ints_and_more+27Fj
F000:E2FF		  mov	  ax, 0C800h			      ;	ROM cartridge at c800h ?
F000:E302		  mov	  ds, ax			      ;	ds = c800h
F000:E304		  mov	  cx, 58h ; 'X'
F000:E307		  call	  run_boot_sector_if_valid
F000:E30A		  mov	  ah, 8
F000:E30C		  mov	  dl, 80h ; '€'
F000:E30E		  int	  13h				      ;	DISK - DISK - GET CURRENT DRIVE	PARAMETERS (XT,AT,XT286,CONV,PS)
F000:E30E							      ;	DL = drive number
F000:E30E							      ;	Return:	CF set on error, AH = status code, BL =	drive type
F000:E30E							      ;	DL = number of consecutive drives
F000:E30E							      ;	DH = maximum value for head number, ES:DI -> drive parameter
F000:E310		  jb	  short	l21
F000:E312		  mov	  cl, dl
F000:E314		  xor	  ch, ch
F000:E316		  jcxz	  short	l21
F000:E318		  push	  cs
F000:E319		  pop	  es
F000:E31A		  mov	  bx, 0C000h
F000:E31D
F000:E31D l20:							      ;	CODE XREF: POST_init_ints_and_more+2B7j
F000:E31D		  mov	  dx, cx
F000:E31F		  add	  dl, 7Fh ; ''
F000:E322		  push	  cx
F000:E323		  xor	  ah, ah
F000:E325		  int	  13h				      ;	DISK - RESET DISK SYSTEM
F000:E325							      ;	DL = drive (if bit 7 is	set both hard disks and	floppy disks reset)
F000:E327		  mov	  ax, 201h
F000:E32A		  mov	  cx, 501h
F000:E32D		  int	  13h				      ;	DISK - READ SECTORS INTO MEMORY
F000:E32D							      ;	AL = number of sectors to read,	CH = track, CL = sector
F000:E32D							      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
F000:E32D							      ;	Return:	CF set on error, AH = status, AL = number of sectors read
F000:E32F		  pop	  cx
F000:E330		  loop	  l20
F000:E332
F000:E332 l21:							      ;	CODE XREF: POST_init_ints_and_more+297j
F000:E332							      ;	POST_init_ints_and_more+29Dj
F000:E332		  mov	  ax, 40h ; '@'
F000:E335		  mov	  ds, ax			      ;	ds = 0x40
F000:E337		  mov	  ax, 7000h
F000:E33A		  mov	  bl, 1
F000:E33C		  int	  15h				      ;	read EEPROM
F000:E33E		  test	  dl, 1
F000:E341		  jz	  short	l22
F000:E343		  mov	  byte ptr ds:p400.monochrome_monitor, 0FFh
F000:E348
F000:E348 l22:							      ;	CODE XREF: POST_init_ints_and_more+2C8j
F000:E348		  test	  dl, 2
F000:E34B		  jz	  short	l23
F000:E34D		  and	  byte ptr ds:p400.installed_hardware, 11001111b ; turn	off video modes	bits
F000:E352		  or	  byte ptr ds:p400.installed_hardware, 10000b ;	initial	video mode = 40x25 color
F000:E357		  xor	  ax, ax
F000:E359		  mov	  es, ax			      ;	es = 0
F000:E35B		  mov	  word ptr es:74h, offset video_6845_init_tbl_tv ; int 1d
F000:E362		  mov	  word ptr es:76h, cs
F000:E367
F000:E367 l23:							      ;	CODE XREF: POST_init_ints_and_more+2D2j
F000:E367		  push	  dx
F000:E368		  mov	  ax, 7000h
F000:E36B		  mov	  bl, 0
F000:E36D		  int	  15h				      ;	read EEPROM
F000:E36F		  mov	  bh, dl
F000:E371		  pop	  dx
F000:E372		  and	  bh, 3
F000:E375		  cmp	  bh, 3
F000:E378		  jz	  short	l24
F000:E37A		  cmp	  bh, 1
F000:E37D		  jz	  short	l26
F000:E37F		  test	  dl, 4
F000:E382		  jz	  short	l26
F000:E384
F000:E384 l24:							      ;	CODE XREF: POST_init_ints_and_more+2FFj
F000:E384		  push	  dx
F000:E385		  mov	  dx, 3F1h
F000:E388		  mov	  al, 6
F000:E38A		  out	  dx, al
F000:E38B		  pop	  dx
F000:E38C		  mov	  al, ds:p400.extra_status
F000:E38F		  and	  al, 3
F000:E391		  ror	  al, 1
F000:E393		  jnb	  short	l25
F000:E395		  or	  al, 2
F000:E397
F000:E397 l25:							      ;	CODE XREF: POST_init_ints_and_more+31Aj
F000:E397		  and	  al, 3
F000:E399		  and	  byte ptr ds:p400.extra_status, 11111100b ; drives A, B are 5 1/4
F000:E39E		  or	  ds:p400.extra_status,	al
F000:E3A2
F000:E3A2 l26:							      ;	CODE XREF: POST_init_ints_and_more+304j
F000:E3A2							      ;	POST_init_ints_and_more+309j
F000:E3A2		  test	  dl, 8
F000:E3A5		  jz	  short	l27
F000:E3A7		  in	  al, 62h			      ;	0-2: Not used
F000:E3A7							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:E3A7							      ;	4: EEPROM data-serial read only
F000:E3A7							      ;	5: 1=Timer 2 channel out
F000:E3A7							      ;	6: Monochrome mode. 0=Color monitor
F000:E3A7							      ;	7: Reserved
F000:E3A9		  and	  al, 11110111b			      ;	switch to 4.77Mhz (slow	mode)
F000:E3AB		  out	  62h, al			      ;	0-2: Not used
F000:E3AB							      ;	3: Fast	Mode: 0=4.77Mhz, 1=7.16Mhz
F000:E3AB							      ;	4: EEPROM data-serial read only
F000:E3AB							      ;	5: 1=Timer 2 channel out
F000:E3AB							      ;	6: Monochrome mode. 0=Color monitor
F000:E3AB							      ;	7: Reserved
F000:E3AD		  and	  byte ptr ds:p400.extra_status, 11110111b ; slow CPU
F000:E3B2
F000:E3B2 l27:							      ;	CODE XREF: POST_init_ints_and_more+32Cj
F000:E3B2		  mov	  ax, 7000h
F000:E3B5		  mov	  bl, 2
F000:E3B7		  int	  15h				      ;	read EEPROM
F000:E3B9		  test	  dh, 11110000b
F000:E3BC		  jz	  short	l30
F000:E3BE		  or	  byte ptr ds:p400.extra_status, 1000000b
F000:E3C3		  mov	  ax, ds:p400.extra_status
F000:E3C6		  and	  ah, 0FEh
F000:E3C9		  test	  byte ptr ds:p400.extra_status, 10b
F000:E3CE		  jz	  short	l28
F000:E3D0		  or	  ah, 1
F000:E3D3
F000:E3D3 l28:							      ;	CODE XREF: POST_init_ints_and_more+355j
F000:E3D3		  or	  al, 2
F000:E3D5		  test	  byte ptr ds:p400.extra_status_2, 1
F000:E3DA		  jnz	  short	l29
F000:E3DC		  and	  al, 0FDh
F000:E3DE
F000:E3DE l29:							      ;	CODE XREF: POST_init_ints_and_more+361j
F000:E3DE		  mov	  ds:p400.extra_status,	ax
F000:E3E1
F000:E3E1 l30:							      ;	CODE XREF: POST_init_ints_and_more+343j
F000:E3E1		  mov	  ax, 7000h
F000:E3E4		  mov	  bl, 3
F000:E3E6		  int	  15h				      ;	read EEPROM
F000:E3E8		  and	  dl, 11000b
F000:E3EB		  cmp	  dl, 10000b
F000:E3EE		  jnz	  short	l32
F000:E3F0		  mov	  ax, 7000h
F000:E3F3		  mov	  bl, 1
F000:E3F5		  int	  15h				      ;	read EEPROM
F000:E3F7		  test	  dl, 1
F000:E3FA		  jz	  short	l31
F000:E3FC		  xor	  ax, ax			      ;	es = 0
F000:E3FE		  mov	  es, ax
F000:E400		  mov	  word ptr es:74h, offset video_6845_init_tbl_b	; int 1dh
F000:E407		  mov	  word ptr es:76h, cs
F000:E40C		  jmp	  short	l32
F000:E40E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E40E
F000:E40E l31:							      ;	CODE XREF: POST_init_ints_and_more+381j
F000:E40E		  test	  dl, 2
F000:E411		  jz	  short	l32
F000:E413		  xor	  ax, ax
F000:E415		  mov	  es, ax			      ;	es = 0
F000:E417		  mov	  word ptr es:74h, offset video_6845_init_tbl_c	; int 1dh
F000:E41E		  mov	  word ptr es:76h, cs
F000:E423		  and	  byte ptr ds:p400.installed_hardware, 11001111b
F000:E428		  or	  byte ptr ds:p400.installed_hardware, 10000b ;	initial	video mode: 40x25 color
F000:E42D
F000:E42D l32:							      ;	CODE XREF: POST_init_ints_and_more+375j
F000:E42D							      ;	POST_init_ints_and_more+393j
F000:E42D							      ;	POST_init_ints_and_more+398j
F000:E42D		  xor	  ax, ax
F000:E42F		  mov	  bx, ds:p400.installed_hardware      ;	installed hardware
F000:E433		  and	  bx, 110000b
F000:E437		  mov	  al, 7				      ;	monochrome 80x25 text mode
F000:E439		  cmp	  bl, 110000b			      ;	is 80x25 mono ?
F000:E43C		  jz	  short	l33
F000:E43E		  mov	  al, 3				      ;	color 80x25 text mode
F000:E440		  cmp	  bl, 100000b			      ;	is 80x25 color ?
F000:E443		  jz	  short	l33
F000:E445		  mov	  al, 1
F000:E447
F000:E447 l33:							      ;	CODE XREF: POST_init_ints_and_more+3C3j
F000:E447							      ;	POST_init_ints_and_more+3CAj
F000:E447		  int	  10h				      ;	- VIDEO	- SET VIDEO MODE
F000:E447							      ;	AL = mode
F000:E449		  mov	  al, 0BCh ; '¼'
F000:E44B		  out	  21h, al			      ;	Interrupt controller, 8259A.
F000:E44D		  mov	  si, offset aBiosRomVersion02_00_00Compatibilit ; "BIOS ROM version 02.00.00\r\nCompatibilit"...
F000:E450		  call	  print_on_screen
F000:E453		  mov	  ax, 7000h
F000:E456		  mov	  bl, 0
F000:E458		  int	  15h				      ;	read EEPROM
F000:E45A		  mov	  cx, dx
F000:E45C		  and	  dl, 0FCh
F000:E45F		  mov	  al, 1
F000:E461		  int	  15h				      ;	write EEPROM
F000:E463		  test	  cl, 1
F000:E466		  jz	  short	l35
F000:E468		  mov	  al, 4
F000:E46A		  test	  cl, 2
F000:E46D		  jz	  short	l34
F000:E46F		  mov	  al, 6
F000:E471
F000:E471 l34:							      ;	CODE XREF: POST_init_ints_and_more+3F4j
F000:E471		  mov	  dx, 3F1h
F000:E474		  out	  dx, al
F000:E475		  jmp	  short	l36
F000:E477 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E477
F000:E477 l35:							      ;	CODE XREF: POST_init_ints_and_more+3EDj
F000:E477		  mov	  ax, 7000h
F000:E47A		  mov	  bl, 1
F000:E47C		  int	  15h				      ;	read EEPROM
F000:E47E		  test	  dx, 10h
F000:E482		  jz	  short	l36
F000:E484		  int	  18h				      ;	TRANSFER TO ROM	BASIC
F000:E484							      ;	causes transfer	to ROM-based BASIC (IBM-PC)
F000:E484							      ;	often reboots a	compatible; often has no effect	at all
F000:E486
F000:E486 l36:							      ;	CODE XREF: POST_init_ints_and_more+3FCj
F000:E486							      ;	POST_init_ints_and_more+409j
F000:E486		  int	  19h				      ;	DISK BOOT
F000:E486							      ;	causes reboot of disk system
F000:E488		  jmp	  POST_entry
F000:E488 POST_init_ints_and_more endp
F000:E488
F000:E48B
F000:E48B ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E48B
F000:E48B ;	Entry:
F000:E48B ;	    DS:SI = source
F000:E48B ;	    ES:DI = destination
F000:E48B
F000:E48B copy_to_vector_tbl proc near				      ;	CODE XREF: POST_init_ints_and_more+5Ap
F000:E48B							      ;	POST_init_ints_and_more+66p
F000:E48B							      ;	POST_init_ints_and_more+72p
F000:E48B							      ;	copy_to_vector_tbl+2j
F000:E48B		  movsw					      ;	di++, si++
F000:E48C		  stosw					      ;	di++
F000:E48D		  loop	  copy_to_vector_tbl
F000:E48F		  retn
F000:E48F copy_to_vector_tbl endp
F000:E48F
F000:E490
F000:E490 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E490
F000:E490
F000:E490 int_18_handler  proc near				      ;	DATA XREF: F000:FF13o
F000:E490		  add	  sp, 6
F000:E493
F000:E493 loop:							      ;	CODE XREF: int_18_handler+Fj
F000:E493		  mov	  si, offset aInsertSystemDisketteAndSt	; "\n\rInsert System Diskette and\n\rStrike an"...
F000:E496		  call	  print_on_screen
F000:E499		  xor	  ah, ah
F000:E49B		  int	  16h				      ;	KEYBOARD - READ	CHAR FROM BUFFER, WAIT IF EMPTY
F000:E49B							      ;	Return:	AH = scan code,	AL = character
F000:E49D		  int	  19h				      ;	DISK BOOT
F000:E49D							      ;	causes reboot of disk system
F000:E49F		  jmp	  short	loop
F000:E49F int_18_handler  endp
F000:E49F
F000:E49F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E4A1 aInsertSystemDisketteAndSt db	0Ah			      ;	DATA XREF: int_18_handler:loopo
F000:E4A1		  db 0Dh,'Insert System Diskette and',0Ah
F000:E4A1		  db 0Dh,'Strike any key when ready',0Ah
F000:E4A1		  db 0Dh,'$'
F000:E4DB
F000:E4DB ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E4DB
F000:E4DB ;	Entry:
F000:E4DB ;	    SI = pointer to the	string to print. '$' terminated
F000:E4DB
F000:E4DB print_on_screen proc near				      ;	CODE XREF: POST_init_ints_and_more+3D7p
F000:E4DB							      ;	int_18_handler+6p
F000:E4DB							      ;	print_on_screen+10j
F000:E4DB		  mov	  al, cs:[si]
F000:E4DE		  cmp	  al, 24h ; '$'                       ; strings are '$' terminated
F000:E4E0		  jz	  short	exit
F000:E4E2		  push	  si
F000:E4E3		  mov	  ah, 0Eh
F000:E4E5		  mov	  bl, 7
F000:E4E7		  int	  10h				      ;	- VIDEO	- WRITE	CHARACTER AND ADVANCE CURSOR (TTY WRITE)
F000:E4E7							      ;	AL = character,	BH = display page (alpha modes)
F000:E4E7							      ;	BL = foreground	color (graphics	modes)
F000:E4E9		  pop	  si
F000:E4EA		  inc	  si
F000:E4EB		  jmp	  short	print_on_screen
F000:E4ED ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E4ED
F000:E4ED exit:							      ;	CODE XREF: print_on_screen+5j
F000:E4ED		  retn
F000:E4ED print_on_screen endp
F000:E4ED
F000:E4EE
F000:E4EE ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E4EE
F000:E4EE
F000:E4EE int_ack_handler proc far				      ;	DATA XREF: F000:FEF7o
F000:E4EE							      ;	F000:FEF9o F000:FEFBo
F000:E4EE							      ;	F000:FEFDo ...
F000:E4EE		  push	  ax				      ;	used by	other interrupts as well: 0xa, 0xb, 0xd, 0xd and 0xf
F000:E4EF		  push	  ds
F000:E4F0		  mov	  ax, 40h ; '@'
F000:E4F3		  mov	  ds, ax			      ;	ds = 40h
F000:E4F5		  mov	  al, 0Bh
F000:E4F7		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:E4F9		  in	  al, 20h			      ;	Interrupt controller, 8259A.
F000:E4FB		  or	  al, al
F000:E4FD		  jz	  short	l0
F000:E4FF		  mov	  ah, al
F000:E501		  in	  al, 21h			      ;	Interrupt controller, 8259A.
F000:E503		  or	  al, ah
F000:E505		  out	  21h, al			      ;	Interrupt controller, 8259A.
F000:E507		  mov	  al, 20h ; ' '
F000:E509		  out	  20h, al			      ;	Interrupt controller, 8259A.
F000:E50B		  jmp	  short	l1
F000:E50D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E50D
F000:E50D l0:							      ;	CODE XREF: int_ack_handler+Fj
F000:E50D		  mov	  ah, 0FFh
F000:E50F
F000:E50F l1:							      ;	CODE XREF: int_ack_handler+1Dj
F000:E50F		  mov	  ds:p400.POST_last_unexpected_int, ah
F000:E513		  pop	  ds
F000:E514		  pop	  ax
F000:E515		  iret
F000:E515 int_ack_handler endp
F000:E515
F000:E516
F000:E516 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E516
F000:E516
F000:E516 run_boot_sector_if_valid proc	near			      ;	CODE XREF: POST_init_ints_and_more+ECp
F000:E516							      ;	POST_init_ints_and_more+28Ep
F000:E516							      ;	run_boot_sector_if_valid+3Bj
F000:E516		  xor	  si, si
F000:E518		  cmp	  word ptr [si], 0AA55h		      ;	valid boot / cartridge ROM ?
F000:E51C		  jnz	  short	l2
F000:E51E		  push	  cx
F000:E51F		  mov	  cl, 0
F000:E521		  mov	  ch, [si+2]			      ;	length
F000:E524		  add	  cx, cx			      ;	length * 2
F000:E526		  mov	  al, 0
F000:E528
F000:E528 l0:							      ;	CODE XREF: run_boot_sector_if_valid+15j
F000:E528		  add	  al, [si]
F000:E52A		  inc	  si
F000:E52B		  loop	  l0				      ;	calculate checksum ?
F000:E52D		  or	  al, al
F000:E52F		  jnz	  short	l1
F000:E531		  mov	  ax, 40h ; '@'
F000:E534		  mov	  es, ax			      ;	es = 40h
F000:E536		  mov	  word ptr es:p400.POST_entry_point_offset, 3 ;	POST re-entry after certain resets
F000:E53D		  mov	  word ptr es:p400.POST_entry_point_seg, ds ; c800 / c000 : 0003: ROM cartridge	address
F000:E542		  push	  ds
F000:E543		  call	  dword	ptr es:p400.POST_entry_point_offset
F000:E548		  pop	  ds
F000:E549
F000:E549 l1:							      ;	CODE XREF: run_boot_sector_if_valid+19j
F000:E549		  pop	  cx
F000:E54A
F000:E54A l2:							      ;	CODE XREF: run_boot_sector_if_valid+6j
F000:E54A		  mov	  ax, ds
F000:E54C		  add	  ax, 80h ; '€'
F000:E54F		  mov	  ds, ax			      ;	ds += 80h (go to next block of 0x8000)
F000:E551		  loop	  run_boot_sector_if_valid
F000:E553		  retn
F000:E553 run_boot_sector_if_valid endp
F000:E553
F000:E553 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E554 aByLsd	  db 'by LSD'                                 ; Tandy developer signature?
F000:E55A
F000:E55A ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E55A
F000:E55A
F000:E55A video_init_palette proc near				      ;	CODE XREF: int_10_00_handler+1B9p
F000:E55A		  mov	  bl, 10h			      ;	palette	register
F000:E55C		  mov	  cx, 10h			      ;	number of colors
F000:E55F		  mov	  dx, 3DAh
F000:E562		  xor	  ah, ah
F000:E564
F000:E564 l0:							      ;	CODE XREF: video_init_palette+1Aj
F000:E564		  mov	  al, bl
F000:E566		  out	  dx, al			      ;	0x3da: select register (palette	register)
F000:E567		  add	  dx, 4
F000:E56A		  mov	  al, ah
F000:E56C		  out	  dx, al			      ;	0x3de: palette
F000:E56D		  inc	  bl				      ;	palette	idx 0 =	color 0
F000:E56D							      ;	palette	idx 1 =	color 1
F000:E56D							      ;	...
F000:E56F		  inc	  ah
F000:E571		  sub	  dx, 4
F000:E574		  loop	  l0
F000:E576		  cmp	  byte ptr ds:p400.crt_mode, 0Ah      ;	640x200	4 colors mode ?
F000:E57B		  jnz	  short	skip_redefine_colors
F000:E57D		  mov	  al, 11h			      ;	select palette idx 1
F000:E57F		  out	  dx, al			      ;	3da
F000:E580		  mov	  al, 3
F000:E582		  add	  dx, 4
F000:E585		  out	  dx, al			      ;	palette	idx 1 =	color 3
F000:E586		  sub	  dx, 4
F000:E589		  mov	  al, 12h			      ;	select palette idx 2
F000:E58B		  out	  dx, al			      ;	Video: bits 0-1	control
F000:E58B							      ;	Feature	Control	outputs	FC0 and	FC1
F000:E58C		  mov	  al, 5				      ;	color 5
F000:E58E		  add	  dx, 4
F000:E591		  out	  dx, al			      ;	palette	idx 2 =	color 5
F000:E592		  sub	  dx, 4
F000:E595		  mov	  al, 13h			      ;	select palette idx 3
F000:E597		  out	  dx, al			      ;	Video: bits 0-1	control
F000:E597							      ;	Feature	Control	outputs	FC0 and	FC1
F000:E598		  mov	  al, 0Fh			      ;	color f
F000:E59A		  add	  dx, 4
F000:E59D		  out	  dx, al			      ;	palette	idx 3 =	color 0xf
F000:E59E		  sub	  dx, 4
F000:E5A1
F000:E5A1 skip_redefine_colors:					      ;	CODE XREF: video_init_palette+21j
F000:E5A1		  mov	  al, 1
F000:E5A3		  out	  dx, al			      ;	select palette mask
F000:E5A4		  add	  dx, 4
F000:E5A7		  mov	  al, 0Fh
F000:E5A9		  out	  dx, al			      ;	mask for palette = 0xf (no mask)
F000:E5AA		  sub	  dx, 4
F000:E5AD		  mov	  al, 2
F000:E5AF		  out	  dx, al			      ;	select border color
F000:E5B0		  add	  dx, 4
F000:E5B3		  xor	  al, al
F000:E5B5		  out	  dx, al			      ;	color is 0 for border
F000:E5B6		  sub	  dx, 4
F000:E5B9		  mov	  al, 3				      ;	select mode control
F000:E5BB		  out	  dx, al			      ;	Video: bits 0-1	control
F000:E5BB							      ;	Feature	Control	outputs	FC0 and	FC1
F000:E5BC		  add	  dx, 4
F000:E5BF		  mov	  al, 0				      ;	modes 0-6: no border color, nothing
F000:E5C1		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:E5C6		  jle	  short	l1
F000:E5C8		  mov	  al, 100b			      ;	mode >=	8: enable border color
F000:E5CA		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:E5CF		  jnz	  short	l1
F000:E5D1		  mov	  al, 10100b			      ;	mode 8:	enables	border color + 16 color	mode
F000:E5D3		  jmp	  short	l3
F000:E5D5 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E5D5
F000:E5D5 l1:							      ;	CODE XREF: video_init_palette+6Cj
F000:E5D5							      ;	video_init_palette+75j
F000:E5D5		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:E5DA		  jnz	  short	l2
F000:E5DC		  mov	  al, 10100b			      ;	mode 9:	enables	border color + 16 color	mode
F000:E5DE		  jmp	  short	l3
F000:E5E0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E5E0
F000:E5E0 l2:							      ;	CODE XREF: video_init_palette+80j
F000:E5E0		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:E5E5		  jnz	  short	l3
F000:E5E7		  mov	  al, 1100b			      ;	mode a:	enables	border color + 640x200 4 color mode
F000:E5E9
F000:E5E9 l3:							      ;	CODE XREF: video_init_palette+79j
F000:E5E9							      ;	video_init_palette+84j
F000:E5E9							      ;	video_init_palette+8Bj
F000:E5E9		  out	  dx, al
F000:E5EA		  cmp	  byte ptr ds:p400.monochrome_monitor, 0FFh ; monochrome installed?
F000:E5EF		  jnz	  short	l5			      ;	skip if	not installed (means internal color video)
F000:E5F1		  mov	  ah, 10h			      ;	palette	registers
F000:E5F3		  mov	  si, offset tbl_3de_mono_palette_values
F000:E5F6		  mov	  cx, 10h
F000:E5F9		  nop
F000:E5FA		  mov	  dx, 3DAh
F000:E5FD
F000:E5FD l4:							      ;	CODE XREF: video_init_palette+B3j
F000:E5FD		  mov	  al, ah
F000:E5FF		  out	  dx, al			      ;	Video: bits 0-1	control
F000:E5FF							      ;	Feature	Control	outputs	FC0 and	FC1
F000:E600		  add	  dx, 4
F000:E603		  mov	  al, cs:[si]
F000:E606		  out	  dx, al
F000:E607		  sub	  dx, 4
F000:E60A		  inc	  si
F000:E60B		  inc	  ah
F000:E60D		  loop	  l4
F000:E60F
F000:E60F l5:							      ;	CODE XREF: video_init_palette+95j
F000:E60F		  mov	  dx, 3DAh
F000:E612		  xor	  al, al
F000:E614		  out	  dx, al			      ;	3da = 0? reset ?
F000:E615		  retn
F000:E615 video_init_palette endp
F000:E615
F000:E616
F000:E616 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E616
F000:E616 ;	Entry:
F000:E616 ;	    bl = palette idx to	set (0-15)
F000:E616 ;	    bh = color
F000:E616
F000:E616 set_palette_color proc near				      ;	CODE XREF: int_10_0b_handler+26p
F000:E616							      ;	int_10_0b_handler+78p
F000:E616							      ;	int_10_0b_handler+7Ep
F000:E616							      ;	int_10_0b_handler+84p ...
F000:E616		  mov	  dx, 3DAh
F000:E619		  mov	  al, bl
F000:E61B		  cmp	  al, 10h
F000:E61D		  jnb	  short	error
F000:E61F		  push	  ax
F000:E620		  push	  dx
F000:E621		  mov	  dx, 3DAh
F000:E624
F000:E624 wait_retrace_finish:					      ;	CODE XREF: set_palette_color+11j
F000:E624		  in	  al, dx			      ;	Video status bits:
F000:E624							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:E624							      ;	1: 1=light pen is triggered; 0=armed
F000:E624							      ;	2: 1=light pen switch is open; 0=closed
F000:E624							      ;	3: 1=vertical sync pulse is occurring.
F000:E625		  test	  al, 8
F000:E627		  jnz	  short	wait_retrace_finish
F000:E629		  cli
F000:E62A
F000:E62A wait_retrace_start:					      ;	CODE XREF: set_palette_color+17j
F000:E62A		  in	  al, dx			      ;	Video status bits:
F000:E62A							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:E62A							      ;	1: 1=light pen is triggered; 0=armed
F000:E62A							      ;	2: 1=light pen switch is open; 0=closed
F000:E62A							      ;	3: 1=vertical sync pulse is occurring.
F000:E62B		  test	  al, 8
F000:E62D		  jz	  short	wait_retrace_start
F000:E62F		  pop	  dx
F000:E630		  pop	  ax
F000:E631		  add	  al, 10h			      ;	al = palette color idx + 10h
F000:E633		  out	  dx, al			      ;	out 3da, 10h + palette_idx
F000:E634		  add	  dx, 4
F000:E637		  mov	  al, bh
F000:E639		  out	  dx, al			      ;	out 3de, color_value
F000:E63A		  sti
F000:E63B		  clc
F000:E63C		  retn
F000:E63D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E63D
F000:E63D error:						      ;	CODE XREF: set_palette_color+7j
F000:E63D		  stc
F000:E63E		  retn
F000:E63E set_palette_color endp
F000:E63E
F000:E63F
F000:E63F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E63F
F000:E63F ; Entry:
F000:E63F ;    bh = 1st	register to select
F000:E63F ;    ch = value for 1st register
F000:E63F ;    bl = 2nd	register to select
F000:E63F ;    cl = value for 2nd register
F000:E63F
F000:E63F set_pair_value_in_6845 proc near			      ;	CODE XREF: int_10_01_handler+4p
F000:E63F							      ;	update_cursor_offset+17j
F000:E63F							      ;	int_10_05_handler+27p
F000:E63F		  mov	  dx, ds:p400.addr_6845		      ;	either 3d4 (color) or 3b4 (mono)
F000:E643		  mov	  al, bh			      ;	bh = register to set
F000:E645		  out	  dx, al
F000:E646		  inc	  dx
F000:E647		  mov	  al, ch			      ;	ch = value for register	bh
F000:E649		  out	  dx, al
F000:E64A		  dec	  dx
F000:E64B		  mov	  al, bl			      ;	bl = register to set
F000:E64D		  out	  dx, al
F000:E64E		  inc	  dx
F000:E64F		  mov	  al, cl			      ;	cl = value for register	bl
F000:E651		  out	  dx, al
F000:E652		  retn
F000:E652 set_pair_value_in_6845 endp
F000:E652
F000:E653
F000:E653 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E653
F000:E653 ;	Entry:
F000:E653 ;	    cx = horizontal position
F000:E653 ;	    dx = vertical position
F000:E653 ;	    bh = display page number
F000:E653 ;
F000:E653 ;	Returns:
F000:E653 ;	    ah = bits for mask ?
F000:E653 ;	    bx = pixel address
F000:E653 ;	    cx = horizontal byte offset
F000:E653 ;	    dx = mask
F000:E653 ;	    carry = clear: Ok. set: error
F000:E653 ;
F000:E653
F000:E653 get_pixel_addr_and_mask proc near			      ;	CODE XREF: int_10_0c_handlerp
F000:E653							      ;	int_10_0d_handlerp
F000:E653		  push	  ax
F000:E654		  mov	  ax, 0B000h
F000:E657		  mov	  es, ax			      ;	es = b000h (mono segment)
F000:E659		  pop	  ax
F000:E65A		  cmp	  dx, 199			      ;	vertical position of the pixel
F000:E65E		  ja	  short	error
F000:E660		  mov	  ah, ds:p400.crt_mode		      ;	current	video mode
F000:E664		  cmp	  ah, 4				      ;	320x200x4?
F000:E667		  jz	  short	test_320_200_mode
F000:E669		  cmp	  ah, 5				      ;	320x200x4 gray?
F000:E66C		  jz	  short	test_320_200_mode
F000:E66E		  cmp	  ah, 6				      ;	640x200x2?
F000:E671		  jz	  short	test_640_200_mode
F000:E673		  cmp	  ah, 8				      ;	160x200x16?
F000:E676		  jz	  short	test_160_200_mode
F000:E678		  cmp	  ah, 9				      ;	320x200x16?
F000:E67B		  jz	  short	test_320_200_mode
F000:E67D		  cmp	  ah, 0Ah			      ;	640x200x4?
F000:E680		  jz	  short	test_640_200_mode
F000:E682
F000:E682 error:						      ;	CODE XREF: get_pixel_addr_and_mask+Bj
F000:E682							      ;	get_pixel_addr_and_mask+36j
F000:E682							      ;	get_pixel_addr_and_mask+3Ej
F000:E682							      ;	get_pixel_addr_and_mask+4Ej
F000:E682		  stc
F000:E683		  jmp	  short	exit
F000:E685 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E685
F000:E685 test_160_200_mode:					      ;	CODE XREF: get_pixel_addr_and_mask+23j
F000:E685		  cmp	  cx, 159			      ;	horizontal: not	>= 160,	else error
F000:E689		  ja	  short	error
F000:E68B		  jmp	  short	s0
F000:E68D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E68D
F000:E68D test_320_200_mode:					      ;	CODE XREF: get_pixel_addr_and_mask+14j
F000:E68D							      ;	get_pixel_addr_and_mask+19j
F000:E68D							      ;	get_pixel_addr_and_mask+28j
F000:E68D		  cmp	  cx, 319			      ;	horizontal: not	>= 320,	else error
F000:E691		  ja	  short	error
F000:E693
F000:E693 s0:							      ;	CODE XREF: get_pixel_addr_and_mask+38j
F000:E693		  call	  get_address_for_pixel
F000:E696		  mov	  ah, 3				      ;	mask. value is 2 LSB bits
F000:E698		  mov	  dx, 1111110000000011b
F000:E69B		  jmp	  short	exit_ok
F000:E69D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E69D
F000:E69D test_640_200_mode:					      ;	CODE XREF: get_pixel_addr_and_mask+1Ej
F000:E69D							      ;	get_pixel_addr_and_mask+2Dj
F000:E69D		  cmp	  cx, 639			      ;	horizontal: not	>= 640,	else error
F000:E6A1		  ja	  short	error
F000:E6A3		  call	  get_address_for_pixel
F000:E6A6		  mov	  ah, 1				      ;	mask. value is 1 LSB bit
F000:E6A8		  mov	  dx, 1111111000000001b
F000:E6AB
F000:E6AB exit_ok:						      ;	CODE XREF: get_pixel_addr_and_mask+48j
F000:E6AB		  clc
F000:E6AC
F000:E6AC exit:							      ;	CODE XREF: get_pixel_addr_and_mask+30j
F000:E6AC		  retn
F000:E6AC get_pixel_addr_and_mask endp
F000:E6AC
F000:E6AC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E6AD tbl_3de_mono_palette_values db    0			      ;	DATA XREF: video_init_palette+99o
F000:E6AD							      ;	value for 03deh	when 03dah=0
F000:E6AE		  db	7				      ;	value for 03deh	when 03dah=1
F000:E6AF		  db	7				      ;	value for 03deh	when 03dah=2
F000:E6B0		  db	7				      ;	value for 03deh	when 03dah=3
F000:E6B1		  db	7				      ;	value for 03deh	when 03dah=4
F000:E6B2		  db	7				      ;	value for 03deh	when 03dah=5
F000:E6B3		  db	7				      ;	value for 03deh	when 03dah=6
F000:E6B4		  db	7				      ;	value for 03deh	when 03dah=7
F000:E6B5		  db	8				      ;	value for 03deh	when 03dah=8
F000:E6B6		  db  0Fh				      ;	value for 03deh	when 03dah=9
F000:E6B7		  db  0Fh				      ;	value for 03deh	when 03dah=a
F000:E6B8		  db  0Fh				      ;	value for 03deh	when 03dah=b
F000:E6B9		  db  0Fh				      ;	value for 03deh	when 03dah=c
F000:E6BA		  db  0Fh				      ;	value for 03deh	when 03dah=d
F000:E6BB		  db  0Fh				      ;	value for 03deh	when 03dah=e
F000:E6BC		  db  0Fh				      ;	value for 03deh	when 03dah=f
F000:E6BD		  db 35h dup(0FFh)
F000:E6F2
F000:E6F2 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E6F2
F000:E6F2
F000:E6F2 int_19_handler  proc near				      ;	DATA XREF: F000:FF15o
F000:E6F2		  add	  sp, 6
F000:E6F5
F000:E6F5 l0:							      ;	CODE XREF: int_19_handler+29j
F000:E6F5		  mov	  cx, 5
F000:E6F8
F000:E6F8 l1:							      ;	CODE XREF: int_19_handler+25j
F000:E6F8		  sti
F000:E6F9		  push	  cx
F000:E6FA		  mov	  ah, 0
F000:E6FC		  mov	  dl, 0
F000:E6FE		  int	  13h				      ;	DISK - RESET DISK SYSTEM
F000:E6FE							      ;	DL = drive (if bit 7 is	set both hard disks and	floppy disks reset)
F000:E700		  mov	  ax, 201h
F000:E703		  les	  bx, cs:addr_for_booting_code	      ;	buffer in 0000:7c00
F000:E708		  mov	  cx, 1
F000:E70B		  xor	  dx, dx
F000:E70D		  int	  13h				      ;	DISK - READ SECTORS INTO MEMORY
F000:E70D							      ;	AL = number of sectors to read,	CH = track, CL = sector
F000:E70D							      ;	DH = head, DL =	drive, ES:BX ->	buffer to fill
F000:E70D							      ;	Return:	CF set on error, AH = status, AL = number of sectors read
F000:E70F		  pop	  cx
F000:E710		  jnb	  short	l3
F000:E712		  cmp	  ah, 80h ; '€'
F000:E715		  jz	  short	l2
F000:E717		  loop	  l1
F000:E719
F000:E719 l2:							      ;	CODE XREF: int_19_handler+23j
F000:E719		  int	  18h				      ;	TRANSFER TO ROM	BASIC
F000:E719							      ;	causes transfer	to ROM-based BASIC (IBM-PC)
F000:E719							      ;	often reboots a	compatible; often has no effect	at all
F000:E71B		  jmp	  short	l0
F000:E71D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E71D
F000:E71D l3:							      ;	CODE XREF: int_19_handler+1Ej
F000:E71D		  jmp	  cs:addr_for_booting_code
F000:E71D int_19_handler  endp
F000:E71D
F000:E71D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E722 addr_for_booting_code	dd 7C00h			      ;	DATA XREF: int_19_handler+11r
F000:E722							      ;	int_19_handler:l3r
F000:E726		  db 3 dup(0FFh)
F000:E729 comm_parameters dw 417h				      ;	DATA XREF: int_14_00_handler+15r
F000:E72B		  dw 300h
F000:E72D		  dw 180h
F000:E72F		  dw 0C0h
F000:E731		  dw 60h
F000:E733		  dw 30h
F000:E735		  dw 18h
F000:E737		  dw 0Ch
F000:E739
F000:E739 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E739
F000:E739
F000:E739 int_14_handler  proc far				      ;	DATA XREF: F000:FF0Bo
F000:E739		  call	  int_push_regs
F000:E73C		  mov	  di, 8
F000:E73F		  nop
F000:E740		  call	  convert_ah_to_di_idx
F000:E743		  jb	  short	error
F000:E745		  mov	  bx, dx
F000:E747		  xor	  cx, cx
F000:E749		  mov	  cl, [bx+p400.comm_0_timeout]	      ;	comm timeout
F000:E74D		  shl	  bx, 1
F000:E74F		  mov	  dx, [bx+p400.comm_0_base_addr]      ;	comm address
F000:E753		  or	  dx, dx
F000:E755		  jnz	  short	jump_to_subsrv
F000:E757		  xor	  ah, ah
F000:E759		  jmp	  int_14_pop_and_iret
F000:E75C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E75C
F000:E75C jump_to_subsrv:					      ;	CODE XREF: int_14_handler+1Cj
F000:E75C		  jmp	  word ptr cs:jump_table[di]
F000:E75C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E761 jump_table:						      ;	DATA XREF: int_14_handler:jump_to_subsrvr
F000:E761		  dw offset int_14_00_handler
F000:E763		  dw offset int_14_01_handler
F000:E765		  dw offset int_14_02_handler
F000:E767		  dw offset int_14_03_handler
F000:E769 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E769
F000:E769 error:						      ;	CODE XREF: int_14_handler+Aj
F000:E769		  jmp	  int_14_pop_and_iret
F000:E769 int_14_handler  endp
F000:E769
F000:E76C
F000:E76C ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E76C
F000:E76C ;	Initializes the	baud rate, parity, stop-bit, and word length
F000:E76C ;	parameters for a serial	port, and returns the status for the port.
F000:E76C ;
F000:E76C ;	   On entry:	  AH	     00h
F000:E76C ;			  AL	     Communications parameters
F000:E76C ;			  DX	     Serial port number	(0 - COM1, 1 - COM2, etc.)
F000:E76C ;
F000:E76C ;	   Returns:	  AX	     Line and modem status (see	Service	03h)
F000:E76C ;
F000:E76C
F000:E76C int_14_00_handler proc far				      ;	CODE XREF: int_14_handler:jump_to_subsrvj
F000:E76C							      ;	DATA XREF: int_14_handler:jump_tableo
F000:E76C		  mov	  ah, al
F000:E76E		  mov	  al, 80h ; '€'
F000:E770		  add	  dx, 3
F000:E773		  out	  dx, al			      ;	out comm_addr+3, ??
F000:E774		  dec	  dx
F000:E775		  dec	  dx
F000:E776		  mov	  bl, ah
F000:E778		  and	  bl, 0E0h
F000:E77B		  mov	  cl, 4
F000:E77D		  shr	  bl, cl
F000:E77F		  xor	  bh, bh
F000:E781		  mov	  cx, cs:comm_parameters[bx]
F000:E786		  mov	  al, ch
F000:E788		  out	  dx, al			      ;	out comm_addr+1, ??
F000:E789		  mov	  al, cl
F000:E78B		  dec	  dx
F000:E78C		  out	  dx, al			      ;	out comm_addr, ??
F000:E78D		  mov	  al, ah
F000:E78F		  and	  al, 1Fh
F000:E791		  add	  dx, 3
F000:E794		  out	  dx, al			      ;	out comm_addr+3, ??
F000:E795		  sub	  dx, 3
F000:E798		  inc	  dx
F000:E799		  xor	  al, al
F000:E79B		  out	  dx, al			      ;	out comm_addr+1, ??
F000:E79C		  dec	  dx
F000:E79D		  jmp	  near ptr int_14_03_handler
F000:E79D int_14_00_handler endp
F000:E79D
F000:E7A0
F000:E7A0 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E7A0
F000:E7A0 ;
F000:E7A0 ;	Sends one character to the specified serial port.
F000:E7A0 ;
F000:E7A0 ;	   On entry:	  AH	     01h
F000:E7A0 ;			  AL	     Character
F000:E7A0 ;			  DX	     Serial port number	(0 - COM1, 1 - COM2, etc.)
F000:E7A0 ;
F000:E7A0 ;	   Returns:	  AH	     Line status (see Service 03h)
F000:E7A0
F000:E7A0 int_14_01_handler proc far				      ;	CODE XREF: int_14_handler:jump_to_subsrvj
F000:E7A0							      ;	DATA XREF: int_14_handler+2Ao
F000:E7A0		  mov	  ah, al
F000:E7A2		  mov	  al, 3
F000:E7A4		  add	  dx, 4
F000:E7A7		  out	  dx, al
F000:E7A8		  inc	  dx
F000:E7A9		  inc	  dx
F000:E7AA		  xor	  bx, bx
F000:E7AC
F000:E7AC l0:							      ;	CODE XREF: int_14_01_handler+2Dj
F000:E7AC							      ;	int_14_01_handler+2Fj
F000:E7AC		  in	  al, dx
F000:E7AD		  test	  al, 30h
F000:E7AF		  jz	  short	l3
F000:E7B1		  xor	  bx, bx
F000:E7B3		  dec	  dx
F000:E7B4
F000:E7B4 l1:							      ;	CODE XREF: int_14_01_handler+1Aj
F000:E7B4							      ;	int_14_01_handler+1Cj
F000:E7B4		  in	  al, dx
F000:E7B5		  test	  al, 20h
F000:E7B7		  jnz	  short	l2
F000:E7B9		  dec	  bx
F000:E7BA		  jnz	  short	l1
F000:E7BC		  loop	  l1
F000:E7BE		  jmp	  short	l4
F000:E7C0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E7C0
F000:E7C0 l2:							      ;	CODE XREF: int_14_01_handler+17j
F000:E7C0		  sub	  dx, 5
F000:E7C3		  mov	  al, ah
F000:E7C5		  out	  dx, al
F000:E7C6		  xchg	  ah, al
F000:E7C8		  xor	  ah, ah
F000:E7CA		  jmp	  short	int_14_pop_and_iret
F000:E7CC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E7CC
F000:E7CC l3:							      ;	CODE XREF: int_14_01_handler+Fj
F000:E7CC		  dec	  bx
F000:E7CD		  jnz	  short	l0
F000:E7CF		  loop	  l0
F000:E7D1		  dec	  dx
F000:E7D2
F000:E7D2 l4:							      ;	CODE XREF: int_14_01_handler+1Ej
F000:E7D2		  in	  al, dx
F000:E7D3		  or	  al, 80h
F000:E7D5		  xchg	  ah, al
F000:E7D7		  and	  ah, 9Eh
F000:E7DA		  jmp	  short	int_14_pop_and_iret
F000:E7DA int_14_01_handler endp
F000:E7DA
F000:E7DC
F000:E7DC ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E7DC
F000:E7DC ;
F000:E7DC ;	Receives one character at the specified	serial port.
F000:E7DC ;
F000:E7DC ;	   On entry:	  AH	     02h
F000:E7DC ;			  DX	     Serial port number	(0 - COM1, 1 - COM2, etc.)
F000:E7DC ;
F000:E7DC ;	   Returns:	  AL	     Character
F000:E7DC ;			  AH	     Line status (See service 03h)
F000:E7DC ;
F000:E7DC
F000:E7DC int_14_02_handler proc far				      ;	CODE XREF: int_14_handler:jump_to_subsrvj
F000:E7DC							      ;	DATA XREF: int_14_handler+2Co
F000:E7DC		  mov	  al, 1
F000:E7DE		  add	  dx, 4
F000:E7E1		  out	  dx, al
F000:E7E2		  sub	  dx, 4
F000:E7E5		  xor	  bx, bx
F000:E7E7
F000:E7E7 l0:							      ;	CODE XREF: int_14_02_handler+17j
F000:E7E7							      ;	int_14_02_handler+19j
F000:E7E7		  add	  dx, 6
F000:E7EA		  in	  al, dx
F000:E7EB		  sub	  dx, 6
F000:E7EE		  test	  al, 20h
F000:E7F0		  jnz	  short	l1
F000:E7F2		  dec	  bx
F000:E7F3		  jnz	  short	l0
F000:E7F5		  loop	  l0
F000:E7F7		  jmp	  short	l4
F000:E7F9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E7F9
F000:E7F9 l1:							      ;	CODE XREF: int_14_02_handler+14j
F000:E7F9		  xor	  bx, bx
F000:E7FB
F000:E7FB l2:							      ;	CODE XREF: int_14_02_handler+33j
F000:E7FB							      ;	int_14_02_handler+35j
F000:E7FB		  add	  dx, 5
F000:E7FE		  in	  al, dx
F000:E7FF		  sub	  dx, 5
F000:E802		  test	  al, 1
F000:E804		  jz	  short	l3
F000:E806		  mov	  ah, al
F000:E808		  and	  ah, 1Eh
F000:E80B		  in	  al, dx
F000:E80C		  jmp	  short	int_14_pop_and_iret
F000:E80E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E80E
F000:E80E l3:							      ;	CODE XREF: int_14_02_handler+28j
F000:E80E		  dec	  bx
F000:E80F		  jnz	  short	l2
F000:E811		  loop	  l2
F000:E813
F000:E813 l4:							      ;	CODE XREF: int_14_02_handler+1Bj
F000:E813		  xor	  ah, ah
F000:E815		  add	  dx, 5
F000:E818		  in	  al, dx
F000:E819		  or	  al, 80h
F000:E81B		  xchg	  ah, al
F000:E81D		  or	  ah, 9Eh
F000:E820		  jmp	  short	int_14_pop_and_iret
F000:E820 int_14_02_handler endp
F000:E820
F000:E822
F000:E822 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E822
F000:E822 ;
F000:E822 ;	Returns	line status and	modem status information for a specified
F000:E822 ;	serial port.
F000:E822 ;
F000:E822 ;	   On entry:	  AH	     03h
F000:E822 ;			  DX	     Serial port number	(0 - COM1, 1 - COM2, etc.)
F000:E822 ;
F000:E822 ;	   Returns:	  AX	     Line and Modem status
F000:E822
F000:E822 int_14_03_handler proc far				      ;	CODE XREF: int_14_handler:jump_to_subsrvj
F000:E822							      ;	int_14_00_handler+31j
F000:E822							      ;	DATA XREF: int_14_handler+2Eo
F000:E822		  add	  dx, 5
F000:E825		  in	  al, dx
F000:E826		  mov	  ah, al
F000:E828		  inc	  dx
F000:E829		  in	  al, dx
F000:E82A
F000:E82A int_14_pop_and_iret:					      ;	CODE XREF: int_14_handler+20j
F000:E82A							      ;	int_14_handler:errorj
F000:E82A							      ;	int_14_01_handler+2Aj
F000:E82A							      ;	int_14_01_handler+3Aj ...
F000:E82A		  jmp	  near ptr pop_regs_and_iret
F000:E82A int_14_03_handler endp
F000:E82A
F000:E82A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E82D		  db 0FFh
F000:E82E
F000:E82E ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E82E
F000:E82E
F000:E82E int_16_handler  proc far				      ;	DATA XREF: F000:FF0Fo
F000:E82E
F000:E82E ; FUNCTION CHUNK AT F000:E898	SIZE 00000009 BYTES
F000:E82E
F000:E82E		  sti
F000:E82F		  push	  bx
F000:E830		  push	  cx
F000:E831		  push	  si
F000:E832		  push	  di
F000:E833		  push	  ds
F000:E834		  pushf
F000:E835		  mov	  di, 6
F000:E838		  nop
F000:E839		  call	  convert_ah_to_di_idx
F000:E83C		  jnb	  short	l0
F000:E83E		  sub	  ah, 2
F000:E841		  jmp	  short	exit
F000:E843 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E843
F000:E843 l0:							      ;	CODE XREF: int_16_handler+Ej
F000:E843		  jmp	  word ptr cs:jump_tbl[di]
F000:E843 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E848 jump_tbl:						      ;	DATA XREF: int_16_handler:l0r
F000:E848		  dw offset int_16_00_handler
F000:E84A		  dw offset int_16_01_handler
F000:E84C		  dw offset int_16_02_handler
F000:E84E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E84E
F000:E84E exit:							      ;	CODE XREF: int_16_handler+13j
F000:E84E		  jmp	  short	int_16_pop_and_exit
F000:E84E int_16_handler  endp
F000:E84E
F000:E850 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E850		  nop
F000:E851
F000:E851 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E851
F000:E851 ;
F000:E851 ;	Returns	the next character in the keyboard buffer; if no character is
F000:E851 ;	available, this	service	waits until one	is available.
F000:E851 ;
F000:E851 ;	   On entry:	  AH	     00h
F000:E851 ;
F000:E851 ;	   Returns:	  AL	     ASCII character code
F000:E851 ;			  AH	     Scan code
F000:E851 ;
F000:E851
F000:E851 int_16_00_handler proc far				      ;	CODE XREF: int_16_handler:l0j
F000:E851							      ;	int_16_00_handler+26j
F000:E851							      ;	DATA XREF: int_16_handler:jump_tblo
F000:E851		  cli
F000:E852		  mov	  si, ds:p400.keyb_buffer_head_ptr
F000:E856		  cmp	  si, ds:p400.keyb_buffer_tail_ptr
F000:E85A		  jz	  short	no_char
F000:E85C		  mov	  ax, [si]			      ;	char is	available
F000:E85E		  inc	  si
F000:E85F		  inc	  si				      ;	pointer	to next	char/scan code
F000:E860		  cmp	  si, ds:p400.keyb_buffer_end_offset_ptr ; end of buffer?
F000:E864		  jb	  short	buffer_with_room
F000:E866		  mov	  si, ds:p400.keyb_buffer_start_offset_ptr ; if	so, point to beginning
F000:E86A
F000:E86A buffer_with_room:					      ;	CODE XREF: int_16_00_handler+13j
F000:E86A		  mov	  ds:p400.keyb_buffer_head_ptr,	si    ;	update pointer
F000:E86E		  sti
F000:E86F		  jmp	  short	int_16_pop_and_exit
F000:E871 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E871
F000:E871 no_char:						      ;	CODE XREF: int_16_00_handler+9j
F000:E871		  sti
F000:E872		  mov	  cx, 19h			      ;	small delay before trying again
F000:E875
F000:E875 delay:						      ;	CODE XREF: int_16_00_handler:delayj
F000:E875		  loop	  delay
F000:E877		  jmp	  short	near ptr int_16_00_handler    ;	try reading buffer again until key is available
F000:E877 int_16_00_handler endp
F000:E877
F000:E879
F000:E879 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E879
F000:E879 ;
F000:E879 ;	Checks to see if a character is	available in the buffer.
F000:E879 ;
F000:E879 ;	   On entry:	  AH	     01h
F000:E879 ;
F000:E879 ;	   Returns:	  Zero	     0,	if character is	available
F000:E879 ;				     1,	if character is	not available
F000:E879 ;			  AL	     ASCII character code (if character	is
F000:E879 ;				     available)
F000:E879 ;			  AH	     Scan code (if character is	available)
F000:E879 ;
F000:E879
F000:E879 int_16_01_handler proc far				      ;	CODE XREF: int_16_handler:l0j
F000:E879							      ;	DATA XREF: int_16_handler+1Co
F000:E879		  popf
F000:E87A		  xor	  bx, bx			      ;	bx = 0
F000:E87C		  cli
F000:E87D		  mov	  si, ds:p400.keyb_buffer_head_ptr
F000:E881		  cmp	  si, ds:p400.keyb_buffer_tail_ptr
F000:E885		  sti
F000:E886		  jz	  short	no_char
F000:E888		  mov	  ax, [si]
F000:E88A		  cmp	  bx, 1				      ;	z flag = 1. BUG: probably not needed since Z already 1 ?
F000:E88D		  jmp	  short	exit
F000:E88F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E88F		  nop
F000:E890
F000:E890 no_char:						      ;	CODE XREF: int_16_01_handler+Dj
F000:E890		  cmp	  bx, 0				      ;	z flag = 0. BUG: probably not needed since z already 0 ?
F000:E893
F000:E893 exit:							      ;	CODE XREF: int_16_01_handler+14j
F000:E893		  jmp	  short	int_16_exit
F000:E893 int_16_01_handler endp
F000:E893
F000:E895
F000:E895 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E895
F000:E895 ;
F000:E895 ;	Returns	the current keyboard shift status.
F000:E895 ;
F000:E895 ;	   On entry:	  AH	     02h
F000:E895 ;
F000:E895 ;	   Returns:	  AL	     Shift status
F000:E895 ;
F000:E895
F000:E895 int_16_02_handler proc far				      ;	CODE XREF: int_16_handler:l0j
F000:E895							      ;	DATA XREF: int_16_handler+1Eo
F000:E895		  mov	  al, ds:p400.keyb_status_flags_1     ;	get keyboard status flags
F000:E895 int_16_02_handler endp
F000:E895
F000:E898 ; START OF FUNCTION CHUNK FOR	int_16_handler
F000:E898
F000:E898 int_16_pop_and_exit:					      ;	CODE XREF: int_16_handler:exitj
F000:E898							      ;	int_16_00_handler+1Ej
F000:E898		  popf
F000:E899
F000:E899 int_16_exit:						      ;	CODE XREF: int_16_01_handler:exitj
F000:E899		  pop	  ds
F000:E89A		  pop	  di
F000:E89B		  pop	  si
F000:E89C		  pop	  cx
F000:E89D		  pop	  bx
F000:E89E		  retf	  2
F000:E89E ; END	OF FUNCTION CHUNK FOR int_16_handler
F000:E89E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E8A1		  db 0E6h dup(0FFh)
F000:E987
F000:E987 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:E987
F000:E987 ;  The keyboard generates an INT 9 every time	a key is pushed	or
F000:E987 ;	released.
F000:E987 ;
F000:E987 ;	   Notes:	  This is a hardware interrupt (IRQ 1) activated by
F000:E987 ;			  the make or break of every keystroke.
F000:E987 ;
F000:E987 ;	The default INT	9 handler in the ROM reads the make and	break scan
F000:E987 ;	codes from the keyboard	and converts them into actions or key codes as
F000:E987 ;	follows:
F000:E987 ;
F000:E987 ;	     .	 For ASCII keys, when a	make code is encountered, the ASCII code
F000:E987 ;		 and the scan code for the key are placed in the 32-byte keyboard
F000:E987 ;		 buffer, which is located at 0:41Eh. The ASCII code and	scan code
F000:E987 ;		 are placed in the buffer at the location addressed by the
F000:E987 ;		 Keyboard Buffer Tail Pointer (0:041Ch). The Keyboard Buffer Tail
F000:E987 ;		 Pointer is then incremented by	2, and if it points past the end
F000:E987 ;		 of the	buffer,	it is adjusted so that it points to the	beginning
F000:E987 ;		 of the	buffer.
F000:E987 ;
F000:E987 ;	     .	 If Ctrl, Alt, or Shift	has been pressed, the Shift Status
F000:E987 ;		 (0:0417h) and Extended	Shift Status (0:0418h) bytes are updated.
F000:E987 ;
F000:E987 ;	     .	 If the	Ctrl-Alt-Del combination has been pressed, the Reset
F000:E987 ;		 Flag (0:0472h)	is set to 1234h	and control is given to	the
F000:E987 ;		 power-on self test (POST). Because the	Reset Flag is 1234h, the
F000:E987 ;		 POST routine bypasses the memory test.
F000:E987 ;
F000:E987 ;	     .	 If the	Pause key sequence has been entered, this interrupt
F000:E987 ;		 enters	an indefinite loop. The	loop is	broken as soon as a valid
F000:E987 ;		 ASCII keystroke is entered. (The PC Convertible issues	an INT
F000:E987 ;		 15h, Service 41h (Wait	on External Event), to execute its pause
F000:E987 ;		 loop.)
F000:E987 ;
F000:E987 ;	     .	 If the	Print Screen key sequence is entered, an INT 05h (Print
F000:E987 ;		 Screen) is executed.
F000:E987 ;
F000:E987 ;	     .	 If the	Control-Break key sequence is entered, an INT 1Bh
F000:E987 ;		 (Control-Break) is executed.
F000:E987 ;
F000:E987 ;	     .	 For XTs dated 1/10/86 and after, ATs, XT-286s,	and PC
F000:E987 ;		 Convertibles, the INT 9h handler generates an INT 15h,	function
F000:E987 ;		 91h (Interrupt	Complete) to signal that a keystroke is
F000:E987 ;		 available. Also, on these machines, a make or break of	the Sys
F000:E987 ;		 Req key generates an INT 15h, function	85h (System Request Key
F000:E987 ;		 Pressed).
F000:E987 ;
F000:E987 ;	     .	 For ATs dated 6/10/85 and after, XT-286s, and PC Convertibles,
F000:E987 ;		 an INT	15h, function 4Fh (Keyboard Intercept) is executed after
F000:E987 ;		 the scan code has been	read from the keyboard port (60h). This
F000:E987 ;		 allows	the user to redefine or	remove a keystroke.
F000:E987 ;
F000:E987 ;	INT 16 provides	a standard way to read characters from the keyboard
F000:E987 ;	buffer that have been placed there by the INT 9	handler	in ROM.
F000:E987
F000:E987 int_09_handler  proc far				      ;	DATA XREF: F000:FEF5o
F000:E987		  call	  int_push_regs
F000:E98A		  push	  ax
F000:E98B		  mov	  ax, 40h ; '@'
F000:E98E		  mov	  ds, ax			      ;	ds = 40h
F000:E990		  mov	  ch, ds:p400.keyb_status_flags_1     ;	keyboard status	flags 1
F000:E994		  mov	  cl, ds:p400.keyb_status_flags_2     ;	keyboard status	flags 2
F000:E998		  mov	  dx, 60h ; '`'
F000:E99B		  in	  al, dx			      ;	in al, 60h - Read keyboard
F000:E99C		  push	  ax
F000:E99D		  in	  al, 61h			      ;	Port B.	Read Write
F000:E99F		  or	  al, 80h			      ;	bit 7: 1=Keyboard clear
F000:E9A1		  out	  61h, al			      ;	out 61h, 80h
F000:E9A3		  and	  al, 7Fh			      ;	bit 7: 1=Keyboard clear, 0=Keyboard not	clear (?)
F000:E9A5		  out	  61h, al			      ;	out 61h, orig &	7fh.
F000:E9A5							      ;	This sequence of outs to port 61h seems	to be
F000:E9A5							      ;	the standard way to set	the keyboard ready again
F000:E9A7		  pop	  ax
F000:E9A8		  cmp	  al, 0FFh			      ;	unsupported scancode ?
F000:E9AA		  jnz	  short	l0
F000:E9AC		  call	  play_bell_sound
F000:E9AF		  jmp	  update_status_flags_and_exit
F000:E9B2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9B2
F000:E9B2 l0:							      ;	CODE XREF: int_09_handler+23j
F000:E9B2		  mov	  ah, al			      ;	ah = scancode (either break code or make code)
F000:E9B4		  and	  al, 7Fh ; ''                       ; al = make code (convert possible break code to make code)
F000:E9B6		  cmp	  al, 1Dh			      ;	scan code for left Ctrl
F000:E9B8		  jnz	  short	l1
F000:E9BA		  jmp	  ctrl_pressed
F000:E9BD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9BD
F000:E9BD l1:							      ;	CODE XREF: int_09_handler+31j
F000:E9BD		  cmp	  al, 2Ah ; '*'                       ; scan code for left Shift
F000:E9BF		  jnz	  short	l2
F000:E9C1		  jmp	  left_shift_pressed
F000:E9C4 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9C4
F000:E9C4 l2:							      ;	CODE XREF: int_09_handler+38j
F000:E9C4		  cmp	  al, 36h ; '6'                       ; scan code for right Shift
F000:E9C6		  jnz	  short	l3
F000:E9C8		  jmp	  right_shift_pressed
F000:E9CB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9CB
F000:E9CB l3:							      ;	CODE XREF: int_09_handler+3Fj
F000:E9CB		  cmp	  al, 38h ; '8'                       ; scan code for left Alt (only one Alt in Tandy 1000HX)
F000:E9CD		  jnz	  short	l4
F000:E9CF		  jmp	  alt_pressed
F000:E9D2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9D2
F000:E9D2 l4:							      ;	CODE XREF: int_09_handler+46j
F000:E9D2		  cmp	  al, 3Ah ; ':'                       ; scan code for Caps lock
F000:E9D4		  jnz	  short	l5
F000:E9D6		  jmp	  test_caps_lock
F000:E9D9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9D9
F000:E9D9 l5:							      ;	CODE XREF: int_09_handler+4Dj
F000:E9D9		  cmp	  al, 45h ; 'E'                       ; scan code for Num Lock
F000:E9DB		  jnz	  short	l6
F000:E9DD		  jmp	  test_num_lock
F000:E9E0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9E0
F000:E9E0 l6:							      ;	CODE XREF: int_09_handler+54j
F000:E9E0		  cmp	  al, 46h ; 'F'                       ; scan code for Scroll lock and Hold (?)
F000:E9E2		  jnz	  short	l7
F000:E9E4		  jmp	  test_hold
F000:E9E7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9E7
F000:E9E7 l7:							      ;	CODE XREF: int_09_handler+5Bj
F000:E9E7		  cmp	  al, 55h ; 'U'                       ; scan code for keypad: + / insert
F000:E9E9		  jnz	  short	l8
F000:E9EB		  mov	  al, ah			      ;	move scancode to al (scancode boths in ah and al)
F000:E9ED		  jmp	  short	l10
F000:E9EF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9EF
F000:E9EF l8:							      ;	CODE XREF: int_09_handler+62j
F000:E9EF		  mov	  al, ah			      ;	al = scan code
F000:E9F1		  test	  cl, 1000b			      ;	paused ?
F000:E9F4		  jz	  short	l10
F000:E9F6		  cmp	  al, 9Dh ; ''                       ; 9d = 80 + 1d = ctrl released ?
F000:E9F8		  jnz	  short	l9
F000:E9FA		  and	  ch, 11111011b			      ;	ctrl released
F000:E9FD		  jmp	  short	update_and_exit_5
F000:E9FF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:E9FF
F000:E9FF l9:							      ;	CODE XREF: int_09_handler+71j
F000:E9FF		  cmp	  al, 0				      ;	scancode 0 (?)
F000:EA01		  jl	  short	update_and_exit_5
F000:EA03		  and	  cl, 1000b			      ;	filter everything, except pause	key
F000:EA06
F000:EA06 update_and_exit_5:					      ;	CODE XREF: int_09_handler+76j
F000:EA06							      ;	int_09_handler+7Aj
F000:EA06		  call	  pic_eoi
F000:EA09		  jmp	  update_status_flags_and_exit2
F000:EA0C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA0C
F000:EA0C l10:							      ;	CODE XREF: int_09_handler+66j
F000:EA0C							      ;	int_09_handler+6Dj
F000:EA0C		  cmp	  al, 0D5h ; 'Õ'                      ; 0d5h - 80h = 55h. Keypad + / insert released ?
F000:EA0E		  jnz	  short	l11
F000:EA10		  jmp	  alt_shift_and_numlock_test
F000:EA13 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA13
F000:EA13 l11:							      ;	CODE XREF: int_09_handler+87j
F000:EA13		  cmp	  al, 0				      ;	scancode 0 (?)
F000:EA15		  jge	  short	l12
F000:EA17		  jmp	  update_status_flags_and_exit
F000:EA1A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA1A
F000:EA1A l12:							      ;	CODE XREF: int_09_handler+8Ej
F000:EA1A		  cmp	  al, 47h ; 'G'                       ; scancode for keypad: 7 / \
F000:EA1C		  jl	  short	l13
F000:EA1E		  jmp	  l26
F000:EA21 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA21
F000:EA21 l13:							      ;	CODE XREF: int_09_handler+95j
F000:EA21		  mov	  byte ptr ds:p400.alt_keypad_entry, 0
F000:EA26		  cmp	  al, 37h ; '7'                       ; print screen ?
F000:EA28		  jnz	  short	use_scancode_tbl_default
F000:EA2A		  test	  ch, 11b			      ;	any shift pressed ?
F000:EA2D		  jz	  short	use_scancode_tbl_default
F000:EA2F		  jmp	  print_screen_pressed
F000:EA32 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA32
F000:EA32 use_scancode_tbl_default:				      ;	CODE XREF: int_09_handler+A1j
F000:EA32							      ;	int_09_handler+A6j
F000:EA32		  lea	  bx, tbl_scancode_to_ascii_default
F000:EA36		  test	  ch, 1000000b			      ;	caps lock locked ?
F000:EA39		  jz	  short	l16
F000:EA3B		  cmp	  al, 10h			      ;	q ?
F000:EA3D		  jl	  short	l16
F000:EA3F		  cmp	  al, 1Ah			      ;	[{ ?
F000:EA41		  jl	  short	use_scancode_tbl_shift
F000:EA43		  cmp	  al, 1Eh			      ;	a ?
F000:EA45		  jl	  short	l16
F000:EA47		  cmp	  al, 27h ; '''                       ; :; ?
F000:EA49		  jl	  short	use_scancode_tbl_shift
F000:EA4B		  cmp	  al, 2Ch ; ','                       ; z ?
F000:EA4D		  jl	  short	l16
F000:EA4F		  cmp	  al, 33h ; '3'                       ; ,< ?
F000:EA51		  jge	  short	l16
F000:EA53
F000:EA53 use_scancode_tbl_shift:				      ;	CODE XREF: int_09_handler+BAj
F000:EA53							      ;	int_09_handler+C2j
F000:EA53		  lea	  bx, tbl_scancode_to_ascii_shift
F000:EA57
F000:EA57 l16:							      ;	CODE XREF: int_09_handler+B2j
F000:EA57							      ;	int_09_handler+B6j
F000:EA57							      ;	int_09_handler+BEj
F000:EA57							      ;	int_09_handler+C6j ...
F000:EA57		  test	  ch, 11b			      ;	any shift pressed ?
F000:EA5A		  jz	  short	l18
F000:EA5C		  cmp	  bx, offset tbl_scancode_to_ascii_shift
F000:EA60		  jnz	  short	use_scancode_tbl_shift_2
F000:EA62		  lea	  bx, tbl_scancode_to_ascii_default
F000:EA66		  jmp	  short	l18
F000:EA68 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA68
F000:EA68 use_scancode_tbl_shift_2:				      ;	CODE XREF: int_09_handler+D9j
F000:EA68		  lea	  bx, tbl_scancode_to_ascii_shift
F000:EA6C
F000:EA6C l18:							      ;	CODE XREF: int_09_handler+D3j
F000:EA6C							      ;	int_09_handler+DFj
F000:EA6C		  test	  ch, 1000b			      ;	alt key	pressed	?
F000:EA6F		  jz	  short	l19
F000:EA71		  lea	  bx, tbl_scancode_to_ascii_alt
F000:EA75		  jmp	  short	do_keypad_scancode_to_ascii_2
F000:EA77 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA77
F000:EA77 l19:							      ;	CODE XREF: int_09_handler+E8j
F000:EA77		  test	  ch, 100b			      ;	ctrl key pressed ?
F000:EA7A		  jz	  short	do_keypad_scancode_to_ascii_2
F000:EA7C		  lea	  bx, tbl_scancode_to_ascii_ctrl
F000:EA80
F000:EA80 do_keypad_scancode_to_ascii_2:			      ;	CODE XREF: int_09_handler+EEj
F000:EA80							      ;	int_09_handler+F3j
F000:EA80		  call	  scancode_to_ascii
F000:EA83		  cmp	  al, 0FFh			      ;	al = ascii value
F000:EA85		  jnz	  short	l21
F000:EA87		  jmp	  short	update_status_flags_and_exit
F000:EA89 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EA89		  nop
F000:EA8A
F000:EA8A l21:							      ;	CODE XREF: int_09_handler+FEj
F000:EA8A		  cmp	  ah, 29h ; ')'                       ; up arrow ?
F000:EA8D		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EA8F		  cmp	  ah, 2Bh ; '+'                       ; left arrow ?
F000:EA92		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EA94		  cmp	  ah, 3Ah ; ':'                       ; caps ?
F000:EA97		  jg	  short	pre_put_ax_in_keyb_buffer
F000:EA99		  test	  ch, 100b			      ;	ctrl key pressed ?
F000:EA9C		  jz	  short	l22
F000:EA9E		  cmp	  ah, 1				      ;	esc ?
F000:EAA1		  jz	  short	try_intl_xlat
F000:EAA3		  cmp	  ah, 7				      ;	5 ^ ?
F000:EAA6		  jz	  short	try_intl_xlat
F000:EAA8		  cmp	  ah, 0Bh			      ;	0 ) ?
F000:EAAB		  jbe	  short	pre_put_ax_in_keyb_buffer
F000:EAAD		  cmp	  ah, 0Dh			      ;	= + ?
F000:EAB0		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAB2		  cmp	  ah, 0Fh			      ;	tab ?
F000:EAB5		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAB7		  cmp	  ah, 27h ; '''                       ; ;: ?
F000:EABA		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EABC		  cmp	  ah, 28h ; '('                       ; '" ?
F000:EABF		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAC1		  cmp	  ah, 33h ; '3'                       ; , < ?
F000:EAC4		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAC6		  cmp	  ah, 34h ; '4'                       ; . > ?
F000:EAC9		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EACB		  cmp	  ah, 35h ; '5'                       ; / ?  ?
F000:EACE		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAD0		  cmp	  ah, 37h ; '7'                       ; print screen ?
F000:EAD3		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAD5
F000:EAD5 l22:							      ;	CODE XREF: int_09_handler+115j
F000:EAD5		  test	  ch, 1000b			      ;	alt pressed ?
F000:EAD8		  jz	  short	l23
F000:EADA		  cmp	  ah, 39h ; '9'                       ; space bar ?
F000:EADD		  jz	  short	try_intl_xlat
F000:EADF		  jmp	  short	pre_put_ax_in_keyb_buffer
F000:EAE1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EAE1
F000:EAE1 l23:							      ;	CODE XREF: int_09_handler+151j
F000:EAE1		  cmp	  ah, 0Fh			      ;	tab ?
F000:EAE4		  jnz	  short	l24
F000:EAE6		  cmp	  al, 0Fh			      ;	tab ?
F000:EAE8		  jz	  short	pre_put_ax_in_keyb_buffer
F000:EAEA
F000:EAEA l24:							      ;	CODE XREF: int_09_handler+15Dj
F000:EAEA		  test	  ch, 1000b			      ;	alt pressed ?
F000:EAED		  jz	  short	try_intl_xlat
F000:EAEF
F000:EAEF pre_put_ax_in_keyb_buffer:				      ;	CODE XREF: int_09_handler+106j
F000:EAEF							      ;	int_09_handler+10Bj
F000:EAEF							      ;	int_09_handler+110j
F000:EAEF							      ;	int_09_handler+124j ...
F000:EAEF		  mov	  ah, al			      ;	ascii to ah
F000:EAF1		  xor	  al, al			      ;	al = 0 (scancode)
F000:EAF3
F000:EAF3 try_intl_xlat:					      ;	CODE XREF: int_09_handler+11Aj
F000:EAF3							      ;	int_09_handler+11Fj
F000:EAF3							      ;	int_09_handler+156j
F000:EAF3							      ;	int_09_handler+166j ...
F000:EAF3		  mov	  bx, p400.keyb_intl_support
F000:EAF6		  mov	  dx, [bx]
F000:EAF8		  or	  dx, [bx+2]			      ;	is intl_support	== 0 ?
F000:EAFB		  jz	  short	put_ax_in_keyb_buffer
F000:EAFD		  call	  dword	ptr [bx]		      ;	calls intl_support callback to handle input ?
F000:EAFF		  jb	  short	update_status_flags_and_exit
F000:EB01
F000:EB01 put_ax_in_keyb_buffer:				      ;	CODE XREF: int_09_handler+174j
F000:EB01		  call	  put_char_in_keyb_buffer
F000:EB04
F000:EB04 update_status_flags_and_exit:				      ;	CODE XREF: int_09_handler+28j
F000:EB04							      ;	int_09_handler+90j
F000:EB04							      ;	int_09_handler+100j
F000:EB04							      ;	int_09_handler+178j ...
F000:EB04		  call	  pic_eoi
F000:EB07
F000:EB07 update_status_flags_and_exit2:			      ;	CODE XREF: int_09_handler+82j
F000:EB07		  mov	  ds:p400.keyb_status_flags_1, ch
F000:EB0B		  mov	  ds:p400.keyb_status_flags_2, cl
F000:EB0F
F000:EB0F pop_and_exit:						      ;	CODE XREF: int_09_handler+256j
F000:EB0F							      ;	int_09_handler:exit_1j
F000:EB0F		  pop	  ax
F000:EB10		  jmp	  near ptr pop_regs_and_iret
F000:EB13 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB13
F000:EB13 ctrl_pressed:						      ;	CODE XREF: int_09_handler+33j
F000:EB13		  cmp	  ah, 1Dh			      ;	ctrl ?
F000:EB16		  jnz	  short	ctrl_released
F000:EB18		  or	  ch, 100b			      ;	ctrl pressed
F000:EB1B		  and	  ch, 11111100b			      ;	left/right shift released
F000:EB1E		  jmp	  short	update_status_flags_and_exit
F000:EB20 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB20
F000:EB20 ctrl_released:					      ;	CODE XREF: int_09_handler+18Fj
F000:EB20		  and	  ch, 11111011b
F000:EB23		  jmp	  short	update_status_flags_and_exit
F000:EB25 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB25
F000:EB25 left_shift_pressed:					      ;	CODE XREF: int_09_handler+3Aj
F000:EB25		  cmp	  ah, 2Ah ; '*'                       ; left shift pressed ?
F000:EB28		  jnz	  short	left_shift_released
F000:EB2A		  or	  ch, 10b
F000:EB2D		  jmp	  short	update_status_flags_and_exit
F000:EB2F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB2F
F000:EB2F left_shift_released:					      ;	CODE XREF: int_09_handler+1A1j
F000:EB2F		  and	  ch, 11111101b
F000:EB32		  jmp	  short	update_status_flags_and_exit
F000:EB34 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB34
F000:EB34 right_shift_pressed:					      ;	CODE XREF: int_09_handler+41j
F000:EB34		  cmp	  ah, 36h ; '6'                       ; right shift ?
F000:EB37		  jnz	  short	right_shift_released
F000:EB39		  or	  ch, 1
F000:EB3C		  jmp	  short	update_status_flags_and_exit
F000:EB3E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB3E
F000:EB3E right_shift_released:					      ;	CODE XREF: int_09_handler+1B0j
F000:EB3E		  and	  ch, 11111110b
F000:EB41		  jmp	  short	update_status_flags_and_exit
F000:EB43 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB43
F000:EB43 alt_pressed:						      ;	CODE XREF: int_09_handler+48j
F000:EB43		  cmp	  ah, 38h ; '8'                       ; alt ?
F000:EB46		  jnz	  short	alt_released
F000:EB48		  or	  ch, 1000b
F000:EB4B		  mov	  byte ptr ds:p400.alt_keypad_entry, 0
F000:EB50		  and	  ch, 11111100b			      ;	left/right shifts released
F000:EB53		  jmp	  short	update_status_flags_and_exit
F000:EB55 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB55
F000:EB55 alt_released:						      ;	CODE XREF: int_09_handler+1BFj
F000:EB55		  and	  ch, 11110111b			      ;	alt key	released
F000:EB58		  cmp	  byte ptr ds:p400.alt_keypad_entry, 0
F000:EB5D		  jz	  short	update_and_exit_3
F000:EB5F		  xor	  ax, ax
F000:EB61		  mov	  al, ds:p400.alt_keypad_entry	      ;	get value from Alt_buffer, when	alt key	is released
F000:EB64		  jmp	  short	try_intl_xlat
F000:EB66 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB66
F000:EB66 update_and_exit_3:					      ;	CODE XREF: int_09_handler+1D6j
F000:EB66		  jmp	  short	update_status_flags_and_exit
F000:EB68 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB68
F000:EB68 test_caps_lock:					      ;	CODE XREF: int_09_handler+4Fj
F000:EB68		  cmp	  ah, 3Ah ; ':'                       ; caps lock
F000:EB6B		  jnz	  short	caps_lock_released
F000:EB6D		  test	  cl, 1000000b			      ;	caps lock pressed ?
F000:EB70		  jnz	  short	update_and_exit_4
F000:EB72		  or	  cl, 1000000b			      ;	caps lock pressed
F000:EB75		  test	  ch, 1000000b			      ;	caps lock locked ?
F000:EB78		  jnz	  short	caps_lock_unlocked
F000:EB7A		  or	  ch, 1000000b			      ;	caps lock locked
F000:EB7D
F000:EB7D update_and_exit_4:					      ;	CODE XREF: int_09_handler+1E9j
F000:EB7D		  jmp	  short	update_status_flags_and_exit
F000:EB7F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB7F
F000:EB7F caps_lock_unlocked:					      ;	CODE XREF: int_09_handler+1F1j
F000:EB7F		  and	  ch, 10111111b			      ;	caps lock unlocked
F000:EB82		  jmp	  short	update_status_flags_and_exit
F000:EB84 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB84
F000:EB84 caps_lock_released:					      ;	CODE XREF: int_09_handler+1E4j
F000:EB84		  and	  ch, 10111111b			      ;	caps lock unlocked
F000:EB87		  and	  cl, 10111111b			      ;	caps lock released
F000:EB8A		  jmp	  update_status_flags_and_exit
F000:EB8D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB8D
F000:EB8D test_num_lock:					      ;	CODE XREF: int_09_handler+56j
F000:EB8D		  cmp	  ah, 45h ; 'E'                       ; num lock ?
F000:EB90		  jnz	  short	num_lock_released
F000:EB92		  test	  ch, 100b
F000:EB95		  jz	  short	num_lock_pressed
F000:EB97		  jmp	  update_status_flags_and_exit
F000:EB9A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EB9A
F000:EB9A num_lock_pressed:					      ;	CODE XREF: int_09_handler+20Ej
F000:EB9A		  or	  cl, 100000b			      ;	num lock pressed
F000:EB9D		  test	  ch, 100000b			      ;	num lock locked	?
F000:EBA0		  jnz	  short	num_lock_unlocked
F000:EBA2		  or	  ch, 100000b			      ;	num lock locked
F000:EBA5		  jmp	  update_status_flags_and_exit
F000:EBA8 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBA8
F000:EBA8 num_lock_unlocked:					      ;	CODE XREF: int_09_handler+219j
F000:EBA8		  and	  ch, 11011111b			      ;	num lock unlocked
F000:EBAB		  jmp	  update_status_flags_and_exit
F000:EBAE ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBAE
F000:EBAE num_lock_released:					      ;	CODE XREF: int_09_handler+209j
F000:EBAE		  and	  ch, 11011111b			      ;	num lock unlocked
F000:EBB1		  and	  cl, 11011111b			      ;	num lock released
F000:EBB4		  jmp	  update_status_flags_and_exit
F000:EBB7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBB7
F000:EBB7 test_hold:						      ;	CODE XREF: int_09_handler+5Dj
F000:EBB7		  cmp	  ah, 46h ; 'F'                       ; hold ? (freeze display)
F000:EBBA		  jnz	  short	left_alt_released
F000:EBBC		  test	  cl, 10b			      ;	left alt pressed ?
F000:EBBF		  jnz	  short	update_and_exit_0
F000:EBC1		  or	  cl, 10b			      ;	left alt pressed
F000:EBC4		  xor	  cl, 1000b			      ;	toggle pause key
F000:EBC7		  call	  pic_eoi
F000:EBCA		  mov	  ds:p400.keyb_status_flags_1, ch
F000:EBCE		  mov	  ds:p400.keyb_status_flags_2, cl
F000:EBD2
F000:EBD2 wait_for_pause_key_released:				      ;	CODE XREF: int_09_handler+253j
F000:EBD2		  test	  byte ptr ds:p400.keyb_status_flags_2,	1000b
F000:EBD7		  jz	  short	exit_0
F000:EBD9		  sti					      ;	enable (keyboard) interrupts
F000:EBDA		  jmp	  short	wait_for_pause_key_released
F000:EBDC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBDC
F000:EBDC exit_0:						      ;	CODE XREF: int_09_handler+250j
F000:EBDC		  cli
F000:EBDD		  jmp	  pop_and_exit
F000:EBE0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBE0
F000:EBE0 left_alt_released:					      ;	CODE XREF: int_09_handler+233j
F000:EBE0		  and	  cl, 11111101b			      ;	left alt released
F000:EBE3
F000:EBE3 update_and_exit_0:					      ;	CODE XREF: int_09_handler+238j
F000:EBE3		  jmp	  update_status_flags_and_exit
F000:EBE6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBE6
F000:EBE6 alt_shift_and_numlock_test:				      ;	CODE XREF: int_09_handler+89j
F000:EBE6		  test	  ch, 100000b			      ;	num lock locked	?
F000:EBE9		  jnz	  short	l25
F000:EBEB		  test	  ch, 1111b			      ;	any shift or any alt pressed ?
F000:EBEE		  jnz	  short	update_and_exit_1
F000:EBF0
F000:EBF0 insert_released:					      ;	CODE XREF: int_09_handler+272j
F000:EBF0		  and	  cl, 1111111b			      ;	Insert key released
F000:EBF3		  jmp	  update_status_flags_and_exit
F000:EBF6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBF6
F000:EBF6 l25:							      ;	CODE XREF: int_09_handler+262j
F000:EBF6		  test	  ch, 11b			      ;	any shift pressed ?
F000:EBF9		  jnz	  short	insert_released
F000:EBFB
F000:EBFB update_and_exit_1:					      ;	CODE XREF: int_09_handler+267j
F000:EBFB		  jmp	  update_status_flags_and_exit
F000:EBFB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EBFE		  db 5Bh dup(0FFh)
F000:EC59 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC59
F000:EC59 int_13_handler:					      ;	DATA XREF: F000:FF09o
F000:EC59		  jmp	  near ptr int_13_main
F000:EC5C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC5C
F000:EC5C l26:							      ;	CODE XREF: int_09_handler+97j
F000:EC5C		  test	  ch, 100b			      ;	ctrl pressed ?
F000:EC5F		  jz	  short	l29
F000:EC61		  cmp	  al, 54h ; 'T'                       ; break scan code ?
F000:EC63		  jnz	  short	l27
F000:EC65		  jmp	  ctrl_break_pressed
F000:EC68 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC68
F000:EC68 l27:							      ;	CODE XREF: int_09_handler+2DCj
F000:EC68		  cmp	  al, 53h ; 'S'                       ; keypad - / delete pressed?
F000:EC6A		  jnz	  short	l28
F000:EC6C		  test	  ch, 1000b			      ;	alt key	pressed	?
F000:EC6F		  jz	  short	l28
F000:EC71		  jmp	  ctrl_alt_del_pressed
F000:EC74 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC74
F000:EC74 l28:							      ;	CODE XREF: int_09_handler+2E3j
F000:EC74							      ;	int_09_handler+2E8j
F000:EC74		  lea	  bx, keypad_scancode_to_ascii_ctrl
F000:EC78		  jmp	  do_keypad_scancode_to_ascii
F000:EC7B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC7B
F000:EC7B l29:							      ;	CODE XREF: int_09_handler+2D8j
F000:EC7B		  test	  ch, 1000b
F000:EC7E		  jz	  short	l34
F000:EC80		  cmp	  al, 53h ; 'S'                       ; keypad - / delete ?
F000:EC82		  jnz	  short	l30
F000:EC84		  test	  ch, 100b
F000:EC87		  jz	  short	l30
F000:EC89		  jmp	  ctrl_alt_del_pressed
F000:EC8C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EC8C
F000:EC8C l30:							      ;	CODE XREF: int_09_handler+2FBj
F000:EC8C							      ;	int_09_handler+300j
F000:EC8C		  cmp	  al, 4Ah ; 'J'                       ; down arrow ?
F000:EC8E		  jz	  short	use_keypad_scancode_tbl_alt
F000:EC90		  cmp	  al, 4Eh ; 'N'                       ; right arrow ?
F000:EC92		  jz	  short	use_keypad_scancode_tbl_alt
F000:EC94		  cmp	  al, 54h ; 'T'                       ; break ?
F000:EC96		  jz	  short	l31
F000:EC98		  cmp	  al, 53h ; 'S'                       ; keypad - / delete ?
F000:EC9A		  jge	  short	use_keypad_scancode_tbl_alt
F000:EC9C		  cmp	  al, 4Eh ; 'N'                       ; right arrow ?
F000:EC9E		  jz	  short	update_and_exit_2
F000:ECA0		  mov	  dx, ax
F000:ECA2		  xor	  ax, ax
F000:ECA4		  mov	  al, ds:p400.alt_keypad_entry
F000:ECA7		  shl	  ax, 1
F000:ECA9		  push	  ax
F000:ECAA		  shl	  ax, 1
F000:ECAC		  shl	  ax, 1
F000:ECAE		  pop	  bx
F000:ECAF		  add	  ax, bx
F000:ECB1		  push	  ax
F000:ECB2		  mov	  ax, dx
F000:ECB4		  lea	  bx, keypad_scancode_to_ascii_default
F000:ECB8		  sub	  al, 70
F000:ECBA		  call	  scancode_to_ascii
F000:ECBD		  sub	  al, 30h ; '0'                       ; ascii value
F000:ECBF		  xor	  ah, ah
F000:ECC1		  pop	  dx
F000:ECC2		  add	  dx, ax
F000:ECC4		  mov	  ds:p400.alt_keypad_entry, dl
F000:ECC8
F000:ECC8 update_and_exit_2:					      ;	CODE XREF: int_09_handler+317j
F000:ECC8		  jmp	  update_status_flags_and_exit
F000:ECCB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECCB
F000:ECCB l31:							      ;	CODE XREF: int_09_handler+30Fj
F000:ECCB		  cmp	  al, 54h ; 'T'                       ; break ?
F000:ECCD		  jnz	  short	l33
F000:ECCF		  or	  cl, 10000b			      ;	scroll lock pressed
F000:ECD2		  test	  ch, 10000b			      ;	scroll lock locked ?
F000:ECD5		  jnz	  short	l32
F000:ECD7		  or	  ch, 10000b			      ;	scroll lock locked
F000:ECDA		  jmp	  update_status_flags_and_exit
F000:ECDD ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECDD
F000:ECDD l32:							      ;	CODE XREF: int_09_handler+34Ej
F000:ECDD		  and	  ch, 11101111b			      ;	scroll lock unlocked
F000:ECE0		  jmp	  update_status_flags_and_exit
F000:ECE3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECE3
F000:ECE3 l33:							      ;	CODE XREF: int_09_handler+346j
F000:ECE3		  and	  cl, 11101111b			      ;	scroll lock released
F000:ECE6		  jmp	  update_status_flags_and_exit
F000:ECE9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECE9
F000:ECE9 use_keypad_scancode_tbl_alt:				      ;	CODE XREF: int_09_handler+307j
F000:ECE9							      ;	int_09_handler+30Bj
F000:ECE9							      ;	int_09_handler+313j
F000:ECE9		  lea	  bx, keypad_scancode_to_ascii_alt
F000:ECED		  sub	  al, 70
F000:ECEF		  call	  scancode_to_ascii
F000:ECF2		  cmp	  al, 0FFh			      ;	ascii value
F000:ECF4		  jnz	  short	pre_do_intl_xlat_2
F000:ECF6		  jmp	  update_status_flags_and_exit
F000:ECF9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECF9
F000:ECF9 pre_do_intl_xlat_2:					      ;	CODE XREF: int_09_handler+36Dj
F000:ECF9		  jmp	  pre_put_ax_in_keyb_buffer
F000:ECFC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ECFC
F000:ECFC l34:							      ;	CODE XREF: int_09_handler+2F7j
F000:ECFC		  test	  ch, 100000b			      ;	num lock locked	?
F000:ECFF		  jnz	  short	l38
F000:ED01		  cmp	  al, 4Ah ; 'J'                       ; down arrow ?
F000:ED03		  jz	  short	l35
F000:ED05		  cmp	  al, 4Eh ; 'N'                       ; right arrow ?
F000:ED07		  jz	  short	l35
F000:ED09		  cmp	  al, 58h ; 'X'                       ; home ?
F000:ED0B		  jge	  short	l35
F000:ED0D		  jmp	  short	l36
F000:ED0F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED0F
F000:ED0F l35:							      ;	CODE XREF: int_09_handler+37Cj
F000:ED0F							      ;	int_09_handler+380j
F000:ED0F							      ;	int_09_handler+384j
F000:ED0F		  test	  ch, 11b
F000:ED12		  jnz	  short	use_keypad_scancode_tbl_shift
F000:ED14		  jmp	  short	use_keypad_scancode_tbl_default
F000:ED16 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED16
F000:ED16 l36:							      ;	CODE XREF: int_09_handler+386j
F000:ED16		  test	  ch, 11b
F000:ED19		  jnz	  short	use_keypad_scancode_tbl_default
F000:ED1B
F000:ED1B use_keypad_scancode_tbl_shift:			      ;	CODE XREF: int_09_handler+38Bj
F000:ED1B							      ;	int_09_handler+3B1j
F000:ED1B		  lea	  bx, keypad_scancode_to_ascii_shift
F000:ED1F		  cmp	  al, 55h ; 'U'                       ; keypad + / insert
F000:ED21		  jnz	  short	do_keypad_scancode_to_ascii
F000:ED23		  or	  cl, 10000000b			      ;	insert pressed
F000:ED26		  test	  ch, 10000000b			      ;	insert locked ?
F000:ED29		  jnz	  short	l37
F000:ED2B		  or	  ch, 10000000b			      ;	insert locked
F000:ED2E		  jmp	  short	do_keypad_scancode_to_ascii
F000:ED30 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED30
F000:ED30 l37:							      ;	CODE XREF: int_09_handler+3A2j
F000:ED30		  and	  ch, 1111111b			      ;	insert unlocked
F000:ED33		  jmp	  short	do_keypad_scancode_to_ascii
F000:ED35 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED35
F000:ED35 l38:							      ;	CODE XREF: int_09_handler+378j
F000:ED35		  test	  ch, 11b			      ;	any shift pressed ?
F000:ED38		  jnz	  short	use_keypad_scancode_tbl_shift
F000:ED3A
F000:ED3A use_keypad_scancode_tbl_default:			      ;	CODE XREF: int_09_handler+38Dj
F000:ED3A							      ;	int_09_handler+392j
F000:ED3A		  lea	  bx, keypad_scancode_to_ascii_default
F000:ED3E
F000:ED3E do_keypad_scancode_to_ascii:				      ;	CODE XREF: int_09_handler+2F1j
F000:ED3E							      ;	int_09_handler+39Aj
F000:ED3E							      ;	int_09_handler+3A7j
F000:ED3E							      ;	int_09_handler+3ACj
F000:ED3E		  sub	  al, 70
F000:ED40		  call	  scancode_to_ascii
F000:ED43		  cmp	  al, 0FFh			      ;	al = ascii code
F000:ED45		  jnz	  short	test_ascii_intl_xlat
F000:ED47		  jmp	  update_status_flags_and_exit
F000:ED4A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED4A
F000:ED4A test_ascii_intl_xlat:					      ;	CODE XREF: int_09_handler+3BEj
F000:ED4A		  cmp	  bx, offset keypad_scancode_to_ascii_default
F000:ED4E		  jnz	  short	test_ascii_intl_xlat_2
F000:ED50		  cmp	  al, 50h ; 'P'
F000:ED52		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED54		  cmp	  al, 4Dh ; 'M'
F000:ED56		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED58		  cmp	  al, 0
F000:ED5A		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED5C		  cmp	  al, 47h ; 'G'
F000:ED5E		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED60		  cmp	  al, 98h ; '˜'
F000:ED62		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED64		  cmp	  al, 99h ; '™'
F000:ED66		  jz	  short	pre_put_ax_in_keyb_buffer_2
F000:ED68
F000:ED68 try_intl_xlat_0:					      ;	CODE XREF: int_09_handler+3E6j
F000:ED68							      ;	int_09_handler+3EAj
F000:ED68							      ;	int_09_handler+3EEj
F000:ED68							      ;	int_09_handler+3F2j ...
F000:ED68		  jmp	  try_intl_xlat
F000:ED6B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED6B
F000:ED6B test_ascii_intl_xlat_2:				      ;	CODE XREF: int_09_handler+3C7j
F000:ED6B		  cmp	  al, 5Ch ; '\'
F000:ED6D		  jz	  short	try_intl_xlat_0
F000:ED6F		  cmp	  al, 7Ch ; '|'
F000:ED71		  jz	  short	try_intl_xlat_0
F000:ED73		  cmp	  al, 7Eh ; '~'
F000:ED75		  jz	  short	try_intl_xlat_0
F000:ED77		  cmp	  al, 60h ; '`'
F000:ED79		  jz	  short	try_intl_xlat_0
F000:ED7B		  cmp	  al, 0Dh
F000:ED7D		  jz	  short	try_intl_xlat_0
F000:ED7F		  cmp	  al, 5Eh ; '^'
F000:ED81		  jz	  short	try_intl_xlat_0
F000:ED83		  cmp	  al, 3Ch ; '<'
F000:ED85		  jz	  short	try_intl_xlat_0
F000:ED87		  cmp	  al, 23h ; '#'
F000:ED89		  jz	  short	try_intl_xlat_0
F000:ED8B		  cmp	  al, 7Bh ; '{'
F000:ED8D		  jz	  short	try_intl_xlat_0
F000:ED8F		  cmp	  al, 7Dh ; '}'
F000:ED91		  jz	  short	try_intl_xlat_0
F000:ED93		  cmp	  al, 0Ah
F000:ED95		  jz	  short	try_intl_xlat_0
F000:ED97
F000:ED97 pre_put_ax_in_keyb_buffer_2:				      ;	CODE XREF: int_09_handler+3CBj
F000:ED97							      ;	int_09_handler+3CFj
F000:ED97							      ;	int_09_handler+3D3j
F000:ED97							      ;	int_09_handler+3D7j ...
F000:ED97		  jmp	  pre_put_ax_in_keyb_buffer
F000:ED9A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:ED9A
F000:ED9A ctrl_alt_del_pressed:					      ;	CODE XREF: int_09_handler+2EAj
F000:ED9A							      ;	int_09_handler+302j
F000:ED9A		  mov	  bx, p400.POST_reset_flag
F000:ED9D		  mov	  word ptr [bx], 1234h		      ;	ctrl + alt + del pressed
F000:EDA1		  call	  pic_eoi
F000:EDA4		  jmp	  reset_vector
F000:EDA7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EDA7
F000:EDA7 ctrl_break_pressed:					      ;	CODE XREF: int_09_handler+2DEj
F000:EDA7		  mov	  ax, ds:p400.keyb_buffer_start_offset_ptr
F000:EDAA		  mov	  ds:p400.keyb_buffer_head_ptr,	ax
F000:EDAD		  mov	  ds:p400.keyb_buffer_tail_ptr,	ax
F000:EDB0		  push	  ds
F000:EDB1		  mov	  ax, 40h ; '@'
F000:EDB4		  mov	  ds, ax			      ;	ds = 40h
F000:EDB6		  mov	  bx, p400.ctrl_break_flag
F000:EDB9		  mov	  byte ptr [bx], 10000000b	      ;	set break pressed
F000:EDBC		  pop	  ds
F000:EDBD		  int	  1Bh				      ;	CTRL-BREAK KEY
F000:EDBF		  xor	  ax, ax			      ;	0 in keyb buffer
F000:EDC1		  call	  put_char_in_keyb_buffer
F000:EDC4		  jmp	  update_status_flags_and_exit
F000:EDC7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EDC7
F000:EDC7 print_screen_pressed:					      ;	CODE XREF: int_09_handler+A8j
F000:EDC7		  call	  pic_eoi
F000:EDCA		  call	  get_keyb_buffer_next_slot
F000:EDCD		  jb	  short	exit_1
F000:EDCF		  int	  5				      ;	 - PRINT-SCREEN	KEY
F000:EDCF							      ;	automatically called by	keyboard scanner when print-screen key is pressed
F000:EDD1
F000:EDD1 exit_1:						      ;	CODE XREF: int_09_handler+446j
F000:EDD1		  jmp	  pop_and_exit
F000:EDD1 int_09_handler  endp
F000:EDD1
F000:EDD4
F000:EDD4 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EDD4
F000:EDD4 ;	Entry:
F000:EDD4 ;	    AL = scancode to store in keyboard buffer
F000:EDD4 ;	    AH = ascii to store	in keyboard buffer
F000:EDD4
F000:EDD4 put_char_in_keyb_buffer proc near			      ;	CODE XREF: int_09_handler:put_ax_in_keyb_bufferp
F000:EDD4							      ;	int_09_handler+43Ap
F000:EDD4		  cli
F000:EDD5		  call	  get_keyb_buffer_next_slot
F000:EDD8		  jb	  short	buffer_full
F000:EDDA		  mov	  si, ds:p400.keyb_buffer_tail_ptr
F000:EDDE		  mov	  [si],	ax
F000:EDE0		  inc	  si
F000:EDE1		  inc	  si
F000:EDE2		  cmp	  si, ds:p400.keyb_buffer_end_offset_ptr
F000:EDE6		  jb	  short	l0
F000:EDE8		  mov	  si, ds:p400.keyb_buffer_start_offset_ptr
F000:EDEC
F000:EDEC l0:							      ;	CODE XREF: put_char_in_keyb_buffer+12j
F000:EDEC		  mov	  ds:p400.keyb_buffer_tail_ptr,	si
F000:EDF0		  retn
F000:EDF1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EDF1
F000:EDF1 buffer_full:						      ;	CODE XREF: put_char_in_keyb_buffer+4j
F000:EDF1		  sti
F000:EDF2		  call	  play_bell_sound
F000:EDF5		  retn
F000:EDF5 put_char_in_keyb_buffer endp
F000:EDF5
F000:EDF6
F000:EDF6 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EDF6
F000:EDF6 ;	Returns:
F000:EDF6 ;	    SI = Keyboard buffer next slot
F000:EDF6 ;	    Carry = Set	if buffer is buffer is full, Clear otherwise
F000:EDF6
F000:EDF6 get_keyb_buffer_next_slot proc near			      ;	CODE XREF: int_09_handler+443p
F000:EDF6							      ;	put_char_in_keyb_buffer+1p
F000:EDF6		  mov	  si, ds:p400.keyb_buffer_tail_ptr
F000:EDFA		  inc	  si
F000:EDFB		  inc	  si
F000:EDFC		  cmp	  si, ds:p400.keyb_buffer_end_offset_ptr
F000:EE00		  jb	  short	l0
F000:EE02		  mov	  si, ds:p400.keyb_buffer_start_offset_ptr
F000:EE06
F000:EE06 l0:							      ;	CODE XREF: get_keyb_buffer_next_slot+Aj
F000:EE06		  cmp	  si, ds:p400.keyb_buffer_head_ptr
F000:EE0A		  jz	  short	full
F000:EE0C		  clc
F000:EE0D		  jmp	  short	end
F000:EE0F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EE0F
F000:EE0F full:							      ;	CODE XREF: get_keyb_buffer_next_slot+14j
F000:EE0F		  stc
F000:EE10
F000:EE10 end:							      ;	CODE XREF: get_keyb_buffer_next_slot+17j
F000:EE10		  retn
F000:EE10 get_keyb_buffer_next_slot endp
F000:EE10
F000:EE11
F000:EE11 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EE11
F000:EE11 ;	Entry:
F000:EE11 ;	    BX+AL: pointer to byte to translate
F000:EE11 ;	Returns:
F000:EE11 ;	    AL:	translated byte
F000:EE11
F000:EE11 scancode_to_ascii proc near				      ;	CODE XREF: int_09_handler:do_keypad_scancode_to_ascii_2p
F000:EE11							      ;	int_09_handler+333p
F000:EE11							      ;	int_09_handler+368p
F000:EE11							      ;	int_09_handler+3B9p
F000:EE11		  push	  ds
F000:EE12		  push	  ax
F000:EE13		  mov	  ax, cs
F000:EE15		  mov	  ds, ax			      ;	ds = cs	(tables	are in BIOS segment)
F000:EE17		  pop	  ax
F000:EE18		  dec	  al				      ;	al - 1 (?)
F000:EE1A		  xlat					      ;	al = [ds:bx+al]
F000:EE1B		  pop	  ds
F000:EE1C		  retn
F000:EE1C scancode_to_ascii endp
F000:EE1C
F000:EE1D
F000:EE1D ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EE1D
F000:EE1D
F000:EE1D pic_eoi	  proc near				      ;	CODE XREF: int_09_handler:update_and_exit_5p
F000:EE1D							      ;	int_09_handler:update_status_flags_and_exitp
F000:EE1D							      ;	int_09_handler+240p
F000:EE1D							      ;	int_09_handler+41Ap ...
F000:EE1D		  cli
F000:EE1E		  mov	  al, 20h ; ' '
F000:EE20		  mov	  dx, 20h ; ' '
F000:EE23		  out	  dx, al			      ;	out 20,20; Tell	PIC to resume interrupts
F000:EE24		  retn
F000:EE24 pic_eoi	  endp
F000:EE24
F000:EE24 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EE25 tbl_scancode_to_ascii_default	db 1Bh,	31h, 32h, 33h, 34h, 35h, 36h, 37h, 38h,	39h, 30h, 2Dh, 3Dh, 8, 9, 71h, 77h, 65h; field_0
F000:EE25							      ;	DATA XREF: int_09_handler:use_scancode_tbl_defaulto
F000:EE25							      ;	int_09_handler+DBo
F000:EE25		  db 72h, 74h, 79h, 75h, 69h, 6Fh, 70h,	5Bh, 5Dh, 0Dh, 0FEh, 61h, 73h, 64h, 66h, 67h, 68h; field_0
F000:EE25		  db 6Ah, 6Bh, 6Ch, 3Bh, 27h, 48h, 0FEh, 4Bh, 7Ah, 78h,	63h, 76h, 62h, 6Eh, 6Dh, 2Ch, 2Eh; field_0
F000:EE25		  db 2Fh, 0FEh,	10h, 0FEh, 20h,	0FEh, 3Bh, 3Ch,	3Dh, 3Eh, 3Fh, 40h, 41h, 42h, 43h, 44h;	field_0
F000:EE25		  db 2 dup(0FEh)			      ;	field_0
F000:EE6B tbl_scancode_to_ascii_shift db 1Bh, 21h, 40h,	23h, 24h, 25h, 5Eh, 26h, 2Ah, 28h, 29h,	5Fh, 2Bh, 8, 0Fh, 51h, 57h; field_0
F000:EE6B							      ;	DATA XREF: int_09_handler:use_scancode_tbl_shifto
F000:EE6B							      ;	int_09_handler+D5o
F000:EE6B							      ;	int_09_handler:use_scancode_tbl_shift_2o
F000:EE6B		  db 45h, 52h, 54h, 59h, 55h, 49h, 4Fh,	50h, 7Bh, 7Dh, 0Dh, 0FFh, 41h, 53h, 44h, 46h, 47h; field_0
F000:EE6B		  db 48h, 4Ah, 4Bh, 4Ch, 3Ah, 22h, 85h,	0FFh, 87h, 5Ah,	58h, 43h, 56h, 42h, 4Eh, 4Dh, 3Ch; field_0
F000:EE6B		  db 3Eh, 3Fh, 0FFh, 0FEh, 0FFh, 20h, 0FFh, 54h, 55h, 56h, 57h,	58h, 59h, 5Ah, 5Bh, 5Ch; field_0
F000:EE6B		  db 5Dh, 0FFh,	0FEh			      ;	field_0
F000:EEB1 tbl_scancode_to_ascii_ctrl db	1Bh, 0E1h, 3, 0E3h, 0E4h, 0E5h,	1Eh, 0E7h, 0E8h, 0E9h, 0E0h, 1Fh, 0F5h,	7Fh, 8Dh; field_0
F000:EEB1							      ;	DATA XREF: int_09_handler+F5o
F000:EEB1		  db 11h, 17h, 5, 12h, 14h, 19h, 15h, 9, 0Fh, 10h, 1Bh,	1Dh, 0Ah, 0FFh,	1, 13h,	4, 6, 7; field_0
F000:EEB1		  db 8,	0Ah, 0Bh, 0Ch, 0F6h, 0F7h, 90h,	0FFh, 73h, 1Ah,	18h, 3,	16h, 2,	0Eh, 0Dh, 0F9h;	field_0
F000:EEB1		  db 0FAh, 0FBh, 0FFh, 72h, 0FFh, 20h, 0FFh, 5Eh, 5Fh, 60h, 61h, 62h, 63h, 64h,	65h, 66h; field_0
F000:EEB1		  db 67h, 0FFh,	0FEh			      ;	field_0
F000:EEF7 tbl_scancode_to_ascii_alt db 8Bh, 78h, 79h, 7Ah, 7Bh,	7Ch, 7Dh, 7Eh, 7Fh, 80h, 81h, 82h, 83h,	8Ch, 8Eh, 10h, 11h; field_0
F000:EEF7							      ;	DATA XREF: int_09_handler+EAo
F000:EEF7		  db 12h, 13h, 14h, 15h, 16h, 17h, 18h,	19h, 0EBh, 0F0h, 8Fh, 0FFh, 1Eh, 1Fh, 20h, 21h;	field_0
F000:EEF7		  db 22h, 23h, 24h, 25h, 26h, 0F8h, 0F1h, 91h, 0FFh, 92h, 2Ch, 2Dh, 2Eh, 2Fh, 30h, 31h;	field_0
F000:EEF7		  db 32h, 89h, 8Ah, 0F2h, 0FFh,	46h, 0FFh, 20h,	0FFh, 68h, 69h,	6Ah, 6Bh, 6Ch, 6Dh, 6Eh; field_0
F000:EEF7		  db 6Fh, 70h, 71h, 0FFh, 0FEh		      ;	field_0
F000:EF3D keypad_scancode_to_ascii_default db 37h, 38h,	39h, 50h, 34h, 35h, 36h, 4Dh, 31h, 32h,	33h, 30h, 2Dh, 0, 2Bh, 2Eh, 0Dh; field_0
F000:EF3D							      ;	DATA XREF: int_09_handler+32Do
F000:EF3D							      ;	int_09_handler:use_keypad_scancode_tbl_defaulto
F000:EF3D							      ;	int_09_handler:test_ascii_intl_xlato
F000:EF3D		  db 47h, 98h, 99h, 5Eh, 3Eh, 40h, 5Bh,	5Dh   ;	field_0
F000:EF56 keypad_scancode_to_ascii_shift db 5Ch, 7Eh, 49h, 86h,	7Ch, 0F3h, 0F4h, 88h, 4Fh, 60h,	51h, 9Bh, 53h, 0, 52h, 0A1h, 0Dh; field_0
F000:EF56							      ;	DATA XREF: int_09_handler:use_keypad_scancode_tbl_shifto
F000:EF56		  db 4Ah, 0A2h,	0A3h, 5Eh, 3Ch,	23h, 7Bh, 7Dh ;	field_0
F000:EF6F keypad_scancode_to_ascii_ctrl	db 93h,	94h, 84h, 96h, 95h, 0FCh, 0FDh,	74h, 75h, 9Ah, 76h, 9Ch, 9Dh, 0, 9Fh, 0A4h, 0Ah; field_0
F000:EF6F							      ;	DATA XREF: int_09_handler:l28o
F000:EF6F		  db 77h, 0ACh,	0ADh, 0A7h, 0A8h, 0A9h,	0AAh, 0ABh; field_0
F000:EF88 keypad_scancode_to_ascii_alt db 3 dup(0FEh), 97h, 3 dup(0FEh), 0EAh, 4 dup(0FEh), 9Eh, 0FEh, 0A0h, 0A5h, 8Fh,	0A6h; field_0
F000:EF88							      ;	DATA XREF: int_09_handler:use_keypad_scancode_tbl_alto
F000:EF88		  db 0B6h, 0B7h, 0AEh, 0AFh, 45h, 4Ch, 4Eh    ;	field_0
F000:EFA1		  db 26h dup(0FFh)
F000:EFC7 diskette_params_values diskette_params <0CFh,	2, 25h,	2, 9, 2Ah, 0FFh, 50h, 0F6h, 19h, 4>
F000:EFC7							      ;	DATA XREF: F000:FF1Fo
F000:EFD2
F000:EFD2 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EFD2
F000:EFD2
F000:EFD2 int_17_handler  proc far				      ;	DATA XREF: F000:FF11o
F000:EFD2		  call	  int_push_regs
F000:EFD5		  mov	  di, 6
F000:EFD8		  nop
F000:EFD9		  call	  convert_ah_to_di_idx
F000:EFDC		  jb	  short	exit
F000:EFDE		  mov	  bx, dx
F000:EFE0		  xor	  cx, cx
F000:EFE2		  mov	  cl, [bx+78h]
F000:EFE6		  shl	  bx, 1
F000:EFE8		  mov	  dx, [bx+8]
F000:EFEC		  or	  dx, dx
F000:EFEE		  jz	  short	loc_FF049
F000:EFF0		  jmp	  word ptr cs:jump_tbl[di]
F000:EFF0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EFF5 jump_tbl:						      ;	DATA XREF: int_17_handler+1Er
F000:EFF5		  dw offset int_17_00_handler
F000:EFF7		  dw offset int_17_01_handler
F000:EFF9		  dw offset int_17_02_handler
F000:EFFB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:EFFB
F000:EFFB exit:							      ;	CODE XREF: int_17_handler+Aj
F000:EFFB		  jmp	  short	loc_FF049
F000:EFFB int_17_handler  endp
F000:EFFB
F000:EFFD
F000:EFFD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:EFFD
F000:EFFD ;
F000:EFFD ;	Sends one character to the specified parallel printer and returns the
F000:EFFD ;	current	status of the printer.
F000:EFFD ;
F000:EFFD ;	   On entry:	  AH	     00h
F000:EFFD ;			  AL	     Character to print
F000:EFFD ;			  DX	     Parallel printer number (0	- LPT1,	1 - LPT2,
F000:EFFD ;				     etc)
F000:EFFD ;
F000:EFFD ;	   Returns:	  AH	     Printer status (see Service 02h)
F000:EFFD
F000:EFFD int_17_00_handler proc far				      ;	CODE XREF: int_17_handler+1Ej
F000:EFFD							      ;	DATA XREF: int_17_handler:jump_tblo
F000:EFFD		  mov	  ah, al
F000:EFFF		  xor	  bx, bx
F000:F001		  inc	  dx
F000:F002
F000:F002 l0:							      ;	CODE XREF: int_17_00_handler+1Ej
F000:F002							      ;	int_17_00_handler+20j
F000:F002		  in	  al, dx
F000:F003		  test	  al, 80h
F000:F005		  jz	  short	l1
F000:F007		  mov	  al, ah
F000:F009		  dec	  dx
F000:F00A		  out	  dx, al
F000:F00B		  inc	  dx
F000:F00C		  inc	  dx
F000:F00D		  pushf
F000:F00E		  cli
F000:F00F		  mov	  al, 0Dh
F000:F011		  out	  dx, al
F000:F012		  mov	  al, 0Ch
F000:F014		  out	  dx, al
F000:F015		  popf
F000:F016		  mov	  cl, ah
F000:F018		  jmp	  short	int_17_exit
F000:F01A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F01A
F000:F01A l1:							      ;	CODE XREF: int_17_00_handler+8j
F000:F01A		  dec	  bx
F000:F01B		  jnz	  short	l0
F000:F01D		  loop	  l0
F000:F01F		  mov	  ch, 1
F000:F021		  mov	  cl, ah
F000:F023		  jmp	  short	loc_FF03E
F000:F023 int_17_00_handler endp
F000:F023
F000:F025
F000:F025 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F025
F000:F025 ;
F000:F025 ;	Sends initialization control codes to the specified parallel printer
F000:F025 ;	and returns the	current	status of the printer.
F000:F025 ;
F000:F025 ;	   On entry:	  AH	     01h
F000:F025 ;			  DX	     Parallel printer number (0	= LPT1,	1 = LPT2,
F000:F025 ;				     etc.)
F000:F025 ;
F000:F025 ;	   Returns:	  AH	     Printer status (See service 02h)
F000:F025
F000:F025 int_17_01_handler proc far				      ;	CODE XREF: int_17_handler+1Ej
F000:F025							      ;	DATA XREF: int_17_handler+25o
F000:F025		  mov	  cl, al
F000:F027		  inc	  dx
F000:F028		  inc	  dx
F000:F029		  mov	  al, 8
F000:F02B		  out	  dx, al
F000:F02C		  push	  cx
F000:F02D		  mov	  cx, 32h ; '2'
F000:F030
F000:F030 delay0:						      ;	CODE XREF: int_17_01_handler:delay0j
F000:F030		  loop	  delay0
F000:F032		  pop	  cx
F000:F033		  mov	  al, 0Ch
F000:F035		  out	  dx, al
F000:F036
F000:F036 int_17_exit:						      ;	CODE XREF: int_17_00_handler+1Bj
F000:F036		  dec	  dx
F000:F037		  xor	  ch, ch
F000:F039		  jmp	  short	loc_FF03E
F000:F039 int_17_01_handler endp
F000:F039
F000:F03B
F000:F03B ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F03B
F000:F03B ;
F000:F03B ;	Returns	status information about the specified parallel	printer.
F000:F03B ;
F000:F03B ;	   On entry:	  AH	     02h
F000:F03B ;			  DX	     Parallel printer number (0	= LPT1,	1 = LPT2,
F000:F03B ;				     etc.)
F000:F03B ;
F000:F03B ;	   Returns:	  AH	     Printer status
F000:F03B
F000:F03B int_17_02_handler proc far				      ;	CODE XREF: int_17_handler+1Ej
F000:F03B							      ;	DATA XREF: int_17_handler+27o
F000:F03B		  mov	  cl, al
F000:F03D		  inc	  dx
F000:F03E
F000:F03E loc_FF03E:						      ;	CODE XREF: int_17_00_handler+26j
F000:F03E							      ;	int_17_01_handler+14j
F000:F03E		  in	  al, dx
F000:F03F		  and	  al, 0F8h
F000:F041		  xor	  al, 48h
F000:F043		  mov	  ah, al
F000:F045		  or	  ah, ch
F000:F047		  mov	  al, cl
F000:F049
F000:F049 loc_FF049:						      ;	CODE XREF: int_17_handler+1Cj
F000:F049							      ;	int_17_handler:exitj
F000:F049		  jmp	  near ptr pop_regs_and_iret
F000:F049 int_17_02_handler endp
F000:F049
F000:F049 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F04C		  db 19h dup(0FFh)
F000:F065
F000:F065 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F065
F000:F065
F000:F065 int_10_handler  proc far				      ;	DATA XREF: F000:FF03o
F000:F065		  call	  int_push_regs
F000:F068		  cld
F000:F069		  mov	  di, 22h ; '"'                       ; max value for ah (22h / 2) == 11h
F000:F06C		  nop
F000:F06D		  call	  convert_ah_to_di_idx
F000:F070		  jb	  short	exit
F000:F072		  jmp	  word ptr cs:jump_tbl[di]
F000:F072 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F077 jump_tbl:						      ;	DATA XREF: int_10_handler+Dr
F000:F077		  dw offset int_10_00_handler		      ;	set video mode
F000:F079		  dw offset int_10_01_handler		      ;	set cursor size
F000:F07B		  dw offset int_10_02_handler		      ;	set cursor positions
F000:F07D		  dw offset int_10_03_handler		      ;	read cursor position and size
F000:F07F		  dw offset int_10_04_handler		      ;	read light-pen position
F000:F081		  dw offset int_10_05_handler		      ;	set active display page
F000:F083		  dw offset int_10_06_handler		      ;	scroll window up
F000:F085		  dw offset int_10_07_handler		      ;	scroll window down
F000:F087		  dw offset int_10_08_handler		      ;	read char and attribute	at cursor
F000:F089		  dw offset int_10_09_handler		      ;	write char and attribute at cursor
F000:F08B		  dw offset int_10_0a_handler		      ;	write char at cursor
F000:F08D		  dw offset int_10_0b_handler		      ;	set color palette
F000:F08F		  dw offset int_10_0c_handler		      ;	write pixel
F000:F091		  dw offset int_10_0d_handler		      ;	read pixel
F000:F093		  dw offset int_10_0e_handler		      ;	write char in TTY mode
F000:F095		  dw offset int_10_0f_handler		      ;	get current video mode
F000:F097		  dw offset int_10_10_handler		      ;	set palette registers
F000:F099 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F099
F000:F099 exit:							      ;	CODE XREF: int_10_handler+Bj
F000:F099		  jmp	  near ptr pop_regs_and_iret
F000:F099 int_10_handler  endp
F000:F099
F000:F099 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F09C		  db 8 dup(0FFh)
F000:F0A4 video_6845_init_tbl_tv db 38h, 28h, 2Dh, 8, 1Fh, 6, 19h, 1Ch,	2, 7, 6, 7, 4 dup(0); init_modes_0_1
F000:F0A4							      ;	DATA XREF: POST_init_ints_and_more+2E2o
F000:F0A4		  db 71h, 50h, 59h, 10h, 1Fh, 6, 19h, 1Ch, 2, 7, 6, 7, 4 dup(0); init_modes_2_3
F000:F0A4		  db 38h, 28h, 2Dh, 8, 7Fh, 6, 64h, 70h, 2, 1, 6, 7, 4 dup(0); init_modes_4_5_6_8
F000:F0A4		  db 61h, 50h, 52h, 0Fh, 19h, 6, 2 dup(19h), 2,	0Dh, 0Bh, 0Ch, 4 dup(0); init_mode_7
F000:F0A4		  db 71h, 50h, 59h, 10h, 3Fh, 6, 32h, 38h, 2, 3, 6, 7, 4 dup(0); init_modes_9_a
F000:F0F4 video_init_more_tbl video_init_some_vars <0, 101100b,	28h, 8>	; DATA XREF: int_10_00_handler+78r
F000:F0F4							      ;	int_10_00_handler+7Dr
F000:F0F4							      ;	int_10_00_handler+84r
F000:F0F4							      ;	int_10_00_handler+8Er
F000:F0F4							      ;	video mode 0
F000:F0F8		  video_init_some_vars <0, 101000b, 28h, 8>   ;	video mode 1
F000:F0FC		  video_init_some_vars <10h, 101101b, 50h, 10h>	; video	mode 2
F000:F100		  video_init_some_vars <10h, 101001b, 50h, 10h>	; video	mode 3
F000:F104		  video_init_some_vars <20h, 101010b, 28h, 40h>	; video	mode 4
F000:F108		  video_init_some_vars <20h, 101110b, 28h, 40h>	; video	mode 5
F000:F10C		  video_init_some_vars <20h, 11110b, 50h, 40h> ; video mode 6
F000:F110		  video_init_some_vars <30h, 101001b, 50h, 40h>	; video	mode 7
F000:F114		  video_init_some_vars <20h, 101010b, 14h, 40h>	; video	mode 8
F000:F118		  video_init_some_vars <40h, 101011b, 28h, 80h>	; video	mode 9
F000:F11C		  video_init_some_vars <40h, 111011b, 50h, 80h>	; video	mode a
F000:F120
F000:F120 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F120
F000:F120 ;	Sets the video mode.
F000:F120 ;
F000:F120 ;	   On entry:	  AH	     00h
F000:F120 ;			  AL	     Video mode
F000:F120 ;
F000:F120 ;	   Returns:	  None
F000:F120
F000:F120 int_10_00_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F120							      ;	DATA XREF: int_10_handler:jump_tblo
F000:F120		  push	  ax
F000:F121		  and	  al, 7Fh			      ;	filter bit 7. when 1 ->	clear screen
F000:F123		  mov	  bx, ds:p400.installed_hardware
F000:F127		  and	  bl, 110000b
F000:F12A		  cmp	  bl, 110000b			      ;	is it 80x25 mono ?
F000:F12D		  jnz	  short	l0
F000:F12F		  mov	  al, 7				      ;	set 80x25 mono video mode, which is unsupported
F000:F131
F000:F131 l0:							      ;	CODE XREF: int_10_00_handler+Dj
F000:F131		  test	  byte ptr ds:p400.extra_status, 100000b ; external monochrome monitor installed ?
F000:F136		  jnz	  short	l1
F000:F138		  cmp	  al, 7				      ;	monochrome text	mode? Unsupported
F000:F13A		  jz	  short	exit
F000:F13C
F000:F13C l1:							      ;	CODE XREF: int_10_00_handler+16j
F000:F13C		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video mode enabled?
F000:F141		  jz	  short	l2
F000:F143		  cmp	  al, 7				      ;	monochrome video mono? Unsupported
F000:F145		  jbe	  short	valid_video_mode
F000:F147		  jmp	  short	exit
F000:F149 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F149
F000:F149 l2:							      ;	CODE XREF: int_10_00_handler+21j
F000:F149		  cmp	  al, 0Ah			      ;	video modes must be 0xa	or lower
F000:F14B		  jbe	  short	valid_video_mode
F000:F14D
F000:F14D exit:							      ;	CODE XREF: int_10_00_handler+1Aj
F000:F14D							      ;	int_10_00_handler+27j
F000:F14D		  pop	  ax
F000:F14E		  jmp	  near ptr pop_regs_and_iret
F000:F151 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F151
F000:F151 valid_video_mode:					      ;	CODE XREF: int_10_00_handler+25j
F000:F151							      ;	int_10_00_handler+2Bj
F000:F151		  mov	  ds:p400.crt_mode, al		      ;	save video mode	with bit 7 off
F000:F154		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video mode?
F000:F159		  jnz	  short	l3
F000:F15B		  push	  ax
F000:F15C		  mov	  dx, 3DAh
F000:F15F		  mov	  al, 3
F000:F161		  out	  dx, al			      ;	select Mode Control
F000:F162		  mov	  al, 0
F000:F164		  add	  dx, 4
F000:F167		  out	  dx, al			      ;	no border, no 16 colors, no 640x200 secondary
F000:F168		  pop	  ax
F000:F169
F000:F169 l3:							      ;	CODE XREF: int_10_00_handler+39j
F000:F169		  xor	  ah, ah
F000:F16B		  mov	  dx, 3D4h			      ;	set CRT	ctrl base address
F000:F16E		  cmp	  al, 7				      ;	monochrome video mode ?
F000:F170		  jnz	  short	is_color
F000:F172		  test	  byte ptr ds:p400.extra_status, 110000b ; external mono monitor or external color video ?
F000:F177		  jnz	  short	is_mono
F000:F179		  push	  ax				      ;	reaches	here when mode is 7 and	no external monitors. is that possible?
F000:F17A		  mov	  dx, 3DAh
F000:F17D		  mov	  al, 3
F000:F17F		  out	  dx, al			      ;	Select mode control
F000:F180		  add	  dx, 4
F000:F183		  mov	  al, 11b			      ;	??? Not	used in	Tandy color modes ?
F000:F185		  out	  dx, al
F000:F186		  pop	  ax
F000:F187
F000:F187 is_mono:						      ;	CODE XREF: int_10_00_handler+57j
F000:F187		  mov	  ah, 21h ; '!'
F000:F189		  mov	  dx, 3B4h			      ;	set CRT	ctrl base address
F000:F18C
F000:F18C is_color:						      ;	CODE XREF: int_10_00_handler+50j
F000:F18C		  push	  ax
F000:F18D		  push	  dx
F000:F18E		  xor	  ah, ah
F000:F190		  shl	  al, 1
F000:F192		  shl	  al, 1				      ;	al = al	* 4
F000:F194		  mov	  si, ax
F000:F196		  xor	  bx, bx
F000:F198		  mov	  bl, byte ptr cs:video_init_more_tbl.offset_to_6845_tbl[si]
F000:F19D		  mov	  cl, cs:video_init_more_tbl.value_for_3d8[si]
F000:F1A2		  xor	  ax, ax
F000:F1A4		  mov	  al, cs:video_init_more_tbl.nr_columns[si]
F000:F1A9		  mov	  ds:p400.crt_nr_cols, ax
F000:F1AC		  xor	  ax, ax
F000:F1AE		  mov	  ah, cs:video_init_more_tbl.video_page_size_256[si] ; f000:f0f7
F000:F1B3		  mov	  ds:p400.crt_page_len,	ax	      ;	video page size	in bytes
F000:F1B6		  pop	  dx
F000:F1B7		  pop	  ax
F000:F1B8		  mov	  ds:p400.crt_mode_set,	cl	      ;	current	setting	for reg. 3d8/3b8
F000:F1BC		  mov	  ds:p400.addr_6845, dx		      ;	CRT ctrl base address: color=3d4, mono=3b4
F000:F1C0		  add	  dx, 4
F000:F1C3		  mov	  al, ah
F000:F1C5		  out	  dx, al
F000:F1C6		  xor	  ax, ax
F000:F1C8		  mov	  es, ax			      ;	es = 0 (interrupt table)
F000:F1CA		  push	  dx
F000:F1CB		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video mode ?
F000:F1D0		  jnz	  short	skip_non_internal_color_video
F000:F1D2		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	monochrome video mono?
F000:F1D7		  jnz	  short	internal_color_video
F000:F1D9		  test	  byte ptr ds:p400.extra_status, 100000b ; external mono monitor ?
F000:F1DE		  jz	  short	internal_color_video
F000:F1E0		  jmp	  short	skip_non_internal_color_video
F000:F1E2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F1E2
F000:F1E2 internal_color_video:					      ;	CODE XREF: int_10_00_handler+B7j
F000:F1E2							      ;	int_10_00_handler+BEj
F000:F1E2		  mov	  al, 111111b			      ;	page register values:
F000:F1E2							      ;	  bit 0-2: CRT Page 0-2
F000:F1E2							      ;	  bit 3-5: Processor Page 0-2
F000:F1E2							      ;	  bit 6-7: Video Address mode  00 -> 40x25 or 80x25 alpha
F000:F1E4		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:F1E9		  jb	  short	l4
F000:F1EB		  mov	  al, 11110110b			      ;	page register values:
F000:F1EB							      ;	  bit 0-2: CRT Page 0-2
F000:F1EB							      ;	  bit 3-5: Processor Page 0-2
F000:F1EB							      ;	  bit 6-7: Video Address mode  11 -> 320x200x16	or 640x200x4
F000:F1ED
F000:F1ED l4:							      ;	CODE XREF: int_10_00_handler+C9j
F000:F1ED		  mov	  dx, 3DFh			      ;	CRT/CPU	page register
F000:F1F0		  out	  dx, al
F000:F1F1		  mov	  ds:p400.video_page_data, al
F000:F1F4		  mov	  al, 0				      ;	CRT and	CPU Page addresses = 0
F000:F1F6		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384 ; 384k RAM?
F000:F1FC		  jz	  short	l5
F000:F1FE		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640 ; 640k RAM?
F000:F204		  jz	  short	l5
F000:F206		  mov	  al, 101000b			      ;	CRT Video Page address "17" = 1
F000:F206							      ;	CPU Page Address "17" =	1
F000:F206							      ;	Only when RAM is < 384
F000:F208
F000:F208 l5:							      ;	CODE XREF: int_10_00_handler+DCj
F000:F208							      ;	int_10_00_handler+E4j
F000:F208		  mov	  dx, 3DDh			      ;	extended RAM page register
F000:F20B		  out	  dx, al
F000:F20C		  mov	  ds:p400.extended_ram,	al
F000:F20F
F000:F20F skip_non_internal_color_video:			      ;	CODE XREF: int_10_00_handler+B0j
F000:F20F							      ;	int_10_00_handler+C0j
F000:F20F		  mov	  si, 74h ; 't'
F000:F212		  mov	  di, es:[si]			      ;	int 1d.	offset to video	6845 init vars
F000:F215		  add	  di, bx			      ;	bx = offset to correct table for mode
F000:F217		  mov	  ax, es:[si+2]
F000:F21B		  mov	  es, ax
F000:F21D		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video ?
F000:F222		  jz	  short	dont_use_default_bios_video_table
F000:F224		  cmp	  ax, 0F000h			      ;	in BIOS	segment	?
F000:F227		  jb	  short	dont_use_default_bios_video_table
F000:F229		  mov	  ax, cs			      ;	use BIOS video table if	not modified by	user or	internal color video
F000:F22B		  mov	  es, ax			      ;	es = 0xf000 (bios seg)
F000:F22D		  mov	  di, offset video_6845_init_tbl_a    ;	default	bios video table
F000:F230		  add	  di, bx			      ;	offset to correct table	for mode
F000:F232
F000:F232 dont_use_default_bios_video_table:			      ;	CODE XREF: int_10_00_handler+102j
F000:F232							      ;	int_10_00_handler+107j
F000:F232		  xor	  bh, bh
F000:F234		  xor	  cx, cx
F000:F236
F000:F236 l6:							      ;	CODE XREF: int_10_00_handler+128j
F000:F236		  mov	  dx, ds:p400.addr_6845		      ;	CRT ctrl base address: color=3d4, mono=3b4
F000:F23A		  mov	  al, cl			      ;	init the 16 registers of 3d4/3d5 pointed by es:di
F000:F23C		  out	  dx, al			      ;	prepare	value to by out	(3d4)
F000:F23D		  inc	  dx
F000:F23E		  mov	  bl, cl
F000:F240		  mov	  al, es:[bx+di]
F000:F243		  out	  dx, al			      ;	send value (0x3d5)
F000:F244		  inc	  cx
F000:F245		  cmp	  cx, 10h			      ;	init 16	registers
F000:F248		  jl	  short	l6
F000:F24A		  mov	  word ptr ds:p400.cursor_row_column, 607h ; cursor size: start	line=06, end line=07
F000:F250		  mov	  word ptr ds:p400.crt_current_page_offset, 0
F000:F256		  mov	  byte ptr ds:p400.active_display_page,	0 ; active page	= 0
F000:F25B		  mov	  byte ptr ds:p400.shadow_3d9_crt_palette, 110000b ; foreground	bright=on, palette=1
F000:F260		  pop	  dx
F000:F261		  pop	  ax
F000:F262		  push	  dx
F000:F263		  test	  al, 80h			      ;	clear screen ?
F000:F265		  jnz	  short	skip_clear_screen
F000:F267		  mov	  ax, 0B800h			      ;	video base address for color
F000:F26A		  mov	  cx, 2000h			      ;	0x2000 words (16k to clear)
F000:F26D		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:F272		  jb	  short	l7
F000:F274		  mov	  cx, 4000h			      ;	0x4000 words (32k to clear)
F000:F277
F000:F277 l7:							      ;	CODE XREF: int_10_00_handler+152j
F000:F277		  mov	  bx, 720h
F000:F27A		  cmp	  byte ptr ds:p400.crt_mode, 7
F000:F27F		  jnz	  short	l8
F000:F281		  mov	  ax, 0B000h			      ;	video base address for monochrome
F000:F284		  mov	  cx, 800h			      ;	0x800 words (4k	to clear)
F000:F287		  jmp	  short	l9
F000:F289 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F289
F000:F289 l8:							      ;	CODE XREF: int_10_00_handler+15Fj
F000:F289		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:F28E		  jl	  short	l9
F000:F290		  xor	  bx, bx
F000:F292
F000:F292 l9:							      ;	CODE XREF: int_10_00_handler+167j
F000:F292							      ;	int_10_00_handler+16Ej
F000:F292		  mov	  es, ax
F000:F294		  xor	  di, di
F000:F296		  mov	  ax, bx
F000:F298		  rep stosw				      ;	and clear the screen
F000:F29A
F000:F29A skip_clear_screen:					      ;	CODE XREF: int_10_00_handler+145j
F000:F29A		  mov	  ax, ds
F000:F29C		  mov	  es, ax			      ;	ds = es	= 0x40
F000:F29E		  xor	  ax, ax
F000:F2A0		  lea	  di, ds:p400.cursor_row_col_in_pages
F000:F2A4		  mov	  cx, 8
F000:F2A7		  rep stosw				      ;	clear memory:0450h - 045fh: cursor pos in pages
F000:F2A9		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	hercules text video mode?
F000:F2AE		  jz	  short	skip_color_select
F000:F2B0		  mov	  al, 110000b			      ;	modes 0-5: palette 1 + foreground intensity
F000:F2B2		  cmp	  byte ptr ds:p400.crt_mode, 6	      ;	640x200x2 video	mode?
F000:F2B7		  jl	  short	color_select
F000:F2B9		  mov	  al, 111111b			      ;	mode 0xa: select all colors + palette 1
F000:F2BB		  cmp	  byte ptr ds:p400.crt_mode, 0Ah      ;	640x200x4 video	mode?
F000:F2C0		  jnz	  short	color_select
F000:F2C2		  mov	  al, 0				      ;	mode 8,9: off all colors
F000:F2C4
F000:F2C4 color_select:						      ;	CODE XREF: int_10_00_handler+197j
F000:F2C4							      ;	int_10_00_handler+1A0j
F000:F2C4		  mov	  dx, 3D9h
F000:F2C7		  out	  dx, al			      ;	update color register (colors +	palette	select)
F000:F2C8		  mov	  ds:p400.shadow_3d9_crt_palette, al  ;	update shadow variable
F000:F2CB
F000:F2CB skip_color_select:					      ;	CODE XREF: int_10_00_handler+18Ej
F000:F2CB		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video?
F000:F2D0		  jnz	  short	skip_something
F000:F2D2		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	hercules text video mode?
F000:F2D7		  jz	  short	skip_something
F000:F2D9		  call	  video_init_palette
F000:F2DC
F000:F2DC skip_something:					      ;	CODE XREF: int_10_00_handler+1B0j
F000:F2DC							      ;	int_10_00_handler+1B7j
F000:F2DC		  pop	  dx
F000:F2DD		  mov	  al, ds:p400.crt_mode_set
F000:F2E0		  out	  dx, al
F000:F2E1		  jmp	  near ptr pop_regs_and_iret
F000:F2E1 int_10_00_handler endp
F000:F2E1
F000:F2E4
F000:F2E4 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F2E4
F000:F2E4 ; Adjusts the	size of	the cursor by setting its start	and end	lines.
F000:F2E4 ;
F000:F2E4 ;	   On entry:	  AH	     01h
F000:F2E4 ;			  CH	     Cursor start line (bits 4 to 0)
F000:F2E4 ;			  CL	     Cursor end	line   (bits 4 to 0)
F000:F2E4 ;
F000:F2E4 ;	   Returns:	  None
F000:F2E4
F000:F2E4 int_10_01_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F2E4							      ;	DATA XREF: int_10_handler+14o
F000:F2E4		  mov	  bh, 0Ah			      ;	reg. 0a	= cursor start register
F000:F2E6		  mov	  bl, 0Bh			      ;	reg. 0b	= cursor end register, cx=has value
F000:F2E8		  call	  set_pair_value_in_6845
F000:F2EB		  mov	  ds:p400.cursor_row_column, cx	      ;	0460h=cursor end line. 0461h=cursor start line
F000:F2EF		  jmp	  near ptr pop_regs_and_iret
F000:F2EF int_10_01_handler endp
F000:F2EF
F000:F2F2
F000:F2F2 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F2F2
F000:F2F2 ; Sets the cursor position (row and column) for a specified display
F000:F2F2 ;	page.
F000:F2F2 ;
F000:F2F2 ;	   On entry:	  AH	     02h
F000:F2F2 ;			  BH	     Display page number
F000:F2F2 ;			  DH	     Row
F000:F2F2 ;			  DL	     Column
F000:F2F2 ;
F000:F2F2 ;	   Returns:	  None
F000:F2F2
F000:F2F2 int_10_02_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F2F2							      ;	DATA XREF: int_10_handler+16o
F000:F2F2		  call	  set_cursor_pos
F000:F2F5		  jmp	  near ptr pop_regs_and_iret
F000:F2F5 int_10_02_handler endp
F000:F2F5
F000:F2F8
F000:F2F8 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F2F8
F000:F2F8 ;	Sets the cursor	position (row and column) for a	specified display
F000:F2F8 ;	page.
F000:F2F8 ;
F000:F2F8 ;	   On entry:	  AH	     02h
F000:F2F8 ;			  BH	     Display page number
F000:F2F8 ;			  DH	     Row
F000:F2F8 ;			  DL	     Column
F000:F2F8 ;
F000:F2F8 ;	   Returns:	  None
F000:F2F8
F000:F2F8 set_cursor_pos  proc near				      ;	CODE XREF: int_10_02_handlerp
F000:F2F8							      ;	int_10_0e_handler+85p
F000:F2F8							      ;	int_10_0e_handler+94p
F000:F2F8		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:F2FD		  jl	  short	s0
F000:F2FF		  xor	  bh, bh			      ;	page 0 for modes >=4 (graphics mode)
F000:F301
F000:F301 s0:							      ;	CODE XREF: set_cursor_pos+5j
F000:F301		  lea	  di, ds:p400.cursor_row_col_in_pages
F000:F305		  push	  bx
F000:F306		  mov	  bl, bh			      ;	offset to correct page
F000:F308		  xor	  bh, bh			      ;	offset = page number * 2
F000:F30A		  shl	  bx, 1
F000:F30C		  mov	  [bx+di], dx			      ;	update cursor_pos_in_pages var with new	row/column value
F000:F30E		  pop	  bx
F000:F30F		  cmp	  ds:p400.active_display_page, bh     ;	page to	update same as active page?
F000:F313		  jnz	  short	exit			      ;	no? exit, then
F000:F315		  call	  update_cursor_offset
F000:F318
F000:F318 exit:							      ;	CODE XREF: set_cursor_pos+1Bj
F000:F318		  retn
F000:F318 set_cursor_pos  endp
F000:F318
F000:F319
F000:F319 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F319
F000:F319 ; entry:
F000:F319 ;   dl = column
F000:F319 ;   dh = row
F000:F319 ; return:
F000:F319 ;   cx = cursor offset in page & 0xfffe
F000:F319
F000:F319 update_cursor_offset proc near			      ;	CODE XREF: set_cursor_pos+1Dp
F000:F319							      ;	int_10_05_handler+31p
F000:F319		  mov	  al, dh
F000:F31B		  mul	  byte ptr ds:p400.crt_nr_cols	      ;	al = row * total columns
F000:F31F		  xor	  dh, dh
F000:F321		  add	  ax, dx			      ;	ax: cursor_offset = (row * total_columns) + col
F000:F323		  mov	  cx, ax
F000:F325		  mov	  ax, ds:p400.crt_current_page_offset
F000:F328		  shr	  ax, 1				      ;	page_offset / 2	(get rid of attributes bytes)
F000:F32A		  add	  cx, ax			      ;	cx = page_offset + cursor_offset
F000:F32C		  mov	  bh, 0Eh			      ;	reg 0e = cursor	start address hi
F000:F32E		  mov	  bl, 0Fh			      ;	reg 0f = cursor	start address lo
F000:F330		  jmp	  set_pair_value_in_6845
F000:F330 update_cursor_offset endp
F000:F330
F000:F333
F000:F333 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F333
F000:F333 ;	Reports	the cursor position (row and column) and size for a specified
F000:F333 ;	display	page.
F000:F333 ;
F000:F333 ;	   On entry:	  AH	     03h
F000:F333 ;			  BH	     Display page number
F000:F333 ;
F000:F333 ;	   Returns:	  CH	     Cursor start line
F000:F333 ;			  CL	     Cursor end	line
F000:F333 ;			  DH	     Row
F000:F333 ;			  DL	     Column
F000:F333 ; Attributes:	bp-based frame
F000:F333
F000:F333 int_10_03_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F333							      ;	DATA XREF: int_10_handler+18o
F000:F333
F000:F333 arg_cursor_position= word ptr	 0Ah
F000:F333 arg_cursor_address_position= word ptr	 0Ch
F000:F333
F000:F333		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:F338		  jl	  short	s0
F000:F33A		  xor	  bh, bh			      ;	page 0 for modes >=4 (graphics)
F000:F33C
F000:F33C s0:							      ;	CODE XREF: int_10_03_handler+5j
F000:F33C		  mov	  bl, bh
F000:F33E		  call	  get_cursor_row_col_for_page
F000:F341		  mov	  bp, sp			      ;	update stack arguments (who knew!)
F000:F343		  mov	  [bp+arg_cursor_position], dx
F000:F346		  mov	  cx, ds:p400.cursor_row_column
F000:F34A		  mov	  [bp+arg_cursor_address_position], cx
F000:F34D		  jmp	  near ptr pop_regs_and_iret
F000:F34D int_10_03_handler endp
F000:F34D
F000:F350
F000:F350 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F350
F000:F350 ;	Reports	the position and status	of the light pen.
F000:F350 ;
F000:F350 ;	   On entry:	  AH	     04h
F000:F350 ;
F000:F350 ;	   Returns:	  AH	     Status (0=not triggered, 1=triggered)
F000:F350 ;			  BX	     Pixel column number (0-319	or 0-639)
F000:F350 ;			  CH	     Raster line number	(0-199)
F000:F350 ;			  DH	     Character row number (0-24)
F000:F350 ;			  DL	     Character column number (0-39 or 0-79)
F000:F350 ;
F000:F350 ; Attributes:	bp-based frame
F000:F350
F000:F350 int_10_04_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F350							      ;	DATA XREF: int_10_handler+1Ao
F000:F350
F000:F350 arg_light_pen_row_col= word ptr  0Ah
F000:F350 arg_light_pen_row_in_pixels= byte ptr	 0Dh
F000:F350 arg_light_pen_col_in_pixels= word ptr	 0Eh
F000:F350
F000:F350		  mov	  dx, 3DAh			      ;	int: read light-pen pos
F000:F353		  in	  al, dx			      ;	Video status bits:
F000:F353							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F353							      ;	1: 1=light pen is triggered; 0=armed
F000:F353							      ;	2: 1=light pen switch is open; 0=closed
F000:F353							      ;	3: 1=vertical sync pulse is occurring.
F000:F354		  mov	  ah, 0				      ;	ah = 0.	light pen not triggered
F000:F356		  test	  al, 2
F000:F358		  jnz	  short	light_pen_present
F000:F35A		  jmp	  exit
F000:F35D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F35D
F000:F35D light_pen_present:					      ;	CODE XREF: int_10_04_handler+8j
F000:F35D		  mov	  dx, ds:p400.addr_6845
F000:F361		  mov	  al, 10h
F000:F363		  out	  dx, al			      ;	out 3d4, 10h (select read light	pen hi)
F000:F364		  inc	  dx
F000:F365		  in	  al, dx			      ;	al = light pen hi
F000:F366		  mov	  bh, al
F000:F368		  dec	  dx
F000:F369		  mov	  al, 11h			      ;	out 3d4, 11h (select light pen lo)
F000:F36B		  out	  dx, al
F000:F36C		  inc	  dx
F000:F36D		  in	  al, dx			      ;	al = light pen lo
F000:F36E		  mov	  ah, bh			      ;	ax = light pen (hi,lo)
F000:F370		  sub	  ax, 4
F000:F373		  mov	  dx, 3DBh
F000:F376		  out	  dx, al			      ;	Video: light pen latch reset.
F000:F376							      ;	Any OUT	clears the latch.
F000:F377		  mov	  bp, sp
F000:F379		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:F37E		  jnb	  short	modes_4_and_up
F000:F380
F000:F380 modes_0_1_2_3:					      ;	dx = 0
F000:F380		  xor	  dx, dx
F000:F382		  mov	  bx, ds:p400.crt_nr_cols
F000:F386		  div	  bx				      ;	ax = current_row = light_pen_pos / nr_cols.
F000:F386							      ;	dx = cols
F000:F388		  mov	  dh, al			      ;	dh = current_row for light pen
F000:F38A		  mov	  [bp+arg_light_pen_row_col], dx      ;	dx = cols
F000:F38D		  mov	  cl, 3
F000:F38F		  shl	  al, cl			      ;	al = current_row * 8 (in pixels)
F000:F391		  mov	  [bp+arg_light_pen_row_in_pixels], al
F000:F394		  xor	  bx, bx			      ;	bx = 0
F000:F396		  mov	  bl, dl			      ;	bl = dl	(cols)
F000:F398		  shl	  bx, cl			      ;	bx = bx	* 8 (in	pixels)
F000:F39A		  mov	  [bp+arg_light_pen_col_in_pixels], bx
F000:F39D		  jmp	  exit_tirggered
F000:F3A0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F3A0
F000:F3A0 modes_4_and_up:					      ;	CODE XREF: int_10_04_handler+2Ej
F000:F3A0		  xor	  dx, dx			      ;	dx = 0
F000:F3A2		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:F3A7		  jnb	  short	modes_9_a
F000:F3A9		  add	  ax, 2				      ;	ax = light_pen pos + 2
F000:F3AC		  cmp	  ax, 4096
F000:F3AF		  jb	  short	s0
F000:F3B1		  sub	  ax, 4056			      ;	ax = ax	- 4056
F000:F3B4
F000:F3B4 s0:							      ;	CODE XREF: int_10_04_handler+5Fj
F000:F3B4		  mov	  bx, 40			      ;	ax = rows (pos / 40) (40 = cols)
F000:F3B7		  div	  bx				      ;	dx = cols
F000:F3B9		  shl	  ax, 1				      ;	rows = rows * 2	(modes 5, 6 & 8	have 2 interlaces)
F000:F3BB		  mov	  [bp+arg_light_pen_row_in_pixels], al
F000:F3BE		  shl	  dx, 1
F000:F3C0		  shl	  dx, 1				      ;	mode 8 = 160x200.
F000:F3C0							      ;	cols in	pixels = cols *	4. compesate for div(40) instead of div(20)
F000:F3C2		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:F3C7		  jz	  short	mode_8
F000:F3C9		  shl	  dx, 1				      ;	mode 5 = 320x200
F000:F3C9							      ;	cols in	pixels = cols *	8
F000:F3CB		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:F3D0		  jnz	  short	mode_8
F000:F3D2		  shl	  dx, 1				      ;	mode 6 = 640x200
F000:F3D2							      ;	cols in	pixels = cols *	16. compesate for div(40) instead of div(80)
F000:F3D4
F000:F3D4 mode_8:						      ;	CODE XREF: int_10_04_handler+77j
F000:F3D4							      ;	int_10_04_handler+80j
F000:F3D4		  mov	  [bp+arg_light_pen_col_in_pixels], dx
F000:F3D7		  jmp	  short	from_pixel_to_char
F000:F3D9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F3D9
F000:F3D9 modes_9_a:						      ;	CODE XREF: int_10_04_handler+57j
F000:F3D9		  mov	  bx, 80			      ;	divide by 80 columns
F000:F3DC		  cmp	  ax, 12288
F000:F3DF		  jb	  short	s1
F000:F3E1		  sub	  ax, 12288
F000:F3E4		  div	  bx				      ;	ax = number of rows
F000:F3E4							      ;	dx = number of cols
F000:F3E6		  shl	  ax, 1
F000:F3E8		  shl	  ax, 1				      ;	ax = number of rows * 4	(modes 9 & a have 4 interlaces)
F000:F3EA		  add	  ax, 3				      ;	ax += 3	(to compensate?)
F000:F3ED		  jmp	  short	s4
F000:F3EF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F3EF
F000:F3EF s1:							      ;	CODE XREF: int_10_04_handler+8Fj
F000:F3EF		  cmp	  ax, 8192
F000:F3F2		  jb	  short	s2
F000:F3F4		  sub	  ax, 8192
F000:F3F7		  div	  bx				      ;	ax = number of rows
F000:F3F7							      ;	dx = number of cols
F000:F3F9		  shl	  ax, 1				      ;	ax = number of rows * 4	(modes 9 & a have 4 interlaces)
F000:F3FB		  shl	  ax, 1
F000:F3FD		  add	  ax, 2				      ;	ax += 2	(to compensate?)
F000:F400		  jmp	  short	s4
F000:F402 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F402
F000:F402 s2:							      ;	CODE XREF: int_10_04_handler+A2j
F000:F402		  cmp	  ax, 4096
F000:F405		  jb	  short	s3
F000:F407		  sub	  ax, 4096
F000:F40A		  div	  bx				      ;	ax = number of rows
F000:F40A							      ;	dx = number of cols
F000:F40C		  shl	  ax, 1				      ;	ax = number of rows * 4	+ 1
F000:F40E		  shl	  ax, 1
F000:F410		  add	  ax, 1
F000:F413		  jmp	  short	s4
F000:F415 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F415
F000:F415 s3:							      ;	CODE XREF: int_10_04_handler+B5j
F000:F415		  div	  bx
F000:F417		  shl	  ax, 1
F000:F419		  shl	  ax, 1				      ;	ax = number of rows * 4	(modes 9 & a have 4 interlaces)
F000:F41B
F000:F41B s4:							      ;	CODE XREF: int_10_04_handler+9Dj
F000:F41B							      ;	int_10_04_handler+B0j
F000:F41B							      ;	int_10_04_handler+C3j
F000:F41B		  shl	  dx, 1
F000:F41D		  shl	  dx, 1				      ;	mode 9 = 320x200 16 colors
F000:F41D							      ;	cols in	pixels = cols *	4. compesate for div(80) instead of div(40)
F000:F41F		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:F424		  jnz	  short	s5
F000:F426		  shl	  dx, 1				      ;	mode a = 640x200 4 colors
F000:F426							      ;	cols in	pixels = cols *	8.
F000:F428
F000:F428 s5:							      ;	CODE XREF: int_10_04_handler+D4j
F000:F428		  mov	  [bp+arg_light_pen_row_in_pixels], al
F000:F42B		  mov	  [bp+arg_light_pen_col_in_pixels], dx
F000:F42E
F000:F42E from_pixel_to_char:					      ;	CODE XREF: int_10_04_handler+87j
F000:F42E		  mov	  al, [bp+arg_light_pen_row_in_pixels]
F000:F431		  mov	  cl, 3
F000:F433		  shr	  al, cl			      ;	al = row in chars
F000:F435		  mov	  dx, [bp+arg_light_pen_col_in_pixels]
F000:F438		  shr	  dx, cl			      ;	dl = col in chars
F000:F43A		  mov	  dh, al			      ;	dx = row/col in	chars
F000:F43C		  mov	  [bp+arg_light_pen_row_col], dx
F000:F43F
F000:F43F exit_tirggered:					      ;	CODE XREF: int_10_04_handler+4Dj
F000:F43F		  mov	  ah, 1				      ;	ah = 1.	light pen triggered
F000:F441
F000:F441 exit:							      ;	CODE XREF: int_10_04_handler+Aj
F000:F441		  jmp	  near ptr pop_regs_and_iret
F000:F441 int_10_04_handler endp
F000:F441
F000:F444
F000:F444 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F444
F000:F444 ;	Sets the active	display	page.
F000:F444 ;
F000:F444 ;	   On entry:	  AH	     05h
F000:F444 ;			  AL = 0-7   Display page number
F000:F444 ;			  AL = 80h   Read CRT/CPU page registers
F000:F444 ;			  AL = 81h   Set CPU page register to value in BL
F000:F444 ;			  AL = 82h   Set CRT page register to value in BH
F000:F444 ;			  AL = 83h   Set both CPU and CRT page registers to BL and BH
F000:F444 ;	   Returns:	  If bit 7 of AL = 1 upon entry,
F000:F444 ;			     BH	= contents of CRT page register
F000:F444 ;			     BL	= contents of CPU page register
F000:F444 ; Attributes:	bp-based frame
F000:F444
F000:F444 int_10_05_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F444							      ;	DATA XREF: int_10_handler+1Co
F000:F444
F000:F444 arg_CRT_CPU_pages= word ptr  0Eh
F000:F444
F000:F444		  test	  al, 10000000b
F000:F446		  jnz	  short	get_set_registers
F000:F448		  cmp	  byte ptr ds:p400.crt_mode, 4	      ;	is a text mode active (modes 0-3)?
F000:F44D		  jl	  short	s0			      ;	yes
F000:F44F		  jmp	  near ptr pop_regs_and_iret	      ;	exit if	not
F000:F452 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F452
F000:F452 s0:							      ;	CODE XREF: int_10_05_handler+9j
F000:F452		  mov	  ds:p400.active_display_page, al     ;	save active page
F000:F455		  mov	  ax, ds:p400.crt_page_len
F000:F458		  xor	  bh, bh
F000:F45A		  mov	  bl, ds:p400.active_display_page     ;	get active page
F000:F45E		  mul	  bx				      ;	ax = ax	* bx = page len	* page number
F000:F460		  mov	  ds:p400.crt_current_page_offset, ax ;	save page offset
F000:F463		  mov	  cx, ax
F000:F465		  sar	  cx, 1				      ;	cx  /= 2 (bc. page len counts attributes) ??
F000:F467		  mov	  bh, 0Ch			      ;	reg 0ch	= start	address	hi
F000:F469		  mov	  bl, 0Dh			      ;	reg 0dh	= start	address	low
F000:F46B		  call	  set_pair_value_in_6845
F000:F46E		  mov	  bl, ds:p400.active_display_page     ;	get active page
F000:F472		  call	  get_cursor_row_col_for_page
F000:F475		  call	  update_cursor_offset
F000:F478		  jmp	  near ptr pop_regs_and_iret
F000:F47B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F47B
F000:F47B get_set_registers:					      ;	CODE XREF: int_10_05_handler+2j
F000:F47B		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video enabled?
F000:F480		  jz	  short	s1
F000:F482
F000:F482 s_error:						      ;	CODE XREF: int_10_05_handler+48j
F000:F482		  jmp	  error
F000:F485 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F485
F000:F485 s1:							      ;	CODE XREF: int_10_05_handler+3Cj
F000:F485		  mov	  bp, sp
F000:F487		  mov	  ah, al			      ;	ah = page number
F000:F489		  cmp	  ah, 84h ; '„'
F000:F48C		  jnb	  short	s_error			      ;	jump to	error if page >= 0x84
F000:F48E		  cmp	  ah, 80h ; '€'
F000:F491		  jnz	  short	set_registers
F000:F493		  jmp	  short	get_registers
F000:F495 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F495
F000:F495 set_registers:					      ;	CODE XREF: int_10_05_handler+4Dj
F000:F495		  and	  bl, 7				      ;	registers can't be > 8
F000:F498		  and	  bh, 7
F000:F49B		  mov	  cl, 3
F000:F49D		  shl	  bl, cl			      ;	align it to video_page_data CPU	page data (bit 3)
F000:F49F		  mov	  al, ds:p400.video_page_data
F000:F4A2		  cmp	  ah, 81h ; ''                       ; set CPU page register
F000:F4A5		  jnz	  short	set_crt_register
F000:F4A7
F000:F4A7 set_cpu_register:					      ;	turn off CPU page data bits (bits 3-5)
F000:F4A7		  and	  al, 11000111b
F000:F4A9		  or	  al, bl			      ;	update it
F000:F4AB		  mov	  ds:p400.video_page_data, al
F000:F4AE		  mov	  dx, 3DFh			      ;	update CRT/CPU page register
F000:F4B1		  out	  dx, al
F000:F4B2		  mov	  bx, [bp+arg_CRT_CPU_pages]	      ;	???
F000:F4B5		  and	  bl, 1000b			      ;	CPU line 17 ?
F000:F4B8		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384
F000:F4BE		  jz	  short	s2
F000:F4C0		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640
F000:F4C6		  jz	  short	s2
F000:F4C8		  xor	  bl, 1000b			      ;	toggle bit 3 if	no extended RAM	(?)
F000:F4CB
F000:F4CB s2:							      ;	CODE XREF: int_10_05_handler+7Aj
F000:F4CB							      ;	int_10_05_handler+82j
F000:F4CB		  mov	  cl, 2
F000:F4CD		  shl	  bl, cl			      ;	align it to match CPU address lines in extended	RAM
F000:F4CF		  mov	  al, ds:p400.extended_ram
F000:F4D2		  and	  al, 10011111b			      ;	filter out CPU page addresses
F000:F4D4		  or	  al, bl			      ;	update contents
F000:F4D6		  mov	  ds:p400.extended_ram,	al
F000:F4D9		  mov	  dx, 3DDh			      ;	extended RAM page register
F000:F4DC		  out	  dx, al
F000:F4DD
F000:F4DD get_registers:					      ;	CODE XREF: int_10_05_handler+4Fj
F000:F4DD		  jmp	  short	s_get_registers
F000:F4DF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F4DF		  nop
F000:F4E0
F000:F4E0 set_crt_register:					      ;	CODE XREF: int_10_05_handler+61j
F000:F4E0		  cmp	  ah, 82h ; '‚'
F000:F4E3		  jnz	  short	set_cpu_crt_registers
F000:F4E5		  and	  al, 11111000b			      ;	al = video page	data. only 3 LSB bits
F000:F4E7		  or	  al, bh			      ;	update it with CRT values
F000:F4E9		  mov	  ds:p400.video_page_data, al	      ;	set updated value to var
F000:F4EC		  mov	  dx, 3DFh			      ;	CRT/CPU	page register
F000:F4EF		  out	  dx, al
F000:F4F0		  mov	  bx, [bp+arg_CRT_CPU_pages]	      ;	???
F000:F4F3		  and	  bh, 1000b			      ;	CRT line 17 ?
F000:F4F6		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384
F000:F4FC		  jz	  short	s3
F000:F4FE		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640
F000:F504		  jz	  short	s3
F000:F506		  xor	  bh, 1000b			      ;	toggle bit if no extended RAM
F000:F509
F000:F509 s3:							      ;	CODE XREF: int_10_05_handler+B8j
F000:F509							      ;	int_10_05_handler+C0j
F000:F509		  mov	  al, ds:p400.extended_ram
F000:F50C		  and	  al, 11100111b			      ;	filter out CRT page addresses
F000:F50E		  or	  al, bl
F000:F510		  mov	  ds:p400.extended_ram,	al
F000:F513		  mov	  dx, 3DDh			      ;	Extended RAM page register
F000:F516		  out	  dx, al
F000:F517		  jmp	  short	s_get_registers
F000:F519 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F519
F000:F519 set_cpu_crt_registers:				      ;	CODE XREF: int_10_05_handler+9Fj
F000:F519		  and	  al, 11000000b			      ;	filter bits 0-5
F000:F51B		  or	  al, bl
F000:F51D		  or	  al, bh			      ;	update values
F000:F51F		  mov	  ds:p400.video_page_data, al	      ;	set updated value to var
F000:F522		  mov	  dx, 3DFh			      ;	CRT/CPU	page register
F000:F525		  out	  dx, al
F000:F526		  mov	  bx, [bp+arg_CRT_CPU_pages]	      ;	???
F000:F529		  and	  bh, 1000b			      ;	CRT line 17 only ?
F000:F52C		  and	  bl, 1000b			      ;	CPU line 17 only ?
F000:F52F		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384
F000:F535		  jz	  short	s4
F000:F537		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640
F000:F53D		  jz	  short	s4
F000:F53F		  xor	  bx, 100000001000b		      ;	toggle bits if no extended RAM ?
F000:F543
F000:F543 s4:							      ;	CODE XREF: int_10_05_handler+F1j
F000:F543							      ;	int_10_05_handler+F9j
F000:F543		  mov	  cl, 2
F000:F545		  shl	  bl, cl			      ;	align it to match registers in extended	mem var
F000:F547		  mov	  al, ds:p400.extended_ram
F000:F54A		  and	  al, 10000111b			      ;	filter out both	CRT and	RAM addresses
F000:F54C		  or	  al, bl			      ;	update
F000:F54E		  or	  al, bh			      ;	update
F000:F550		  mov	  ds:p400.extended_ram,	al
F000:F553		  mov	  dx, 3DDh			      ;	Extended RAM page register
F000:F556		  out	  dx, al
F000:F557
F000:F557 s_get_registers:					      ;	CODE XREF: int_10_05_handler:get_registersj
F000:F557							      ;	int_10_05_handler+D3j
F000:F557		  mov	  bp, sp
F000:F559		  mov	  al, ds:p400.video_page_data
F000:F55C		  and	  al, 111b			      ;	CRT registers only
F000:F55E		  mov	  bh, al			      ;	update BH with them
F000:F560		  mov	  al, ds:p400.extended_ram
F000:F563		  and	  al, 1000b			      ;	CRT address 17 only
F000:F565		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384
F000:F56B		  jz	  short	s5
F000:F56D		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640
F000:F573		  jz	  short	s5
F000:F575		  xor	  al, 1000b			      ;	toggle it if no	extended RAM
F000:F577
F000:F577 s5:							      ;	CODE XREF: int_10_05_handler+127j
F000:F577							      ;	int_10_05_handler+12Fj
F000:F577		  or	  bh, al			      ;	update BH with address 17
F000:F579		  mov	  al, ds:p400.video_page_data
F000:F57C		  mov	  cl, 3				      ;	move CPU register to bits 0-3
F000:F57E		  shr	  al, cl
F000:F580		  and	  al, 7				      ;	CPU registers only
F000:F582		  mov	  bl, al
F000:F584		  mov	  al, ds:p400.extended_ram	      ;	update var
F000:F587		  and	  al, 100000b			      ;	test CPU page address "17"
F000:F589		  mov	  cl, 2
F000:F58B		  shr	  al, cl			      ;	align it with bit 4
F000:F58D		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	384
F000:F593		  jz	  short	s6
F000:F595		  cmp	  word ptr ds:p400.IO_channel_RAM_size,	640
F000:F59B		  jz	  short	s6
F000:F59D		  xor	  al, 1000b			      ;	toggle it if no	extended RAM ?
F000:F59F
F000:F59F s6:							      ;	CODE XREF: int_10_05_handler+14Fj
F000:F59F							      ;	int_10_05_handler+157j
F000:F59F		  or	  bl, al
F000:F5A1		  mov	  [bp+arg_CRT_CPU_pages], bx	      ;	update passed var
F000:F5A4		  clc
F000:F5A5		  jmp	  near ptr pop_regs_and_iret
F000:F5A8 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F5A8
F000:F5A8 error:						      ;	CODE XREF: int_10_05_handler:s_errorj
F000:F5A8		  stc
F000:F5A9		  jmp	  near ptr pop_regs_and_iret
F000:F5A9 int_10_05_handler endp
F000:F5A9
F000:F5AC
F000:F5AC ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F5AC
F000:F5AC ;	Scrolls	a specified window upward a specified number of	lines.
F000:F5AC ;
F000:F5AC ;	   On entry:	  AH	     06h
F000:F5AC ;			  AL	     Number of lines to	scroll (if 0, clear entire window)
F000:F5AC ;			  BH	     Attribute (alpha modes) or	color (graphics	modes) to be used on blank line
F000:F5AC ;			  CH	     Row number	of upper left corner
F000:F5AC ;			  CL	     Column number of upper left corner
F000:F5AC ;			  DH	     Row number	of lower right corner
F000:F5AC ;			  DL	     Column number of lower right corner
F000:F5AC ;
F000:F5AC ;	   Returns:	  None
F000:F5AC ; Attributes:	bp-based frame
F000:F5AC
F000:F5AC int_10_06_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F5AC							      ;	DATA XREF: int_10_handler+1Eo
F000:F5AC		  push	  ax
F000:F5AD		  mov	  bp, sp			      ;	bp = sp
F000:F5AF		  mov	  word ptr [bp+0], 0		      ;	0 = scroll up
F000:F5B4		  call	  scroll_up_or_down
F000:F5B7		  pop	  bx
F000:F5B8		  jmp	  near ptr pop_regs_and_iret
F000:F5B8 int_10_06_handler endp
F000:F5B8
F000:F5BB
F000:F5BB ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F5BB
F000:F5BB ;	Scrolls	a specified window upward/downward a specified number of lines.
F000:F5BB ;
F000:F5BB ;	   On entry:	  AH	     06h
F000:F5BB ;			  AL	     Number of lines to	scroll (if 0, clear entire
F000:F5BB ;				     window)
F000:F5BB ;			  BH	     Attribute (alpha modes) or	color (graphics	modes) to be used on blank line
F000:F5BB ;			  CH	     Row number	of upper left corner
F000:F5BB ;			  CL	     Column number of upper left corner
F000:F5BB ;			  DH	     Row number	of lower right corner
F000:F5BB ;			  DL	     Column number of lower right corner
F000:F5BB ;			  [BP+0]     Direction:	0=Upwards. 1=Downwards
F000:F5BB ;
F000:F5BB ;	   Returns:	  None
F000:F5BB ; Attributes:	bp-based frame bp==sp
F000:F5BB
F000:F5BB scroll_up_or_down proc near				      ;	CODE XREF: int_10_06_handler+8p
F000:F5BB							      ;	int_10_07_handler+8p
F000:F5BB
F000:F5BB arg_scroll_direction=	word ptr  4
F000:F5BB arg_row_bottom  = byte ptr  11h
F000:F5BB arg_col_left	  = byte ptr  12h
F000:F5BB arg_row_top	  = byte ptr  13h
F000:F5BB arg_char_attrib = byte ptr  15h
F000:F5BB
F000:F5BB		  mov	  ah, dl			      ;	column right
F000:F5BD		  sub	  ah, cl			      ;	ah = column right - column left	(number	of columns)
F000:F5BF		  inc	  ah				      ;	columns	+ 1
F000:F5C1		  cmp	  ah, 0
F000:F5C4		  ja	  short	s0			      ;	columns	>= 1, then start. else exit
F000:F5C6		  jmp	  exit
F000:F5C9 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F5C9
F000:F5C9 s0:							      ;	CODE XREF: scroll_up_or_down+9j
F000:F5C9		  mov	  bl, dh			      ;	bottom row
F000:F5CB		  sub	  bl, ch			      ;	bl = bottom row	- top row (number of rows)
F000:F5CD		  cmp	  al, bl			      ;	rows to	scroll bigger than window size ?
F000:F5CF		  jle	  short	s1
F000:F5D1		  xor	  al, al			      ;	if rows	to scroll bigger than window size, then	scroll 0
F000:F5D3
F000:F5D3 s1:							      ;	CODE XREF: scroll_up_or_down+14j
F000:F5D3		  call	  is_graphics_mode
F000:F5D6		  jnb	  short	is_text_mode		      ;	jump if	carry=0
F000:F5D8		  jmp	  scroll_graphics_up_or_down
F000:F5DB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F5DB
F000:F5DB is_text_mode:						      ;	CODE XREF: scroll_up_or_down+1Bj
F000:F5DB		  cmp	  word ptr [bp+0], 0		      ;	direction: 0 up, 1 down
F000:F5DF		  jz	  short	s2
F000:F5E1		  mov	  dh, ch			      ;	up:
F000:F5E3
F000:F5E3 s2:							      ;	CODE XREF: scroll_up_or_down+24j
F000:F5E3		  mov	  bh, ds:p400.active_display_page     ;	get active page
F000:F5E7		  xor	  bl, bl			      ;	bl = 0.	use dx for row/column
F000:F5E9		  call	  get_screen_offset		      ;	ret = es:bx = screen offset for	dh/dl (row/column)
F000:F5EC		  inc	  bx
F000:F5ED		  inc	  bx
F000:F5EE		  push	  bx				      ;	bx = [bp+0] (see below): final source offset
F000:F5EF		  mov	  bp, sp			      ;	bp = sp
F000:F5F1		  xor	  ch, ch
F000:F5F3		  cmp	  [bp+arg_scroll_direction], 0
F000:F5F7		  jz	  short	s3			      ;	scroll up
F000:F5F9		  mov	  ch, [bp+arg_row_bottom]	      ;	scroll down
F000:F5FC		  sub	  ch, [bp+arg_row_top]		      ;	ch: rows to scroll
F000:F5FF
F000:F5FF s3:							      ;	CODE XREF: scroll_up_or_down+3Cj
F000:F5FF		  mov	  dx, word ptr [bp+arg_col_left]      ;	dh = row top, dl = col left
F000:F602		  add	  dh, ch			      ;	dh = bottom row?
F000:F604		  mov	  bh, ds:p400.active_display_page     ;	get active page
F000:F608		  xor	  bl, bl			      ;	bl = 0.	use dx for row/column
F000:F60A		  call	  get_screen_offset		      ;	ret = es:bx = screen offset for	dh/dl (row/column)
F000:F60D		  mov	  di, bx			      ;	di = destination offset	for scroll
F000:F60F		  mov	  dh, [bp+arg_row_bottom]
F000:F612		  sub	  dh, [bp+arg_row_top]
F000:F615		  cmp	  dh, 0
F000:F618		  jnz	  short	s4			      ;	window with more than 0	rows
F000:F61A		  jmp	  short	l1			      ;	window with 0 rows
F000:F61C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F61C
F000:F61C s4:							      ;	CODE XREF: scroll_up_or_down+5Dj
F000:F61C		  mov	  dx, word ptr [bp+arg_col_left]      ;	dh = row top, dl = col left
F000:F61F		  add	  dh, ch			      ;	dh = top row + rows to scroll
F000:F621		  cmp	  [bp+arg_scroll_direction], 0
F000:F625		  jnz	  short	s5			      ;	scroll down
F000:F627		  add	  dh, al			      ;	dh += lines to scroll
F000:F629		  jmp	  short	s6
F000:F62B ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F62B
F000:F62B s5:							      ;	CODE XREF: scroll_up_or_down+6Aj
F000:F62B		  sub	  dh, al			      ;	dh -= lines to scroll
F000:F62D
F000:F62D s6:							      ;	CODE XREF: scroll_up_or_down+6Ej
F000:F62D		  mov	  bh, ds:p400.active_display_page     ;	get active page
F000:F631		  xor	  bl, bl
F000:F633		  call	  get_screen_offset		      ;	ret = es:bx screen offset for row/col (dh/dl)
F000:F636		  mov	  si, bx			      ;	si = source offset for scroll
F000:F638		  test	  byte ptr ds:p400.extra_status, 10000b	; external video color enabled?
F000:F63D		  jz	  short	s7
F000:F63F		  call	  disable_video_in_80x25_mode
F000:F642
F000:F642 s7:							      ;	CODE XREF: scroll_up_or_down+82j
F000:F642		  xor	  cx, cx
F000:F644		  cmp	  al, 0				      ;	lines to scroll	== 0 ?
F000:F646		  jz	  short	l1
F000:F648
F000:F648 l0:							      ;	CODE XREF: scroll_up_or_down+A5j
F000:F648		  push	  si				      ;	do the scroll
F000:F649		  push	  di
F000:F64A		  push	  ds
F000:F64B		  push	  ax
F000:F64C		  mov	  ax, es
F000:F64E		  mov	  ds, ax			      ;	ds = es	(screen	segment)
F000:F650		  pop	  ax
F000:F651		  mov	  cl, ah
F000:F653		  rep movsw
F000:F655		  pop	  ds
F000:F656		  cmp	  si, [bp+0]			      ;	final destination (see above)
F000:F659		  jz	  short	s8
F000:F65B		  pop	  di
F000:F65C		  pop	  si
F000:F65D		  call	  add_or_sub_bytes_per_row	      ;	di/si +/- = bytes per row
F000:F660		  jmp	  short	l0
F000:F662 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F662
F000:F662 s8:							      ;	CODE XREF: scroll_up_or_down+9Ej
F000:F662		  pop	  di
F000:F663		  pop	  si
F000:F664		  call	  add_or_sub_bytes_per_row
F000:F667
F000:F667 l1:							      ;	CODE XREF: scroll_up_or_down+5Fj
F000:F667							      ;	scroll_up_or_down+8Bj
F000:F667							      ;	scroll_up_or_down+C3j
F000:F667		  push	  si				      ;	clean the scren	with space + attribute
F000:F668		  push	  di
F000:F669		  mov	  cl, ah
F000:F66B		  push	  ax
F000:F66C		  mov	  al, 20h ; ' '                       ; space
F000:F66E		  mov	  ah, [bp+arg_char_attrib]	      ;	attribute to fill
F000:F671		  rep stosw
F000:F673		  pop	  ax
F000:F674		  cmp	  di, [bp+0]			      ;	final destination (see above)
F000:F677		  jz	  short	s9
F000:F679		  pop	  di
F000:F67A		  pop	  si
F000:F67B		  call	  add_or_sub_bytes_per_row
F000:F67E		  jmp	  short	l1
F000:F680 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F680
F000:F680 s9:							      ;	CODE XREF: scroll_up_or_down+BCj
F000:F680		  pop	  di
F000:F681		  pop	  si
F000:F682		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video enabled ?
F000:F687		  jz	  short	s10
F000:F689		  call	  enable_video_in_80x25_mode
F000:F68C
F000:F68C s10:							      ;	CODE XREF: scroll_up_or_down+CCj
F000:F68C		  pop	  bx
F000:F68D
F000:F68D exit:							      ;	CODE XREF: scroll_up_or_down+Bj
F000:F68D		  retn
F000:F68D scroll_up_or_down endp
F000:F68D
F000:F68E
F000:F68E ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F68E
F000:F68E ; Scrolls a specified	window downward	a specified number of lines.
F000:F68E ;
F000:F68E ;	   On entry:	  AH	     07h
F000:F68E ;			  AL	     Number of lines to	scroll (if 0, clear entire
F000:F68E ;				     window)
F000:F68E ;			  BH	     Attribute (alpha modes) or	color (graphics	modes) to be used on blank line
F000:F68E ;			  CH	     Row number	of upper left corner
F000:F68E ;			  CL	     Column number of upper left corner
F000:F68E ;			  DH	     Row number	of lower right corner
F000:F68E ;			  DL	     Column number of lower right corner
F000:F68E ;
F000:F68E ;	   Returns:	  None
F000:F68E ; Attributes:	bp-based frame
F000:F68E
F000:F68E int_10_07_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F68E							      ;	DATA XREF: int_10_handler+20o
F000:F68E		  push	  ax
F000:F68F		  mov	  bp, sp
F000:F691		  mov	  word ptr [bp+0], 1		      ;	1 = scroll down
F000:F696		  call	  scroll_up_or_down
F000:F699		  pop	  bx
F000:F69A		  jmp	  near ptr pop_regs_and_iret
F000:F69A int_10_07_handler endp
F000:F69A
F000:F69D
F000:F69D ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F69D
F000:F69D ;	Read a character and its attribute or color at the current cursor position.
F000:F69D ;
F000:F69D ;	   On entry:	  AH	     08h
F000:F69D ;			  BH	     Display page number (text modes only)
F000:F69D ;
F000:F69D ;	   Returns:	  AH	     Attribute of character (text mode)
F000:F69D ;			  AL	     ASCII value of character
F000:F69D
F000:F69D int_10_08_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F69D							      ;	DATA XREF: int_10_handler+22o
F000:F69D		  call	  is_graphics_mode
F000:F6A0		  jnb	  short	text_mode
F000:F6A2		  xor	  bl, bl
F000:F6A4		  call	  get_cursor_row_col_for_page
F000:F6A7		  call	  gfx_get_ascii_value_for_row_col
F000:F6AA		  jmp	  short	exit
F000:F6AC ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F6AC
F000:F6AC text_mode:						      ;	CODE XREF: int_10_08_handler+3j
F000:F6AC		  mov	  bl, 1
F000:F6AE		  call	  get_screen_offset
F000:F6B1		  test	  byte ptr ds:p400.extra_status, 10000b
F000:F6B6		  jz	  short	skip_horiz_retrace
F000:F6B8		  call	  is_80x25_text_mode
F000:F6BB		  jnb	  short	skip_horiz_retrace
F000:F6BD		  mov	  dx, 3DAh
F000:F6C0
F000:F6C0 wait_horiz_refresh_finish:				      ;	CODE XREF: int_10_08_handler+26j
F000:F6C0		  in	  al, dx			      ;	Video status bits:
F000:F6C0							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F6C0							      ;	1: 1=light pen is triggered; 0=armed
F000:F6C0							      ;	2: 1=light pen switch is open; 0=closed
F000:F6C0							      ;	3: 1=vertical sync pulse is occurring.
F000:F6C1		  shr	  al, 1
F000:F6C3		  jb	  short	wait_horiz_refresh_finish
F000:F6C5		  cli
F000:F6C6
F000:F6C6 wait_horiz_refresh_start:				      ;	CODE XREF: int_10_08_handler+2Cj
F000:F6C6		  in	  al, dx			      ;	Video status bits:
F000:F6C6							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F6C6							      ;	1: 1=light pen is triggered; 0=armed
F000:F6C6							      ;	2: 1=light pen switch is open; 0=closed
F000:F6C6							      ;	3: 1=vertical sync pulse is occurring.
F000:F6C7		  shr	  al, 1
F000:F6C9		  jnb	  short	wait_horiz_refresh_start
F000:F6CB
F000:F6CB skip_horiz_retrace:					      ;	CODE XREF: int_10_08_handler+19j
F000:F6CB							      ;	int_10_08_handler+1Ej
F000:F6CB		  mov	  ax, es:[bx]			      ;	get ascii value	+ attribute
F000:F6CE		  sti
F000:F6CF
F000:F6CF exit:							      ;	CODE XREF: int_10_08_handler+Dj
F000:F6CF		  jmp	  near ptr pop_regs_and_iret
F000:F6CF int_10_08_handler endp
F000:F6CF
F000:F6D2
F000:F6D2 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F6D2
F000:F6D2 ;	Displays a specified character with a specified	attribute a specified
F000:F6D2 ;	number of times.
F000:F6D2 ;
F000:F6D2 ;	   On entry:	  AX	     09h
F000:F6D2 ;			  AL	     ASCII value of character
F000:F6D2 ;			  BH	     Display page (text	mode only)
F000:F6D2 ;			  BL	     Attribute of character (for alpha modes) or color of character
F000:F6D2 ;				     (for graphics modes; if bit 7 of BL is set, the color of the character is XOR'ed with the color value)
F000:F6D2 ;			  CX	     Number of times to	write character
F000:F6D2 ;
F000:F6D2 ;	   Returns:	  None
F000:F6D2
F000:F6D2 int_10_09_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F6D2							      ;	DATA XREF: int_10_handler+24o
F000:F6D2		  xor	  dl, dl			      ;	dl = 0:	write with attribute
F000:F6D4		  jmp	  short	display_chars
F000:F6D4 int_10_09_handler endp
F000:F6D4
F000:F6D6
F000:F6D6 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F6D6
F000:F6D6 ;
F000:F6D6 ;	Displays a specified character a specified number of times.
F000:F6D6 ;
F000:F6D6 ;	   On entry:	  AH	     0Ah
F000:F6D6 ;			  AL	     ASCII character to	write
F000:F6D6 ;			  BL	     color of character	(graphics mode)
F000:F6D6 ;			  BH	     display page number (valid	for alpha modes	only
F000:F6D6 ;			  CX	     number of characters to write
F000:F6D6 ;
F000:F6D6 ;	   Returns:	  None
F000:F6D6 ; Attributes:	bp-based frame
F000:F6D6
F000:F6D6 int_10_0a_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F6D6							      ;	DATA XREF: int_10_handler+26o
F000:F6D6		  mov	  dl, 0FFh
F000:F6D8
F000:F6D8 display_chars:					      ;	CODE XREF: int_10_09_handler+2j
F000:F6D8		  or	  cx, cx			      ;	nothing	to write?
F000:F6DA		  jz	  short	exit
F000:F6DC		  mov	  ah, bl
F000:F6DE		  call	  is_graphics_mode
F000:F6E1		  jnb	  short	display_chars_text_mode
F000:F6E3		  xor	  bl, bl
F000:F6E5		  call	  get_cursor_row_col_for_page
F000:F6E8		  call	  gfx_print_char
F000:F6EB		  jmp	  short	exit
F000:F6ED ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F6ED
F000:F6ED display_chars_text_mode:				      ;	CODE XREF: int_10_0a_handler+Bj
F000:F6ED		  push	  dx
F000:F6EE		  mov	  bp, sp
F000:F6F0		  mov	  bl, 1
F000:F6F2		  call	  get_screen_offset
F000:F6F5		  mov	  di, bx
F000:F6F7		  mov	  bl, al
F000:F6F9		  cmp	  byte ptr [bp+0], 0		      ;	[bp+0] = dx. 0=write with attribute. 255=write only ascii
F000:F6FD		  jnz	  short	write_ascii_only
F000:F6FF
F000:F6FF write_ascii_and_attribute:				      ;	CODE XREF: int_10_0a_handler+47j
F000:F6FF		  test	  byte ptr ds:p400.extra_status, 10000b
F000:F704		  jz	  short	skip_horizontal_retrace
F000:F706		  call	  is_80x25_text_mode
F000:F709		  jnb	  short	skip_horizontal_retrace
F000:F70B		  mov	  dx, 3DAh
F000:F70E
F000:F70E wait_horizontal_refresh_finish:			      ;	CODE XREF: int_10_0a_handler+3Bj
F000:F70E		  in	  al, dx			      ;	Video status bits:
F000:F70E							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F70E							      ;	1: 1=light pen is triggered; 0=armed
F000:F70E							      ;	2: 1=light pen switch is open; 0=closed
F000:F70E							      ;	3: 1=vertical sync pulse is occurring.
F000:F70F		  shr	  al, 1
F000:F711		  jb	  short	wait_horizontal_refresh_finish
F000:F713		  cli
F000:F714
F000:F714 wait_horizontal_refresh_start:			      ;	CODE XREF: int_10_0a_handler+41j
F000:F714		  in	  al, dx			      ;	Video status bits:
F000:F714							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F714							      ;	1: 1=light pen is triggered; 0=armed
F000:F714							      ;	2: 1=light pen switch is open; 0=closed
F000:F714							      ;	3: 1=vertical sync pulse is occurring.
F000:F715		  shr	  al, 1
F000:F717		  jnb	  short	wait_horizontal_refresh_start
F000:F719
F000:F719 skip_horizontal_retrace:				      ;	CODE XREF: int_10_0a_handler+2Ej
F000:F719							      ;	int_10_0a_handler+33j
F000:F719		  mov	  al, bl
F000:F71B		  stosw
F000:F71C		  sti
F000:F71D		  loop	  write_ascii_and_attribute
F000:F71F		  jmp	  short	pop_and_exit
F000:F721 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F721
F000:F721 write_ascii_only:					      ;	CODE XREF: int_10_0a_handler+27j
F000:F721							      ;	int_10_0a_handler+6Aj
F000:F721		  test	  byte ptr ds:p400.extra_status, 10h
F000:F726		  jz	  short	skip_horizontal_retrace_bis
F000:F728		  call	  is_80x25_text_mode
F000:F72B		  jnb	  short	skip_horizontal_retrace_bis
F000:F72D		  mov	  dx, 3DAh
F000:F730
F000:F730 wait_horizontal_refresh_finish_bis:			      ;	CODE XREF: int_10_0a_handler+5Dj
F000:F730		  in	  al, dx			      ;	Video status bits:
F000:F730							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F730							      ;	1: 1=light pen is triggered; 0=armed
F000:F730							      ;	2: 1=light pen switch is open; 0=closed
F000:F730							      ;	3: 1=vertical sync pulse is occurring.
F000:F731		  shr	  al, 1
F000:F733		  jb	  short	wait_horizontal_refresh_finish_bis
F000:F735		  cli
F000:F736
F000:F736 wait_horizontal_refresh_start_bis:			      ;	CODE XREF: int_10_0a_handler+63j
F000:F736		  in	  al, dx			      ;	Video status bits:
F000:F736							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F736							      ;	1: 1=light pen is triggered; 0=armed
F000:F736							      ;	2: 1=light pen switch is open; 0=closed
F000:F736							      ;	3: 1=vertical sync pulse is occurring.
F000:F737		  shr	  al, 1
F000:F739		  jnb	  short	wait_horizontal_refresh_start_bis
F000:F73B
F000:F73B skip_horizontal_retrace_bis:				      ;	CODE XREF: int_10_0a_handler+50j
F000:F73B							      ;	int_10_0a_handler+55j
F000:F73B		  mov	  al, bl			      ;	al = ASCII to write to screen
F000:F73D		  stosb					      ;	write char to screen
F000:F73E		  sti					      ;	enable interrupts
F000:F73F		  inc	  di
F000:F740		  loop	  write_ascii_only
F000:F742
F000:F742 pop_and_exit:						      ;	CODE XREF: int_10_0a_handler+49j
F000:F742		  pop	  bx
F000:F743
F000:F743 exit:							      ;	CODE XREF: int_10_0a_handler+4j
F000:F743							      ;	int_10_0a_handler+15j
F000:F743		  jmp	  near ptr pop_regs_and_iret
F000:F743 int_10_0a_handler endp
F000:F743
F000:F746
F000:F746 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F746
F000:F746 ; Select the color palette.
F000:F746 ;
F000:F746 ; Entry Conditions:	    AH = 11
F000:F746 ;			    BH = 0 Set background color	(0-15) to color	value in BL.
F000:F746 ;			    BL = color value (0	= black	/ 1 = blue / 2 = green / 3 = cyan / 4 =	red / 5	= magenta / 6 =	yellow / 7 = gray /
F000:F746 ;				 8 = dark gray / 9 = light blue	/ 10 = light green / 11	= light	cyan / 12 = light red /	13 = light magenta /
F000:F746 ;				 14 = light yellow /15 = white)
F000:F746 ;				 or
F000:F746 ;			    BH = 1 Set default palette to the number (0	or 1) in BL.
F000:F746 ;
F000:F746 ; In black and white modes:
F000:F746 ;			    BL = 0: 1 for white
F000:F746 ;			    BL = 1: 1 for black
F000:F746 ; In 4 color graphics	modes:
F000:F746 ;			    BL = 0 (1 =	green/2	= red/3	= yellow)
F000:F746 ;			    BL = 1 (1 =	cyan / 2 = magenta / 3 = white)
F000:F746 ; In 16 color	graphics modes:
F000:F746 ;			    (1 = blue /	2 = green / 3 =	cyan / 4 = red / 5 = magenta / 6 = yellow / 7 =	light gray / 8 = dark gray / 9 = light blue /
F000:F746 ;			     10	= light	green /	11 = light cyan	/ 12 = light red / 13 =	light magenta /	14 = yellow / 15 = white)
F000:F746 ; Note: For alpha modes palette entry	0 indicates the	border color. For graphics mode	palette	entry 0	indicates the border and the background	color.
F000:F746
F000:F746 int_10_0b_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F746							      ;	DATA XREF: int_10_handler+28o
F000:F746		  mov	  dx, 3D9h
F000:F749		  mov	  al, ds:p400.shadow_3d9_crt_palette
F000:F74C		  cmp	  bh, 0				      ;	bh==0: bl=background/border color
F000:F74F		  jnz	  short	set_default_palette
F000:F751		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	hercules text video mode?
F000:F756		  jz	  short	s0
F000:F758		  test	  byte ptr ds:p400.extra_status, 10000b	; external video ? treat it as mode 7
F000:F75D		  jz	  short	s1
F000:F75F
F000:F75F s0:							      ;	CODE XREF: int_10_0b_handler+10j
F000:F75F		  jmp	  short	s4
F000:F761 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F761
F000:F761 s1:							      ;	CODE XREF: int_10_0b_handler+17j
F000:F761		  cmp	  byte ptr ds:p400.crt_mode, 8	      ;	160x200x16 mode?
F000:F766		  jb	  short	s2
F000:F768		  mov	  bh, bl			      ;	bh = color to set
F000:F76A		  mov	  bl, 0				      ;	palette	idx = 0
F000:F76C		  call	  set_palette_color
F000:F76F		  mov	  bl, bh
F000:F771
F000:F771 s2:							      ;	CODE XREF: int_10_0b_handler+20j
F000:F771		  cmp	  byte ptr ds:p400.crt_mode, 6	      ;	640x200x2 mode?
F000:F776		  jz	  short	s3
F000:F778		  mov	  dx, 3DAh
F000:F77B		  mov	  al, 2				      ;	set border color same as background for	modes 0-5
F000:F77D		  out	  dx, al			      ;	out 3da,2 (select border color)
F000:F77E		  mov	  al, bl
F000:F780		  add	  dx, 4
F000:F783		  out	  dx, al			      ;	out 3de, bl (set border	color)
F000:F784		  xor	  al, al
F000:F786		  sub	  dx, 4
F000:F789		  out	  dx, al			      ;	out 3da, 0
F000:F78A
F000:F78A s3:							      ;	CODE XREF: int_10_0b_handler+30j
F000:F78A		  mov	  dx, 3D9h
F000:F78D		  mov	  al, ds:p400.shadow_3d9_crt_palette
F000:F790
F000:F790 s4:							      ;	CODE XREF: int_10_0b_handler:s0j
F000:F790		  and	  al, 11100000b			      ;	filter everything except palette select
F000:F792		  and	  bl, 11111b
F000:F795		  or	  al, bl			      ;	update color
F000:F797		  jmp	  short	s5
F000:F799 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F799
F000:F799 set_default_palette:					      ;	CODE XREF: int_10_0b_handler+9j
F000:F799		  and	  al, 11011111b			      ;	filter color select
F000:F79B		  cmp	  bl, 0				      ;	palette	0 or 1 ?
F000:F79E		  jz	  short	s5
F000:F7A0		  or	  al, 100000b			      ;	using palette 1
F000:F7A2
F000:F7A2 s5:							      ;	CODE XREF: int_10_0b_handler+51j
F000:F7A2							      ;	int_10_0b_handler+58j
F000:F7A2		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:F7A7		  jnz	  short	s6
F000:F7A9		  mov	  al, 0				      ;	mode 0xa: crt color select = everything	off
F000:F7AB
F000:F7AB s6:							      ;	CODE XREF: int_10_0b_handler+61j
F000:F7AB		  out	  dx, al			      ;	out 3d9, value
F000:F7AC		  mov	  ds:p400.shadow_3d9_crt_palette, al  ;	update shadow variable
F000:F7AF		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:F7B4		  jnz	  short	s9
F000:F7B6		  cmp	  bl, 0				      ;	palette	0 or 1 ?
F000:F7B9		  jz	  short	set_cga_palette_0
F000:F7BB
F000:F7BB set_cga_palette_1:					      ;	color 3	(cyan) for idx 1
F000:F7BB		  mov	  bx, 301h
F000:F7BE		  call	  set_palette_color
F000:F7C1		  mov	  bx, 502h			      ;	color 5	(magenta) for idx 2
F000:F7C4		  call	  set_palette_color
F000:F7C7		  mov	  bx, 0F03h			      ;	color 15 (white) for idx 3
F000:F7CA		  call	  set_palette_color
F000:F7CD		  jmp	  short	s8
F000:F7CF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F7CF
F000:F7CF set_cga_palette_0:					      ;	CODE XREF: int_10_0b_handler+73j
F000:F7CF		  mov	  bx, 201h			      ;	color 2	(green)	for idx	1
F000:F7D2		  call	  set_palette_color
F000:F7D5		  mov	  bx, 402h			      ;	color 4	(red) for idx 2
F000:F7D8		  call	  set_palette_color
F000:F7DB		  mov	  bx, 603h			      ;	color 6	(brown)	for idx	3
F000:F7DE		  call	  set_palette_color
F000:F7E1
F000:F7E1 s8:							      ;	CODE XREF: int_10_0b_handler+87j
F000:F7E1		  mov	  dx, 3DAh
F000:F7E4		  xor	  al, al
F000:F7E6		  out	  dx, al			      ;	out 3da, 0
F000:F7E7
F000:F7E7 s9:							      ;	CODE XREF: int_10_0b_handler+6Ej
F000:F7E7		  jmp	  near ptr pop_regs_and_iret
F000:F7E7 int_10_0b_handler endp
F000:F7E7
F000:F7EA
F000:F7EA ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F7EA
F000:F7EA ;	Writes a pixel dot of a	specified color	at a specified screen
F000:F7EA ;	coordinate.
F000:F7EA ;
F000:F7EA ;	   On entry:	  AH	     0Ch
F000:F7EA ;			  AL	     Pixel color (When bit 7 of	AL is set, the resultant color
F000:F7EA ;				     value of the dot is the exclusive OR of the current dot color
F000:F7EA ;				     value and the value in AL.)
F000:F7EA ;			  CX	     Horizontal	position of pixel
F000:F7EA ;			  DX	     Vertical position of pixel
F000:F7EA ;
F000:F7EA ;	   Returns:	  None
F000:F7EA
F000:F7EA int_10_0c_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F7EA							      ;	DATA XREF: int_10_handler+2Ao
F000:F7EA		  call	  get_pixel_addr_and_mask
F000:F7ED		  jb	  short	error
F000:F7EF		  cmp	  byte ptr ds:p400.crt_mode, 8	      ;	160x200	16 colors
F000:F7F4		  jz	  short	mode_8_9
F000:F7F6		  cmp	  byte ptr ds:p400.crt_mode, 9	      ;	320x200	16 colors
F000:F7FB		  jz	  short	mode_8_9
F000:F7FD		  cmp	  byte ptr ds:p400.crt_mode, 0Ah      ;	640x200	4 colors
F000:F802		  jz	  short	mode_a
F000:F804
F000:F804 s0:							      ;	CODE XREF: int_10_0c_handler+39j
F000:F804		  mov	  ah, al			      ;	al = number of bits to mask
F000:F806		  and	  al, dl
F000:F808		  shl	  al, cl			      ;	cl bit number
F000:F80A		  test	  ah, 10000000b			      ;	perform	Xor ?
F000:F80D		  jnz	  short	do_xor
F000:F80F		  rol	  dh, cl			      ;	update pixel
F000:F811		  and	  es:[bx], dh
F000:F814		  or	  es:[bx], al
F000:F817		  jmp	  near ptr pop_regs_and_iret
F000:F81A ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F81A
F000:F81A do_xor:						      ;	CODE XREF: int_10_0c_handler+23j
F000:F81A		  xor	  es:[bx], al
F000:F81D
F000:F81D error:						      ;	CODE XREF: int_10_0c_handler+3j
F000:F81D		  jmp	  near ptr pop_regs_and_iret
F000:F820 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F820
F000:F820 mode_8_9:						      ;	CODE XREF: int_10_0c_handler+Aj
F000:F820							      ;	int_10_0c_handler+11j
F000:F820		  mov	  dx, 1111000000001111b		      ;	mask for modes 8 and 9
F000:F823		  jmp	  short	s0
F000:F825 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F825
F000:F825 mode_a:						      ;	CODE XREF: int_10_0c_handler+18j
F000:F825		  mov	  dx, 1111111000000001b		      ;	mask for mode a
F000:F828		  mov	  ah, al
F000:F82A		  and	  al, dl
F000:F82C		  shl	  al, cl
F000:F82E		  test	  ah, 10000000b			      ;	do xor ?
F000:F831		  jnz	  short	do_xor_mode_a
F000:F833		  rol	  dh, cl
F000:F835		  and	  es:[bx], dh
F000:F838		  or	  es:[bx], al
F000:F83B		  jmp	  short	s1
F000:F83D ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F83D
F000:F83D do_xor_mode_a:					      ;	CODE XREF: int_10_0c_handler+47j
F000:F83D		  xor	  es:[bx], al
F000:F840
F000:F840 s1:							      ;	CODE XREF: int_10_0c_handler+51j
F000:F840		  mov	  al, ah			      ;	do smth	similar	for the	following pixel. mmm...	why?
F000:F842		  shr	  al, 1
F000:F844		  and	  al, dl
F000:F846		  shl	  al, cl
F000:F848		  test	  ah, 10000000b			      ;	do xor ?
F000:F84B		  jnz	  short	do_xor_mode_a_bis
F000:F84D		  and	  es:[bx+1], dh
F000:F851		  or	  es:[bx+1], al
F000:F855		  jmp	  near ptr pop_regs_and_iret
F000:F858 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F858
F000:F858 do_xor_mode_a_bis:					      ;	CODE XREF: int_10_0c_handler+61j
F000:F858		  xor	  es:[bx+1], al
F000:F85C		  jmp	  near ptr pop_regs_and_iret
F000:F85C int_10_0c_handler endp
F000:F85C
F000:F85F
F000:F85F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F85F
F000:F85F ;	Reports	the color of the pixel at a specified screen coordinate.
F000:F85F ;
F000:F85F ;	   On entry:	  AH	     0Dh
F000:F85F ;			  CX	     Horizontal	position of pixel
F000:F85F ;			  DX	     Vertical position of pixel
F000:F85F ;
F000:F85F ;	   Returns:	  AL	     Color of pixel
F000:F85F
F000:F85F int_10_0d_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F85F							      ;	DATA XREF: int_10_handler+2Co
F000:F85F		  call	  get_pixel_addr_and_mask
F000:F862		  jb	  short	exit
F000:F864		  cmp	  byte ptr ds:p400.crt_mode, 8
F000:F869		  jz	  short	mode_8_9
F000:F86B		  cmp	  byte ptr ds:p400.crt_mode, 9
F000:F870		  jz	  short	mode_8_9
F000:F872		  cmp	  byte ptr ds:p400.crt_mode, 0Ah
F000:F877		  jz	  short	mode_a
F000:F879
F000:F879 get_and_exit:						      ;	CODE XREF: int_10_0d_handler+26j
F000:F879		  mov	  al, es:[bx]			      ;	get pixel value. returns multi-value
F000:F87C		  shr	  al, cl			      ;	shift right until value	is in LSB
F000:F87E		  and	  al, ah			      ;	mask rest of the byte, and return it
F000:F880
F000:F880 exit:							      ;	CODE XREF: int_10_0d_handler+3j
F000:F880		  jmp	  near ptr pop_regs_and_iret
F000:F883 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F883
F000:F883 mode_8_9:						      ;	CODE XREF: int_10_0d_handler+Aj
F000:F883							      ;	int_10_0d_handler+11j
F000:F883		  mov	  ah, 0Fh			      ;	mask: get 4 LSB	bits
F000:F885		  jmp	  short	get_and_exit
F000:F887 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F887
F000:F887 mode_a:						      ;	CODE XREF: int_10_0d_handler+18j
F000:F887		  mov	  ah, 1
F000:F889		  mov	  al, es:[bx]
F000:F88C		  shr	  al, cl
F000:F88E		  and	  al, ah
F000:F890		  mov	  dl, es:[bx+1]
F000:F894		  shr	  dl, cl
F000:F896		  and	  dl, ah
F000:F898		  shl	  dl, 1
F000:F89A		  or	  al, dl
F000:F89C		  jmp	  near ptr pop_regs_and_iret
F000:F89C int_10_0d_handler endp
F000:F89C
F000:F89F
F000:F89F ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F89F
F000:F89F ;	Writes one character at	the current cursor location and	advances the
F000:F89F ;	cursor.
F000:F89F ;
F000:F89F ;	   On entry:	  AH	     0Eh
F000:F89F ;			  AL	     Character to write
F000:F89F ;			  BL	     Foreground	color (graphics	modes only)
F000:F89F ;	   Returns:	  None
F000:F89F
F000:F89F int_10_0e_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F89F							      ;	DATA XREF: int_10_handler+2Eo
F000:F89F
F000:F89F ; FUNCTION CHUNK AT F000:F94A	SIZE 00000003 BYTES
F000:F89F
F000:F89F		  push	  ax
F000:F8A0		  mov	  cl, bl
F000:F8A2		  call	  get_active_display_page
F000:F8A5		  call	  get_cursor_row_col_for_page
F000:F8A8		  cmp	  al, 7				      ;	7 = ascii bell
F000:F8AA		  jnz	  short	no_bell
F000:F8AC		  call	  play_bell_sound
F000:F8AF		  jmp	  exit
F000:F8B2 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F8B2
F000:F8B2 no_bell:						      ;	CODE XREF: int_10_0e_handler+Bj
F000:F8B2		  cmp	  al, 0Dh			      ;	0xd = carriage return
F000:F8B4		  jnz	  short	no_cr
F000:F8B6		  xor	  dl, dl			      ;	col = 0
F000:F8B8		  jmp	  short	update_cursor_position
F000:F8BA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F8BA
F000:F8BA no_cr:						      ;	CODE XREF: int_10_0e_handler+15j
F000:F8BA		  cmp	  al, 8				      ;	8 = backspace
F000:F8BC		  jnz	  short	no_backspace
F000:F8BE		  dec	  dl				      ;	backspace: col--
F000:F8C0		  jge	  short	s0
F000:F8C2		  cmp	  dh, 0				      ;	row == 0?
F000:F8C5		  jg	  short	s1
F000:F8C7		  xor	  dl, dl			      ;	col = 0
F000:F8C9
F000:F8C9 s0:							      ;	CODE XREF: int_10_0e_handler+21j
F000:F8C9		  jmp	  short	update_cursor_position
F000:F8CB ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F8CB
F000:F8CB s1:							      ;	CODE XREF: int_10_0e_handler+26j
F000:F8CB		  dec	  dh				      ;	row--
F000:F8CD		  add	  dl, ds:p400.crt_nr_cols	      ;	cols +=	nr of cols
F000:F8D1		  jmp	  short	update_cursor_position
F000:F8D3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F8D3
F000:F8D3 no_backspace:						      ;	CODE XREF: int_10_0e_handler+1Dj
F000:F8D3		  cmp	  al, 0Ah			      ;	line feed
F000:F8D5		  jnz	  short	no_linefeed
F000:F8D7		  cmp	  dh, 24			      ;	last row?
F000:F8DA		  jnz	  short	not_last_row
F000:F8DC
F000:F8DC l0:							      ;	CODE XREF: int_10_0e_handler+8Bj
F000:F8DC		  call	  is_graphics_mode
F000:F8DF		  jnb	  short	not_graphics
F000:F8E1		  mov	  ah, 0				      ;	color 0	for empty lines
F000:F8E3		  jmp	  short	do_scroll_up
F000:F8E5 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F8E5
F000:F8E5 not_graphics:						      ;	CODE XREF: int_10_0e_handler+40j
F000:F8E5		  mov	  bp, sp
F000:F8E7		  call	  get_active_display_page
F000:F8EA		  mov	  ah, 8
F000:F8EC		  int	  10h				      ;	- VIDEO	- READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
F000:F8EC							      ;	BH = display page
F000:F8EC							      ;	Return:	AL = character
F000:F8EC							      ;	AH = attribute of character (alpha modes)
F000:F8EE
F000:F8EE do_scroll_up:						      ;	CODE XREF: int_10_0e_handler+44j
F000:F8EE		  mov	  bh, ah
F000:F8F0		  mov	  ah, 6
F000:F8F2		  mov	  al, 1
F000:F8F4		  xor	  cx, cx
F000:F8F6		  mov	  dl, ds:p400.crt_nr_cols	      ;	columns	on screen
F000:F8FA		  dec	  dl
F000:F8FC		  int	  10h				      ;	- VIDEO	- SCROLL PAGE UP
F000:F8FC							      ;	AL = number of lines to	scroll window (0 = blank whole window)
F000:F8FC							      ;	BH = attributes	to be used on blanked lines
F000:F8FC							      ;	CH,CL =	row,column of upper left corner	of window to scroll
F000:F8FC							      ;	DH,DL =	row,column of lower right corner of window
F000:F8FE		  jmp	  short	exit
F000:F900 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F900
F000:F900 not_last_row:						      ;	CODE XREF: int_10_0e_handler+3Bj
F000:F900		  inc	  dh
F000:F902		  jmp	  short	update_cursor_position
F000:F904 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F904
F000:F904 no_linefeed:						      ;	CODE XREF: int_10_0e_handler+36j
F000:F904		  mov	  ah, 0Ah
F000:F906		  mov	  bl, cl
F000:F908		  mov	  cx, 1
F000:F90B		  int	  10h				      ;	- VIDEO	- WRITE	CHARACTERS ONLY	AT CURSOR POSITION
F000:F90B							      ;	AL = character,	BH = display page - alpha mode
F000:F90B							      ;	BL = color of character	(graphics mode,	PCjr only)
F000:F90B							      ;	CX = number of times to	write character
F000:F90D		  inc	  dl
F000:F90F		  cmp	  dl, ds:p400.crt_nr_cols	      ;	columns	on screen
F000:F913		  jnz	  short	update_cursor_position
F000:F915		  xor	  dl, dl			      ;	col = 0
F000:F917		  cmp	  dh, 24			      ;	row = 24 ? (last row)
F000:F91A		  jnz	  short	s2
F000:F91C		  mov	  bp, sp
F000:F91E		  push	  ax
F000:F91F		  push	  cx
F000:F920		  push	  dx
F000:F921		  call	  get_active_display_page
F000:F924		  call	  set_cursor_pos
F000:F927		  pop	  dx
F000:F928		  pop	  cx
F000:F929		  pop	  ax
F000:F92A		  jmp	  short	l0
F000:F92C ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F92C
F000:F92C s2:							      ;	CODE XREF: int_10_0e_handler+7Bj
F000:F92C		  inc	  dh				      ;	row++
F000:F92E
F000:F92E update_cursor_position:				      ;	CODE XREF: int_10_0e_handler+19j
F000:F92E							      ;	int_10_0e_handler:s0j
F000:F92E							      ;	int_10_0e_handler+32j
F000:F92E							      ;	int_10_0e_handler+63j ...
F000:F92E		  mov	  bp, sp
F000:F930		  call	  get_active_display_page
F000:F933		  call	  set_cursor_pos
F000:F936
F000:F936 exit:							      ;	CODE XREF: int_10_0e_handler+10j
F000:F936							      ;	int_10_0e_handler+5Fj
F000:F936		  pop	  ax
F000:F937		  jmp	  short	int_10_0e_exit
F000:F937 int_10_0e_handler endp
F000:F937
F000:F939
F000:F939 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F939
F000:F939 ;	Reports	the current video mode,	the number of character	positions per
F000:F939 ;	line in	that video mode, and the current display page.
F000:F939 ;
F000:F939 ;	   On entry:	  AH	     0Fh
F000:F939 ;
F000:F939 ;	   Returns:	  AL	     Video mode
F000:F939 ;			  AH	     Number of character columns per line
F000:F939 ;			  BH	     Active display page number
F000:F939 ;
F000:F939 ; Attributes:	bp-based frame
F000:F939
F000:F939 int_10_0f_handler proc near				      ;	CODE XREF: int_10_handler+Dj
F000:F939							      ;	DATA XREF: int_10_handler+30o
F000:F939
F000:F939 arg_bx	  = word ptr  0Eh
F000:F939
F000:F939		  mov	  ax, ds:p400.crt_nr_cols	      ;	columns	on screen
F000:F93C		  mov	  ah, al			      ;	ah=number of character columns
F000:F93E		  mov	  al, ds:p400.crt_mode		      ;	al=video mode
F000:F941		  mov	  bh, ds:p400.active_display_page     ;	bh=active page
F000:F945		  mov	  bp, sp
F000:F947		  mov	  [bp+arg_bx], bx
F000:F947 int_10_0f_handler endp
F000:F947
F000:F94A ; START OF FUNCTION CHUNK FOR	int_10_0e_handler
F000:F94A
F000:F94A int_10_0e_exit:					      ;	CODE XREF: int_10_0e_handler+98j
F000:F94A		  jmp	  near ptr pop_regs_and_iret
F000:F94A ; END	OF FUNCTION CHUNK FOR int_10_0e_handler
F000:F94D
F000:F94D ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:F94D
F000:F94D ;	Sets the palette and border registers
F000:F94D ;
F000:F94D ;	   On entry:	  AH	     10h
F000:F94D ;			  AL	     Subservice
F000:F94D ;				     0 - Set palette register
F000:F94D ;					 BL	 Palette register (0-15)
F000:F94D ;					 BH	 Color value to	set
F000:F94D ;
F000:F94D ;				     1 - Set border color register
F000:F94D ;					 BH	 Color value to	set
F000:F94D ;
F000:F94D ;				     2 - Set palette registers and border register
F000:F94D ;					 ES:DX	 Pointer to 17-byte list
F000:F94D ;					 bytes 0-15 = values for palette registers 0-15
F000:F94D ;					 byte 16 = value for the border	register
F000:F94D
F000:F94D int_10_10_handler proc far				      ;	CODE XREF: int_10_handler+Dj
F000:F94D							      ;	DATA XREF: int_10_handler+32o
F000:F94D		  cmp	  byte ptr ds:p400.crt_mode, 7
F000:F952		  jz	  short	s0			      ;	palette	not supported in 80x25 mono
F000:F954		  test	  byte ptr ds:p400.extra_status, 10000b	; external color video enabled ?
F000:F959		  jnz	  short	s0			      ;	palette	not supported with external color video
F000:F95B		  cmp	  al, 3				      ;	al - 3
F000:F95D		  jb	  short	s1			      ;	error if subservice al >= 3
F000:F95F
F000:F95F s0:							      ;	CODE XREF: int_10_10_handler+5j
F000:F95F							      ;	int_10_10_handler+Cj
F000:F95F		  jmp	  error
F000:F962 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F962
F000:F962 s1:							      ;	CODE XREF: int_10_10_handler+10j
F000:F962		  cmp	  al, 0
F000:F964		  jnz	  short	subsrv_set_border_color
F000:F966		  cmp	  byte ptr ds:p400.crt_mode, 6
F000:F96B		  jnz	  short	s2
F000:F96D		  cmp	  bl, 1				      ;	if palette idx is 1, replace with 0xf. I guess because in 640x200 there	are only two colors?
F000:F970		  jnz	  short	set_palette
F000:F972		  mov	  bl, 0Fh
F000:F974		  jmp	  short	set_palette
F000:F976 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F976
F000:F976 s2:							      ;	CODE XREF: int_10_10_handler+1Ej
F000:F976		  jnb	  short	set_palette		      ;	modes 7-0xa don't need special requirements
F000:F978		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:F97D		  jb	  short	set_palette		      ;	modes 0-3 don't need special requirements
F000:F97F		  mov	  al, ds:p400.shadow_3d9_crt_palette  ;	modes 4-5 DO need special requirements
F000:F982		  and	  al, 100000b			      ;	only color select
F000:F984		  jz	  short	s5
F000:F986		  cmp	  bl, 1				      ;	palette	idx == 1 ?
F000:F989		  jnz	  short	s3
F000:F98B		  mov	  bl, 0Bh			      ;	idx 1 replaced with 0xb
F000:F98D		  jmp	  short	set_palette
F000:F98F ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F98F
F000:F98F s3:							      ;	CODE XREF: int_10_10_handler+3Cj
F000:F98F		  cmp	  bl, 2				      ;	palette	idx == 2 ?
F000:F992		  jnz	  short	s4
F000:F994		  mov	  bl, 0Dh			      ;	idx 2 replaced with 0xd
F000:F996		  jmp	  short	set_palette
F000:F998 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F998
F000:F998 s4:							      ;	CODE XREF: int_10_10_handler+45j
F000:F998		  cmp	  bl, 3				      ;	palette	idx == 3?
F000:F99B		  jnz	  short	set_palette
F000:F99D		  mov	  bl, 0Fh			      ;	idx 3 replaced with idx	0xf
F000:F99F		  jmp	  short	set_palette
F000:F9A1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F9A1
F000:F9A1 s5:							      ;	CODE XREF: int_10_10_handler+37j
F000:F9A1		  cmp	  bl, 1				      ;	palette	idx == 1 ?
F000:F9A4		  jnz	  short	s6
F000:F9A6		  mov	  bl, 0Ah			      ;	idx 1 replaced with idx	0xa
F000:F9A8		  jmp	  short	set_palette
F000:F9AA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F9AA
F000:F9AA s6:							      ;	CODE XREF: int_10_10_handler+57j
F000:F9AA		  cmp	  bl, 2
F000:F9AD		  jnz	  short	s7
F000:F9AF		  mov	  bl, 0Ch			      ;	idx 2 replaced with idx	0xc
F000:F9B1		  jmp	  short	set_palette
F000:F9B3 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F9B3
F000:F9B3 s7:							      ;	CODE XREF: int_10_10_handler+60j
F000:F9B3		  cmp	  bl, 3				      ;	palette	idx == 3 ?
F000:F9B6		  jnz	  short	set_palette
F000:F9B8		  mov	  bl, 0Eh			      ;	idx 3 replaced with idx	0xe
F000:F9BA
F000:F9BA set_palette:						      ;	CODE XREF: int_10_10_handler+23j
F000:F9BA							      ;	int_10_10_handler+27j
F000:F9BA							      ;	int_10_10_handler:s2j
F000:F9BA							      ;	int_10_10_handler+30j ...
F000:F9BA		  call	  set_palette_color
F000:F9BD		  jb	  short	error
F000:F9BF		  jmp	  short	pre_exit
F000:F9C1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F9C1
F000:F9C1 subsrv_set_border_color:				      ;	CODE XREF: int_10_10_handler+17j
F000:F9C1		  push	  ax
F000:F9C2		  cmp	  byte ptr ds:p400.crt_mode, 7
F000:F9C7		  jnb	  short	s9
F000:F9C9		  push	  dx
F000:F9CA		  mov	  dx, 3DAh
F000:F9CD		  mov	  al, 3
F000:F9CF		  out	  dx, al			      ;	out 3da, 3 (Select mode	control)
F000:F9D0		  add	  dx, 4
F000:F9D3		  mov	  al, 100b
F000:F9D5		  out	  dx, al			      ;	out 3de, 4 (Enables border color)
F000:F9D6		  pop	  dx
F000:F9D7
F000:F9D7 s9:							      ;	CODE XREF: int_10_10_handler+7Aj
F000:F9D7		  pop	  ax
F000:F9D8		  cmp	  al, 1
F000:F9DA		  jnz	  short	subsrv_set_palette_and_border_color
F000:F9DC		  mov	  al, 2				      ;	set border color register
F000:F9DE		  mov	  dx, 3DAh
F000:F9E1		  out	  dx, al			      ;	out 3da, 2 (Select border color)
F000:F9E2		  mov	  al, bh			      ;	bh = border color to set
F000:F9E4		  add	  dx, 4
F000:F9E7		  out	  dx, al			      ;	out 3de, bh (border color to set)
F000:F9E8		  jmp	  short	pre_exit
F000:F9EA ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:F9EA
F000:F9EA subsrv_set_palette_and_border_color:			      ;	CODE XREF: int_10_10_handler+8Dj
F000:F9EA		  mov	  bl, 10h			      ;	first palette register (from 0x10 to 0x1f)
F000:F9EC		  mov	  si, dx			      ;	es:dx points to	list. si=dx
F000:F9EE		  mov	  dx, 3DAh
F000:F9F1		  mov	  cx, 10h			      ;	16 palette colors
F000:F9F4
F000:F9F4 l0:							      ;	CODE XREF: int_10_10_handler+CBj
F000:F9F4		  push	  dx
F000:F9F5		  mov	  dx, 3DAh
F000:F9F8
F000:F9F8 retrace_in_progress:					      ;	CODE XREF: int_10_10_handler+AEj
F000:F9F8		  in	  al, dx			      ;	Video status bits:
F000:F9F8							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F9F8							      ;	1: 1=light pen is triggered; 0=armed
F000:F9F8							      ;	2: 1=light pen switch is open; 0=closed
F000:F9F8							      ;	3: 1=vertical sync pulse is occurring.
F000:F9F9		  test	  al, 8
F000:F9FB		  jnz	  short	retrace_in_progress
F000:F9FD		  cli					      ;	no interrupts
F000:F9FE
F000:F9FE wait_start_retrace:					      ;	CODE XREF: int_10_10_handler+B4j
F000:F9FE		  in	  al, dx			      ;	Video status bits:
F000:F9FE							      ;	0: retrace.  1=display is in vert or horiz retrace.
F000:F9FE							      ;	1: 1=light pen is triggered; 0=armed
F000:F9FE							      ;	2: 1=light pen switch is open; 0=closed
F000:F9FE							      ;	3: 1=vertical sync pulse is occurring.
F000:F9FF		  test	  al, 8
F000:FA01		  jz	  short	wait_start_retrace
F000:FA03		  pop	  dx
F000:FA04		  mov	  al, bl			      ;	bl = palette idx register
F000:FA06		  out	  dx, al			      ;	out 3da, palette_idx
F000:FA07		  mov	  al, es:[si]			      ;	get palette from list
F000:FA0A		  add	  dx, 4
F000:FA0D		  out	  dx, al			      ;	out 3de, [es:si] (color)
F000:FA0E		  sti					      ;	enable interrupts
F000:FA0F		  inc	  si				      ;	points to next palette color
F000:FA10		  sub	  dx, 4
F000:FA13		  xor	  al, al
F000:FA15		  out	  dx, al			      ;	out 3da, 0
F000:FA16		  inc	  bl				      ;	bl++ (pointer to palette idx register)
F000:FA18		  loop	  l0
F000:FA1A		  mov	  al, 2				      ;	2 = border color
F000:FA1C		  out	  dx, al			      ;	out 3da, 2 (Select border color)
F000:FA1D		  add	  dx, 4
F000:FA20		  mov	  al, es:[si]			      ;	fetch boder color from the last	element	in the list
F000:FA23		  out	  dx, al			      ;	out 3de, [es:si] (Border color)
F000:FA24
F000:FA24 pre_exit:						      ;	CODE XREF: int_10_10_handler+72j
F000:FA24							      ;	int_10_10_handler+9Bj
F000:FA24		  mov	  dx, 3DAh
F000:FA27		  xor	  al, al
F000:FA29		  out	  dx, al			      ;	out 3da, 0
F000:FA2A		  clc
F000:FA2B
F000:FA2B exit:							      ;	CODE XREF: int_10_10_handler+E2j
F000:FA2B		  jmp	  near ptr pop_regs_and_iret
F000:FA2E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FA2E
F000:FA2E error:						      ;	CODE XREF: int_10_10_handler:s0j
F000:FA2E							      ;	int_10_10_handler+70j
F000:FA2E		  stc
F000:FA2F		  jmp	  short	exit
F000:FA2F int_10_10_handler endp
F000:FA2F
F000:FA31
F000:FA31 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FA31
F000:FA31
F000:FA31 get_active_display_page proc near			      ;	CODE XREF: int_10_0e_handler+3p
F000:FA31							      ;	int_10_0e_handler+48p
F000:FA31							      ;	int_10_0e_handler+82p
F000:FA31							      ;	int_10_0e_handler+91p
F000:FA31		  mov	  bl, ds:p400.active_display_page     ;	get active page
F000:FA35		  cmp	  byte ptr ds:p400.crt_mode, 4
F000:FA3A		  jl	  short	s0
F000:FA3C		  xor	  bl, bl
F000:FA3E
F000:FA3E s0:							      ;	CODE XREF: get_active_display_page+9j
F000:FA3E		  mov	  bh, bl
F000:FA40		  retn
F000:FA40 get_active_display_page endp
F000:FA40
F000:FA41
F000:FA41 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FA41
F000:FA41 ; Returns:
F000:FA41 ;	Carry set if in	graphics mode
F000:FA41 ;	      clear if in text mode
F000:FA41
F000:FA41 is_graphics_mode proc	near				      ;	CODE XREF: scroll_up_or_down:s1p
F000:FA41							      ;	int_10_08_handlerp
F000:FA41							      ;	int_10_0a_handler+8p
F000:FA41							      ;	int_10_0e_handler:l0p
F000:FA41		  cmp	  byte ptr ds:p400.crt_mode, 7	      ;	monochrome text	mode?
F000:FA46		  jz	  short	is_text_mode
F000:FA48		  cmp	  byte ptr ds:p400.crt_mode, 4	      ;	mode between 0-3 (text modes)
F000:FA4D		  jl	  short	is_text_mode
F000:FA4F
F000:FA4F is_graphics_mode_:
F000:FA4F		  stc
F000:FA50		  retn
F000:FA51 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FA51
F000:FA51 is_text_mode:						      ;	CODE XREF: is_graphics_mode+5j
F000:FA51							      ;	is_graphics_mode+Cj
F000:FA51		  clc
F000:FA52		  retn
F000:FA52 is_graphics_mode endp
F000:FA52
F000:FA52 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FA53		  db 1Bh dup(0FFh)
F000:FA6E charset_0_127	  db 8 dup(   0), 7Eh, 81h,0A5h, 81h,0BDh, 99h,	81h,2 dup( 7Eh),0FFh,0DBh,0FFh,0C3h,0E7h
F000:FA6E							      ;	DATA XREF: F000:int_44_44_tableo
F000:FA6E		  db 0FFh, 7Eh,	36h,3 dup( 7Fh), 3Eh, 1Ch,   8,	  0,   8, 1Ch, 3Eh, 7Fh, 3Eh, 1Ch,   8
F000:FA6E		  db	0, 1Ch,	3Eh, 1Ch,2 dup(	7Fh), 3Eh, 1Ch,	3Eh,2 dup(   8), 1Ch, 3Eh, 7Fh,	3Eh, 1Ch
F000:FA6E		  db  3Eh,2 dup(   0), 18h,2 dup( 3Ch),	18h,2 dup(   0),2 dup(0FFh),0E7h,2 dup(0C3h),0E7h
F000:FA6E		  db 2 dup(0FFh),   0, 3Ch, 66h,2 dup( 42h), 66h, 3Ch,	 0,0FFh,0C3h, 99h,2 dup(0BDh)
F000:FA6E		  db  99h,0C3h,0FFh, 0Fh,   7, 0Fh, 7Dh,3 dup(0CCh), 78h, 3Ch,3	dup( 66h), 3Ch,	18h, 7Eh
F000:FA6E		  db  18h, 30h,	3Ch, 33h,2 dup(	31h),2 dup( 70h),   0, 60h, 78h, 66h, 73h, 6Fh,0E3h,0E7h
F000:FA6E		  db	7, 99h,	5Ah, 3Ch,2 dup(0E7h), 3Ch, 5Ah,	99h, 40h, 70h, 7Ch, 7Fh, 7Ch, 70h, 40h
F000:FA6E		  db	0,   1,	  7, 1Fh, 7Fh, 1Fh,   7,   1,	0, 18h,	3Ch, 7Eh,2 dup(	18h), 7Eh, 3Ch
F000:FA6E		  db  18h,5 dup( 66h),	 0, 66h,   0, 7Fh,2 dup(0DBh), 7Bh,3 dup( 1Bh),	  0, 3Fh, 60h
F000:FA6E		  db  3Eh, 63h,	3Eh,   3, 7Eh,5	dup(   0),3 dup( 7Eh),	 0, 18h, 3Ch, 7Eh, 18h,	7Eh, 3Ch
F000:FA6E		  db  18h,0FFh,	18h, 3Ch, 7Eh,4	dup( 18h),   0,4 dup( 18h), 7Eh, 3Ch, 18h,2 dup(   0)
F000:FA6E		  db  0Ch,   6,	7Fh,   6, 0Ch,3	dup(   0), 18h,	30h, 7Fh, 30h, 18h,4 dup(   0),3 dup( 60h)
F000:FA6E		  db  7Fh,3 dup(   0), 24h, 66h,0FFh, 66h, 24h,3 dup(	0), 18h, 3Ch, 7Eh,2 dup(0FFh)
F000:FA6E		  db 3 dup(   0),2 dup(0FFh), 7Eh, 3Ch,	18h,0Ah	dup(   0), 18h,2 dup( 3Ch),2 dup( 18h)
F000:FA6E		  db	0, 18h,	  0,3 dup( 36h),5 dup(	 0),2 dup( 36h), 7Fh, 36h, 7Fh,2 dup( 36h),   0
F000:FA6E		  db  18h, 3Eh,	60h, 3Ch,   6, 7Ch, 18h,2 dup(	 0), 63h, 66h, 0Ch, 18h, 33h, 63h,   0
F000:FA6E		  db  1Ch, 36h,	1Ch, 3Bh, 6Eh, 66h, 3Bh,   0,2 dup( 18h), 30h,5	dup(   0), 0Ch,	18h,3 dup( 30h)
F000:FA6E		  db  18h, 0Ch,	  0, 30h, 18h,3	dup( 0Ch), 18h,	30h,2 dup(   0), 66h, 3Ch,0FFh,	3Ch, 66h
F000:FA6E		  db 3 dup(   0),2 dup(	18h), 7Eh,2 dup( 18h),7	dup(   0),2 dup( 18h), 30h,3 dup(   0)
F000:FA6E		  db  7Eh,9 dup(   0),2	dup( 18h),   0,	  3,   6, 0Ch, 18h, 30h, 60h,0C0h,   0,	3Eh, 63h
F000:FA6E		  db  67h, 6Fh,	7Bh, 73h, 3Eh,	 0, 18h, 38h,4 dup( 18h), 7Eh,	 0, 3Ch, 66h,	6, 1Ch
F000:FA6E		  db  30h, 66h,	7Eh,   0, 3Ch, 66h,   6, 1Ch,	6, 66h,	3Ch,   0, 0Eh, 1Eh, 36h, 66h, 7Fh
F000:FA6E		  db	6, 0Fh,	  0, 7Eh, 60h, 7Ch,2 dup(   6),	66h, 3Ch,   0, 1Ch, 30h, 60h, 7Ch,2 dup( 66h)
F000:FA6E		  db  3Ch,   0,	7Eh, 66h,   6, 0Ch,3 dup( 18h),	  0, 3Ch,2 dup(	66h), 3Ch,2 dup( 66h)
F000:FA6E		  db  3Ch,   0,	3Ch,2 dup( 66h), 3Eh,	6, 0Ch,	38h,2 dup(   0),2 dup( 18h),2 dup(   0)
F000:FA6E		  db 2 dup( 18h),2 dup(	  0),2 dup( 18h),2 dup(	  0),2 dup( 18h), 30h,	 6, 0Ch, 18h, 30h
F000:FA6E		  db  18h, 0Ch,	  6,3 dup(   0), 7Eh,	0, 7Eh,3 dup(	0), 30h, 18h, 0Ch,   6,	0Ch, 18h
F000:FA6E		  db  30h,   0,	3Ch, 66h,   6, 0Ch, 18h,   0, 18h,   0,	3Eh, 63h,3 dup(	6Fh), 60h, 3Ch
F000:FA6E		  db	0, 1Ch,	36h,2 dup( 63h), 7Fh,2 dup( 63h),   0, 7Eh,2 dup( 33h),	3Eh,2 dup( 33h)
F000:FA6E		  db  7Eh,   0,	1Eh, 33h,3 dup(	60h), 33h, 1Eh,	  0, 7Ch, 36h,3	dup( 33h), 36h,	7Ch,   0
F000:FA6E		  db  7Fh, 31h,	34h, 3Ch, 34h, 31h, 7Fh,   0, 7Fh, 31h,	34h, 3Ch, 34h, 30h, 78h,   0, 1Eh
F000:FA6E		  db  33h,2 dup( 60h), 67h, 33h, 1Fh,	0,3 dup( 66h), 7Eh,3 dup( 66h),	  0, 3Ch,5 dup(	18h)
F000:FA6E		  db  3Ch,   0,	0Fh,3 dup(   6),2 dup( 66h), 3Ch,   0, 73h, 33h, 36h, 3Ch, 36h,	33h, 73h
F000:FA6E		  db	0, 78h,3 dup( 30h), 31h, 33h, 7Fh,   0,	63h, 77h,2 dup(	7Fh), 6Bh,2 dup( 63h)
F000:FA6E		  db	0, 63h,	73h, 7Bh, 6Fh, 67h,2 dup( 63h),	  0, 3Eh,5 dup(	63h), 3Eh,   0,	7Eh,2 dup( 33h)
F000:FA6E		  db  3Eh,2 dup( 30h), 78h,   0, 3Eh,4 dup( 63h), 6Fh, 3Eh,   3, 7Eh,2 dup( 33h), 3Eh
F000:FA6E		  db  36h, 33h,	73h,   0, 3Ch, 66h, 70h, 38h, 0Eh, 66h,	3Ch,   0, 7Eh, 5Ah,4 dup( 18h)
F000:FA6E		  db  3Ch,   0,6 dup( 63h), 3Eh,   0,5 dup( 66h), 3Ch, 18h,   0,3 dup( 63h), 6Bh, 7Fh
F000:FA6E		  db  77h, 63h,	  0,2 dup( 63h), 36h,2 dup( 1Ch), 36h, 63h,   0,3 dup( 66h), 3Ch,2 dup(	18h)
F000:FA6E		  db  3Ch,   0,	7Fh, 63h, 46h, 0Ch, 19h, 33h, 7Fh,   0,	3Ch,5 dup( 30h), 3Ch,	0, 60h
F000:FA6E		  db  30h, 18h,	0Ch,   6,   3,	 1,   0, 3Ch,5 dup( 0Ch), 3Ch,	 0,   8, 1Ch, 36h,0Ch dup(   0)
F000:FA6E		  db 0FFh,2 dup( 18h), 0Ch,7 dup(   0),	3Ch,   6, 3Eh, 66h, 3Bh,   0, 70h, 30h,	3Eh,3 dup( 33h)
F000:FA6E		  db  6Eh,3 dup(   0), 3Ch, 66h, 60h, 66h, 3Ch,	  0, 0Eh,   6, 3Eh,3 dup( 66h),	3Bh,3 dup(   0)
F000:FA6E		  db  3Ch, 66h,	7Eh, 60h, 3Ch,	 0, 1Ch, 36h, 30h, 78h,2 dup( 30h), 78h,3 dup(	 0), 3Bh
F000:FA6E		  db 2 dup( 66h), 3Eh,	 6, 7Ch, 70h, 30h, 36h,	3Bh,2 dup( 33h), 73h,	0, 18h,	  0, 38h
F000:FA6E		  db 3 dup( 18h), 3Ch,	 0,   6,   0, 0Eh,2 dup(   6),2	dup( 66h), 3Ch,	70h, 30h, 33h
F000:FA6E		  db  36h, 3Ch,	36h, 73h,   0, 38h,5 dup( 18h),	3Ch,3 dup(   0),0E6h,2 dup( 7Fh), 6Bh
F000:FA6E		  db  63h,3 dup(   0), 6Eh,4 dup( 33h),3 dup(	0), 3Ch,3 dup( 66h), 3Ch,3 dup(	  0), 6Eh
F000:FA6E		  db 2 dup( 33h), 3Eh, 30h, 78h,2 dup(	 0), 3Bh,2 dup(	66h), 3Eh,   6,	0Fh,2 dup(   0)
F000:FA6E		  db  6Eh, 3Bh,	33h, 30h, 78h,3	dup(   0), 3Eh,	60h, 3Ch,   6, 7Ch,   0, 10h, 30h, 7Ch
F000:FA6E		  db 2 dup( 30h), 36h, 1Ch,3 dup(   0),4 dup( 66h), 3Bh,3 dup(	 0),3 dup( 66h), 3Ch, 18h
F000:FA6E		  db 3 dup(   0), 63h, 6Bh,2 dup( 7Fh),	36h,3 dup(   0), 63h, 36h, 1Ch,	36h, 63h,3 dup(	  0)
F000:FA6E		  db 3 dup( 66h), 3Eh,	 6, 7Ch,2 dup(	 0), 7Eh, 4Ch, 18h, 32h, 7Eh,	0, 0Eh,2 dup( 18h)
F000:FA6E		  db  70h,2 dup( 18h), 0Eh,   0,3 dup( 18h),   0,3 dup(	18h),	0, 70h,2 dup( 18h), 0Eh
F000:FA6E		  db 2 dup( 18h), 70h,	 0, 3Bh, 6Eh,7 dup(   0),   8, 1Ch, 36h,2 dup( 63h), 7Fh,   0
F000:FE6E ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FE6E
F000:FE6E int_1a_handler:					      ;	DATA XREF: F000:FF17o
F000:FE6E		  jmp	  near ptr int_1a_main
F000:FE71
F000:FE71 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FE71
F000:FE71 ;
F000:FE71 ;	Returns	a list of installed equipment on the system.
F000:FE71 ;
F000:FE71 ;	   On entry:	  No parameters
F000:FE71 ;
F000:FE71 ;	   Returns:	  AX	     Equipment code
F000:FE71
F000:FE71 int_11_handler  proc far				      ;	DATA XREF: F000:FF05o
F000:FE71		  push	  bx
F000:FE72		  push	  ds
F000:FE73		  mov	  ax, 40h ; '@'
F000:FE76		  mov	  ds, ax
F000:FE78		  lea	  bx, ds:p400.installed_hardware
F000:FE7C		  mov	  ax, [bx]			      ;	returns	value from 0410h. list of installed equipment
F000:FE7E		  pop	  ds
F000:FE7F		  pop	  bx
F000:FE80		  iret
F000:FE80 int_11_handler  endp
F000:FE80
F000:FE81
F000:FE81 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FE81
F000:FE81 ;
F000:FE81 ;	Reports	the number of contiguous 1K memory blocks in the system	(up to
F000:FE81 ;	640K).
F000:FE81 ;
F000:FE81 ;	   On entry:	  No parameters
F000:FE81 ;
F000:FE81 ;	   Returns:	  AX	     Memory size (up to	640K)
F000:FE81
F000:FE81 int_12_handler  proc far				      ;	DATA XREF: F000:FF07o
F000:FE81		  push	  bx
F000:FE82		  push	  ds
F000:FE83		  mov	  ax, 40h ; '@'
F000:FE86		  mov	  ds, ax
F000:FE88		  lea	  bx, ds:p400.base_mem_kb
F000:FE8C		  mov	  ax, [bx]			      ;	returns	base memory size in Kb
F000:FE8E		  pop	  ds
F000:FE8F		  pop	  bx
F000:FE90		  iret
F000:FE90 int_12_handler  endp
F000:FE90
F000:FE91
F000:FE91 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FE91
F000:FE91 ; Attributes:	bp-based frame
F000:FE91
F000:FE91 int_push_regs	  proc near				      ;	CODE XREF: int_13_mainp
F000:FE91							      ;	int_14_handlerp
F000:FE91							      ;	int_09_handlerp
F000:FE91							      ;	int_17_handlerp ...
F000:FE91
F000:FE91 arg_bx	  = word ptr  0Eh
F000:FE91
F000:FE91		  sti					      ;	enable interrupts
F000:FE92		  push	  cx				      ;	bp+c
F000:FE93		  push	  dx				      ;	bp+a
F000:FE94		  push	  si				      ;	bp+8
F000:FE95		  push	  di				      ;	bp+6
F000:FE96		  push	  bp				      ;	bp+4
F000:FE97		  push	  ds				      ;	bp+2
F000:FE98		  push	  es				      ;	bp+0
F000:FE99		  mov	  bp, sp
F000:FE9B		  push	  [bp+arg_bx]			      ;	cx ?
F000:FE9E		  mov	  [bp+arg_bx], bx		      ;	replace	with bx	? I don't understand
F000:FEA1		  retn
F000:FEA1 int_push_regs	  endp ; sp = -10h
F000:FEA1
F000:FEA1 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FEA2		  db 0FFh
F000:FEA3		  db 0FFh
F000:FEA4		  db 0FFh
F000:FEA5 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FEA5
F000:FEA5 int_08_handler:					      ;	DATA XREF: F000:int_08_1f_tableo
F000:FEA5		  jmp	  near ptr int_08_main
F000:FEA8
F000:FEA8 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FEA8
F000:FEA8
F000:FEA8 pop_regs_and_iret proc far				      ;	CODE XREF: int_14_03_handler:int_14_pop_and_iretj
F000:FEA8							      ;	int_09_handler+189j
F000:FEA8							      ;	int_17_02_handler:loc_FF049j
F000:FEA8							      ;	int_10_handler:exitj ...
F000:FEA8		  pop	  es
F000:FEA9		  pop	  ds
F000:FEAA		  pop	  bp
F000:FEAB		  pop	  di
F000:FEAC		  pop	  si
F000:FEAD		  pop	  dx
F000:FEAE		  pop	  cx
F000:FEAF		  pop	  bx
F000:FEB0		  iret
F000:FEB0 pop_regs_and_iret endp ; sp =	 10h
F000:FEB0
F000:FEB1
F000:FEB1 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FEB1
F000:FEB1 ;	Entry:
F000:FEB1 ;	    ah = value to convert
F000:FEB1 ;	    di = max value for ah
F000:FEB1 ;	Returns:
F000:FEB1 ;	    ds = 40h
F000:FEB1 ;	    di = ah * 2
F000:FEB1 ;	    carry: clear if Ok.	set on Error
F000:FEB1
F000:FEB1 convert_ah_to_di_idx proc near			      ;	CODE XREF: int_13_main+7p
F000:FEB1							      ;	int_14_handler+7p
F000:FEB1							      ;	int_16_handler+Bp
F000:FEB1							      ;	int_17_handler+7p ...
F000:FEB1		  push	  ax
F000:FEB2		  mov	  al, ah
F000:FEB4		  xor	  ah, ah
F000:FEB6		  shl	  ax, 1
F000:FEB8		  cmp	  ax, di
F000:FEBA		  mov	  di, ax
F000:FEBC		  mov	  ax, 40h ; '@'
F000:FEBF		  mov	  ds, ax
F000:FEC1		  pop	  ax
F000:FEC2		  jnb	  short	error
F000:FEC4		  clc
F000:FEC5		  retn
F000:FEC6 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FEC6
F000:FEC6 error:						      ;	CODE XREF: convert_ah_to_di_idx+11j
F000:FEC6		  stc
F000:FEC7		  retn
F000:FEC7 convert_ah_to_di_idx endp
F000:FEC7
F000:FEC7 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FEC8		  db 2Bh dup(0FFh)
F000:FEF3 int_08_1f_table dw offset int_08_handler		      ;	DATA XREF: POST_init_ints_and_more+5Do
F000:FEF3							      ;	int 0x08
F000:FEF5		  dw offset int_09_handler		      ;	int 0x09
F000:FEF7		  dw offset int_ack_handler		      ;	int 0x0a
F000:FEF9		  dw offset int_ack_handler		      ;	int 0x0b
F000:FEFB		  dw offset int_ack_handler		      ;	int 0x0c
F000:FEFD		  dw offset int_ack_handler		      ;	int 0x0d
F000:FEFF		  dw offset int_0e_handler		      ;	int 0x0e
F000:FF01		  dw offset int_ack_handler		      ;	int 0x0f
F000:FF03		  dw offset int_10_handler		      ;	int 0x10
F000:FF05		  dw offset int_11_handler		      ;	int 0x11
F000:FF07		  dw offset int_12_handler		      ;	int 0x12
F000:FF09		  dw offset int_13_handler		      ;	int 0x13
F000:FF0B		  dw offset int_14_handler		      ;	int 0x14
F000:FF0D		  dw offset int_15_handler		      ;	int 0x15
F000:FF0F		  dw offset int_16_handler		      ;	int 0x16
F000:FF11		  dw offset int_17_handler		      ;	int 0x17
F000:FF13		  dw offset int_18_handler		      ;	int 0x18
F000:FF15		  dw offset int_19_handler		      ;	int 0x19
F000:FF17		  dw offset int_1a_handler		      ;	int 0x1a
F000:FF19		  dw offset int_do_nothing_handler	      ;	int 0x1b
F000:FF1B		  dw offset int_do_nothing_handler	      ;	int 0x1c
F000:FF1D		  dw offset video_6845_init_tbl_d	      ;	int 0x1d
F000:FF1F		  dw offset diskette_params_values	      ;	int 0x1e
F000:FF21		  dw offset int_1f_charset_128_255	      ;	int 0x1f: charset 128-255
F000:FF23 int_00_07_table dw offset int_do_nothing_handler	      ;	DATA XREF: POST_init_ints_and_more+52o
F000:FF23							      ;	int 0
F000:FF25		  dw offset int_do_nothing_handler	      ;	int 1
F000:FF27		  dw offset int_do_nothing_handler	      ;	int 2
F000:FF29		  dw offset int_do_nothing_handler	      ;	int 3
F000:FF2B		  dw offset int_do_nothing_handler	      ;	int 4
F000:FF2D		  dw offset int_5_handler		      ;	int 5
F000:FF2F		  dw offset int_do_nothing_handler	      ;	int 6
F000:FF31		  dw offset int_do_nothing_handler	      ;	int 7
F000:FF33 int_44_44_table dw offset charset_0_127		      ;	DATA XREF: POST_init_ints_and_more+69o
F000:FF33							      ;	int 0x44: charset 0-127
F000:FF35 value_0040	  dw 40h				      ;	DATA XREF: int_1a_main+1r
F000:FF35							      ;	int_08_main+5r
F000:FF37		  db 1Ch dup(0FFh)
F000:FF53
F000:FF53 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FF53
F000:FF53
F000:FF53 int_do_nothing_handler proc far			      ;	DATA XREF: F000:FF19o
F000:FF53							      ;	F000:FF1Bo
F000:FF53							      ;	F000:int_00_07_tableo
F000:FF53							      ;	F000:FF25o ...
F000:FF53		  iret					      ;	int 0 and many other interrupts
F000:FF53 int_do_nothing_handler endp
F000:FF53
F000:FF54
F000:FF54 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FF54
F000:FF54 ;	Prints the current screen contents to the first	parallel printer
F000:FF54 ;	(LPT1).
F000:FF54 ;
F000:FF54 ;	This interrupt can be called from within a program as well as by means
F000:FF54 ;	of the Shift-PrtSc key combination. The	service	returns	no register
F000:FF54 ;	values but sets	a status code at memory	location 0000:0500h. The
F000:FF54 ;	possible values	of this	status code, and their meanings, are as
F000:FF54 ;	follows:
F000:FF54 ;
F000:FF54 ;	     00h	  Print	Screen not called, or operation	completed
F000:FF54 ;
F000:FF54 ;	     01h	  Print	Screen currently in progress
F000:FF54 ;
F000:FF54 ;	     FFh	  Error	encountered during most	recent Print Screen
F000:FF54
F000:FF54 int_5_handler	  proc far				      ;	DATA XREF: F000:FF2Do
F000:FF54		  push	  ax
F000:FF55		  push	  bx
F000:FF56		  push	  cx
F000:FF57		  push	  dx
F000:FF58		  push	  ds
F000:FF59		  mov	  ax, 50h ; 'P'                       ; ds = 50h (to place error code)
F000:FF5C		  mov	  ds, ax
F000:FF5E		  xor	  bx, bx
F000:FF60		  cmp	  byte ptr [bx], 1		      ;	print screen currently in progress?
F000:FF63		  jz	  short	exit
F000:FF65		  mov	  byte ptr [bx], 1		      ;	print screen in	progress = true
F000:FF68		  sti
F000:FF69		  mov	  ah, 3
F000:FF6B		  int	  10h				      ;	- VIDEO	- READ CURSOR POSITION
F000:FF6B							      ;	BH = page number
F000:FF6B							      ;	Return:	DH,DL =	row,column, CH = cursor	start line, CL = cursor	end line
F000:FF6D		  push	  dx
F000:FF6E		  mov	  ah, 0Fh
F000:FF70		  int	  10h				      ;	- VIDEO	- GET CURRENT VIDEO MODE
F000:FF70							      ;	Return:	AH = number of columns on screen
F000:FF70							      ;	AL = current video mode
F000:FF70							      ;	BH = current active display page
F000:FF72		  mov	  cl, ah
F000:FF74		  call	  near ptr printer_output_new_line
F000:FF77		  xor	  dx, dx
F000:FF79
F000:FF79 l0:							      ;	CODE XREF: int_5_handler+3Cj
F000:FF79							      ;	int_5_handler+48j
F000:FF79		  mov	  ah, 2
F000:FF7B		  int	  10h				      ;	- VIDEO	- SET CURSOR POSITION
F000:FF7B							      ;	DH,DL =	row, column (0,0 = upper left)
F000:FF7B							      ;	BH = page number
F000:FF7D		  mov	  ah, 8
F000:FF7F		  int	  10h				      ;	- VIDEO	- READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
F000:FF7F							      ;	BH = display page
F000:FF7F							      ;	Return:	AL = character
F000:FF7F							      ;	AH = attribute of character (alpha modes)
F000:FF81		  cmp	  al, 0
F000:FF83		  jnz	  short	s0
F000:FF85		  mov	  al, 20h ; ' '                       ; treat 0 as space for printing
F000:FF87
F000:FF87 s0:							      ;	CODE XREF: int_5_handler+2Fj
F000:FF87		  call	  printer_output_char
F000:FF8A		  jnz	  short	update_cursor_position
F000:FF8C		  inc	  dl
F000:FF8E		  cmp	  dl, cl
F000:FF90		  jnz	  short	l0
F000:FF92		  call	  near ptr printer_output_new_line
F000:FF95		  xor	  dl, dl
F000:FF97		  inc	  dh
F000:FF99		  cmp	  dh, 19h
F000:FF9C		  jnz	  short	l0
F000:FF9E		  mov	  cl, 0
F000:FFA0
F000:FFA0 update_cursor_position:				      ;	CODE XREF: int_5_handler+36j
F000:FFA0							      ;	printer_output_new_line+10j
F000:FFA0		  pop	  dx
F000:FFA1		  mov	  ah, 2
F000:FFA3		  int	  10h				      ;	- VIDEO	- SET CURSOR POSITION
F000:FFA3							      ;	DH,DL =	row, column (0,0 = upper left)
F000:FFA3							      ;	BH = page number
F000:FFA5		  mov	  [bx],	cl
F000:FFA7
F000:FFA7 exit:							      ;	CODE XREF: int_5_handler+Fj
F000:FFA7		  pop	  ds
F000:FFA8		  pop	  dx
F000:FFA9		  pop	  cx
F000:FFAA		  pop	  bx
F000:FFAB		  pop	  ax
F000:FFAC		  iret
F000:FFAC int_5_handler	  endp ; sp =  4
F000:FFAC
F000:FFAD
F000:FFAD ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FFAD
F000:FFAD ;	Entry:
F000:FFAD ;	    AL = character to print
F000:FFAD ;	Returns:
F000:FFAD ;	    CL = 255 on	error
F000:FFAD ;	    Zero Flag =	0 if Ok. 1 on error
F000:FFAD
F000:FFAD printer_output_char proc near				      ;	CODE XREF: int_5_handler:s0p
F000:FFAD							      ;	printer_output_new_line+2p
F000:FFAD							      ;	printer_output_new_line+9p
F000:FFAD		  push	  dx
F000:FFAE		  xor	  ah, ah
F000:FFB0		  xor	  dx, dx
F000:FFB2		  int	  17h				      ;	PRINTER	- OUTPUT CHARACTER
F000:FFB2							      ;	AL = character,	DX = printer port (0-3)
F000:FFB2							      ;	Return:	AH = status bits
F000:FFB4		  and	  ah, 1001b
F000:FFB7		  cmp	  ah, 0
F000:FFBA		  jz	  short	s0
F000:FFBC		  mov	  cl, 0FFh			      ;	error
F000:FFBE
F000:FFBE s0:							      ;	CODE XREF: printer_output_char+Dj
F000:FFBE		  pop	  dx
F000:FFBF		  retn
F000:FFBF printer_output_char endp
F000:FFBF
F000:FFC0
F000:FFC0 ; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U	B R O U	T I N E	ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ
F000:FFC0
F000:FFC0
F000:FFC0 printer_output_new_line proc far			      ;	CODE XREF: int_5_handler+20p
F000:FFC0							      ;	int_5_handler+3Ep
F000:FFC0		  mov	  al, 0Dh			      ;	\r
F000:FFC2		  call	  printer_output_char
F000:FFC5		  jnz	  short	exit
F000:FFC7		  mov	  al, 0Ah			      ;	\n
F000:FFC9		  call	  printer_output_char
F000:FFCC		  jnz	  short	exit
F000:FFCE		  retn
F000:FFCF ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FFCF
F000:FFCF exit:							      ;	CODE XREF: printer_output_new_line+5j
F000:FFCF							      ;	printer_output_new_line+Cj
F000:FFCF		  pop	  dx				      ;	pop IP
F000:FFD0		  jmp	  short	update_cursor_position
F000:FFD0 printer_output_new_line endp
F000:FFD0
F000:FFD0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FFD2		  db 1Eh dup(0FFh)
F000:FFF0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FFF0
F000:FFF0 reset_vector:						      ;	CODE XREF: int_09_handler+41Dj
F000:FFF0		  jmp	  POST_entry
F000:FFF0 ; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
F000:FFF5 a060187	  db '06/01/87'                               ; ROM release date
F000:FFFD		  db 0FFh
F000:FFFE unk_FFFFE	  db 0FFh				      ;	Model value. ff	= PC, early XT
F000:FFFF		  db 0FFh
F000:FFFF F000		  ends
F000:FFFF
F000:FFFF
F000:FFFF		  end
